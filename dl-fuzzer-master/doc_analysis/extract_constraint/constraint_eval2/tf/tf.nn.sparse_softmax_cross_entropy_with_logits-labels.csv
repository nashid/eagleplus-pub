descp1,descp2,default,attribute,constraint,in_doc,extracted
,"`Tensor` of shape `[d_0, d_1, ..., d_{r-1}]` (where `r` is rank of`labels` and result) and dtype `int32` or `int64`. Each entry in `labels`must be an index in `[0, num_classes)`. Other values will raise an exception when this op is run on CPU, and return `NaN` for corresponding loss and gradient rows on GPU.",,prim_dtype,"dtype(tf.int32, tf.int64)",,1
,"`Tensor` of shape `[d_0, d_1, ..., d_{r-1}]` (where `r` is rank of`labels` and result) and dtype `int32` or `int64`. Each entry in `labels`must be an index in `[0, num_classes)`. Other values will raise an exception when this op is run on CPU, and return `NaN` for corresponding loss and gradient rows on GPU.",,nonprim_dtype,tensor_t(tf.tensor),,1
,"`Tensor` of shape `[d_0, d_1, ..., d_{r-1}]` (where `r` is rank of`labels` and result) and dtype `int32` or `int64`. Each entry in `labels`must be an index in `[0, num_classes)`. Other values will raise an exception when this op is run on CPU, and return `NaN` for corresponding loss and gradient rows on GPU.",,shape,"shape([...]), ndim(?)",,1
,"`Tensor` of shape `[d_0, d_1, ..., d_{r-1}]` (where `r` is rank of`labels` and result) and dtype `int32` or `int64`. Each entry in `labels`must be an index in `[0, num_classes)`. Other values will raise an exception when this op is run on CPU, and return `NaN` for corresponding loss and gradient rows on GPU.",,validvalue,"range([0,num_classes))",,1
