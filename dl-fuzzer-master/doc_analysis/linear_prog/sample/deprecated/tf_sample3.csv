API,Arg,Descp,Normalized_descp,dtype,tensor_t,structure,shape,ndim,range,enum
tf.image.hsv_to_rgb,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. HSV data to convert. Last dimension must be size 3.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.hsv_to_rgb,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. HSV data to convert. Last dimension must be size 3.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.hsv_to_rgb,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. HSV data to convert. Last dimension must be size 3.",CONSTANT_NUM D or higher rank,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.hsv_to_rgb,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. HSV data to convert. Last dimension must be size 3.",HSV data to convert,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.hsv_to_rgb,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. HSV data to convert. Last dimension must be size 3.",Last dimension must be size CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.debugging.assert_greater,x,Numeric `Tensor`.,D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.summary.write,name,Optional string name for this op.,Optional D_TYPE name for this op,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.write,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.pool,name,Optional. Name of the op.,ONE_WORD Optional,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.pool,name,Optional. Name of the op.,Name of the op,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.pool,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Lambda,arguments,"Optional dictionary of keyword arguments to be passed to the function. Input shape: Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model. Output shape: Specified by `output_shape` argument",Optional D_STRUCTURE of keyword arguments to be passed to the PARAM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Lambda,arguments,"Optional dictionary of keyword arguments to be passed to the function. Input shape: Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model. Output shape: Specified by `output_shape` argument",Input shape Arbitrary,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Lambda,arguments,"Optional dictionary of keyword arguments to be passed to the function. Input shape: Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model. Output shape: Specified by `output_shape` argument",Use the keyword argument input_shape BSTR when using this layer as the first layer in a model,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Lambda,arguments,"Optional dictionary of keyword arguments to be passed to the function. Input shape: Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model. Output shape: Specified by `output_shape` argument",Output shape Specified by PARAM argument,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Lambda,arguments,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.AveragePooling2D,pool_size,"integer or tuple of 2 integers, factors by which to downscale (vertical, horizontal).`(2, 2)` will halve the input in both spatial dimension. If only one integer is specified, the same window length will be used for both dimensions.",D_TYPE or D_STRUCTURE of CONSTANT_NUM D_TYPE factors by which to downscale BSTR BSTR will halve the input in both spatial dimension,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.AveragePooling2D,pool_size,"integer or tuple of 2 integers, factors by which to downscale (vertical, horizontal).`(2, 2)` will halve the input in both spatial dimension. If only one integer is specified, the same window length will be used for both dimensions.",If only one D_TYPE is specified the same window length will be used for both dimensions,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.AveragePooling2D,pool_size,"DF: (2, 2)",DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.ragged.constant,name,A name prefix for the returned tensor (optional).,A name prefix for the returned D_STRUCTURE BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.constant,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sufficient_statistics,keepdims,produce statistics with the same dimensionality as the input.,produce statistics with the same dimensionality as the input,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sufficient_statistics,keepdims,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv2D,bias_regularizer,Regularizer function applied to the bias vector.,Regularizer function applied to the bias vector,,,,,,,
tf.keras.layers.Conv2D,bias_regularizer,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.MaxPool1D,padding,"One of `""valid""` or `""same""` (case-insensitive).",One of QSTR BSTR,D_TYPE,,,,,,QSTR
tf.keras.layers.MaxPool1D,padding,DF: valid,DEFAULT DF_STR,D_TYPE,,,,,,QSTR
tf.image.non_max_suppression_overlaps,overlaps,"A 2-D float `Tensor` of shape `[num_boxes, num_boxes]`.",A CONSTANT_NUM D D_TYPE D_STRUCTURE of shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.keras.utils.plot_model,model,A Keras model instance,A Keras model instance,,,,,,,
tf.image.non_max_suppression,score_threshold,A float representing the threshold for deciding when to remove boxes based on score.,A D_TYPE representing the threshold for deciding when to remove PARAM based on score,D_TYPE,,,,CONSTANT_VAL,,
tf.image.non_max_suppression,score_threshold,DF: float(-inf),D_TYPE BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTM,time_major,"The shape format of the `inputs` and `outputs` tensors. If True, the inputs and outputs will be in shape`[timesteps, batch, feature]`, whereas in the False case, it will be`[batch, timesteps, feature]`. Using `time_major = True` is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.",The shape format of the QSTR D_STRUCTURE,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.LSTM,time_major,"The shape format of the `inputs` and `outputs` tensors. If True, the inputs and outputs will be in shape`[timesteps, batch, feature]`, whereas in the False case, it will be`[batch, timesteps, feature]`. Using `time_major = True` is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.",If CONSTANT_BOOL the inputs and outputs will be in shape BSTR whereas in the CONSTANT_BOOL case it will be BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.LSTM,time_major,"The shape format of the `inputs` and `outputs` tensors. If True, the inputs and outputs will be in shape`[timesteps, batch, feature]`, whereas in the False case, it will be`[batch, timesteps, feature]`. Using `time_major = True` is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.",Using time_major CONSTANT_BOOL is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.LSTM,time_major,"The shape format of the `inputs` and `outputs` tensors. If True, the inputs and outputs will be in shape`[timesteps, batch, feature]`, whereas in the False case, it will be`[batch, timesteps, feature]`. Using `time_major = True` is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.",However most TensorFlow data is batch major so by default this function accepts input and emits output in batch major form,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.LSTM,time_major,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.numpy_function,func,"A Python function, which accepts `numpy.ndarray` objects as arguments and returns a list of `numpy.ndarray` objects (or a single`numpy.ndarray`). This function must accept as many arguments as there are tensors in `inp`, and these argument types will match the corresponding`tf.Tensor` objects in `inp`. The returns `numpy.ndarray`s must match the number and types defined `Tout`. Important Note: Input and output `numpy.ndarray`s of `func` are not guaranteed to be copies. In some cases their underlying memory will be shared with the corresponding TensorFlow tensors. In-place modification or storing `func` input or return values in python datastructures without explicit (np.)copy can have non-deterministic consequences.",A Python function which accepts numpy D_STRUCTURE objects as arguments and returns a D_STRUCTURE of numpy D_STRUCTURE objects or a single numpy D_STRUCTURE,,,,,,,
tf.numpy_function,func,"A Python function, which accepts `numpy.ndarray` objects as arguments and returns a list of `numpy.ndarray` objects (or a single`numpy.ndarray`). This function must accept as many arguments as there are tensors in `inp`, and these argument types will match the corresponding`tf.Tensor` objects in `inp`. The returns `numpy.ndarray`s must match the number and types defined `Tout`. Important Note: Input and output `numpy.ndarray`s of `func` are not guaranteed to be copies. In some cases their underlying memory will be shared with the corresponding TensorFlow tensors. In-place modification or storing `func` input or return values in python datastructures without explicit (np.)copy can have non-deterministic consequences.",This function must accept as many arguments as there are D_STRUCTURE in PARAM and these argument types will match the correspondingD_STRUCTURE objects in PARAM,,,,,,,
tf.numpy_function,func,"A Python function, which accepts `numpy.ndarray` objects as arguments and returns a list of `numpy.ndarray` objects (or a single`numpy.ndarray`). This function must accept as many arguments as there are tensors in `inp`, and these argument types will match the corresponding`tf.Tensor` objects in `inp`. The returns `numpy.ndarray`s must match the number and types defined `Tout`. Important Note: Input and output `numpy.ndarray`s of `func` are not guaranteed to be copies. In some cases their underlying memory will be shared with the corresponding TensorFlow tensors. In-place modification or storing `func` input or return values in python datastructures without explicit (np.)copy can have non-deterministic consequences.",The returns numpy D_STRUCTUREs must match the number and types defined PARAM,,,,,,,
tf.numpy_function,func,"A Python function, which accepts `numpy.ndarray` objects as arguments and returns a list of `numpy.ndarray` objects (or a single`numpy.ndarray`). This function must accept as many arguments as there are tensors in `inp`, and these argument types will match the corresponding`tf.Tensor` objects in `inp`. The returns `numpy.ndarray`s must match the number and types defined `Tout`. Important Note: Input and output `numpy.ndarray`s of `func` are not guaranteed to be copies. In some cases their underlying memory will be shared with the corresponding TensorFlow tensors. In-place modification or storing `func` input or return values in python datastructures without explicit (np.)copy can have non-deterministic consequences.",Important Note Input and output numpy D_STRUCTUREs of QSTR are not guaranteed to be copies,,,,,,,
tf.numpy_function,func,"A Python function, which accepts `numpy.ndarray` objects as arguments and returns a list of `numpy.ndarray` objects (or a single`numpy.ndarray`). This function must accept as many arguments as there are tensors in `inp`, and these argument types will match the corresponding`tf.Tensor` objects in `inp`. The returns `numpy.ndarray`s must match the number and types defined `Tout`. Important Note: Input and output `numpy.ndarray`s of `func` are not guaranteed to be copies. In some cases their underlying memory will be shared with the corresponding TensorFlow tensors. In-place modification or storing `func` input or return values in python datastructures without explicit (np.)copy can have non-deterministic consequences.",In some cases their underlying memory will be shared with the corresponding TensorFlow D_STRUCTURE,,,,,,,
tf.numpy_function,func,"A Python function, which accepts `numpy.ndarray` objects as arguments and returns a list of `numpy.ndarray` objects (or a single`numpy.ndarray`). This function must accept as many arguments as there are tensors in `inp`, and these argument types will match the corresponding`tf.Tensor` objects in `inp`. The returns `numpy.ndarray`s must match the number and types defined `Tout`. Important Note: Input and output `numpy.ndarray`s of `func` are not guaranteed to be copies. In some cases their underlying memory will be shared with the corresponding TensorFlow tensors. In-place modification or storing `func` input or return values in python datastructures without explicit (np.)copy can have non-deterministic consequences.",In place modification or storing QSTR input or return values in python datastructures without explicit np,,,,,,,
tf.numpy_function,func,"A Python function, which accepts `numpy.ndarray` objects as arguments and returns a list of `numpy.ndarray` objects (or a single`numpy.ndarray`). This function must accept as many arguments as there are tensors in `inp`, and these argument types will match the corresponding`tf.Tensor` objects in `inp`. The returns `numpy.ndarray`s must match the number and types defined `Tout`. Important Note: Input and output `numpy.ndarray`s of `func` are not guaranteed to be copies. In some cases their underlying memory will be shared with the corresponding TensorFlow tensors. In-place modification or storing `func` input or return values in python datastructures without explicit (np.)copy can have non-deterministic consequences.",copy can have non deterministic consequences,,,,,,,
tf.bitwise.right_shift,y,A `Tensor`. Must have the same type as `x`.,A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.bitwise.right_shift,y,A `Tensor`. Must have the same type as `x`.,Must have the same type as QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.nn.conv2d_transpose,strides,"An int or list of `ints` that has length `1`, `2` or `4`.  The stride of the sliding window for each dimension of `input`. If a single value is given it is replicated in the `H` and `W` dimension. By default the `N` and `C` dimensions are set to 0. The dimension order is determined by the value of `data_format`, see below for details.",An D_TYPE or D_STRUCTURE of D_TYPE that has length CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.conv2d_transpose,strides,"An int or list of `ints` that has length `1`, `2` or `4`.  The stride of the sliding window for each dimension of `input`. If a single value is given it is replicated in the `H` and `W` dimension. By default the `N` and `C` dimensions are set to 0. The dimension order is determined by the value of `data_format`, see below for details.",The stride of the sliding window for each dimension of PARAM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.conv2d_transpose,strides,"An int or list of `ints` that has length `1`, `2` or `4`.  The stride of the sliding window for each dimension of `input`. If a single value is given it is replicated in the `H` and `W` dimension. By default the `N` and `C` dimensions are set to 0. The dimension order is determined by the value of `data_format`, see below for details.",If a single value is given it is replicated in the QSTR dimension,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.conv2d_transpose,strides,"An int or list of `ints` that has length `1`, `2` or `4`.  The stride of the sliding window for each dimension of `input`. If a single value is given it is replicated in the `H` and `W` dimension. By default the `N` and `C` dimensions are set to 0. The dimension order is determined by the value of `data_format`, see below for details.",By default the QSTR dimensions are set to CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.conv2d_transpose,strides,"An int or list of `ints` that has length `1`, `2` or `4`.  The stride of the sliding window for each dimension of `input`. If a single value is given it is replicated in the `H` and `W` dimension. By default the `N` and `C` dimensions are set to 0. The dimension order is determined by the value of `data_format`, see below for details.",The dimension order is determined by the value of PARAM see below for details,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.MaxPool3D,padding,"One of `""valid""` or `""same""` (case-insensitive).",One of QSTR BSTR,D_TYPE,,,,,,QSTR
tf.keras.layers.MaxPool3D,padding,DF: valid,DEFAULT DF_STR,D_TYPE,,,,,,QSTR
tf.nn.separable_conv2d,name,A name for this operation (optional).,A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.separable_conv2d,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.max_pool1d,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.max_pool1d,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_integer,x,A `Tensor`.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.train.latest_checkpoint,latest_filename,Optional name for the protocol buffer file that contains the list of most recent checkpoint filenames. See the corresponding argument to `Saver.save()`.,Optional name for the protocol buffer file that contains the D_STRUCTURE of most recent checkpoint filenames,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.train.latest_checkpoint,latest_filename,Optional name for the protocol buffer file that contains the list of most recent checkpoint filenames. See the corresponding argument to `Saver.save()`.,See the corresponding argument to Saver save,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.train.latest_checkpoint,latest_filename,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.math.reduce_prod,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reduce_prod,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nest.is_nested,seq,an input sequence.,an input D_STRUCTURE,,,,,,,
tf.sets.intersection,b,"`Tensor` or `SparseTensor` of the same type as `a`. If sparse, indices must be sorted in row-major order.",D_STRUCTURE of the same type as QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.sets.intersection,b,"`Tensor` or `SparseTensor` of the same type as `a`. If sparse, indices must be sorted in row-major order.",If sparse indices must be sorted in row major order,D_TYPE,D_STRUCTURE,,,,,
tf.linalg.inv,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.inv,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.random_uniform,minval,"A float, lower boundary of the uniform distribution to draw samples.",A D_TYPE lower boundary of the uniform distribution to draw samples,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.random_uniform,minval,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.local_conv2d,inputs,"4D tensor with shape: (batch_size, filters, new_rows, new_cols) if data_format='channels_first' or 4D tensor with shape: (batch_size, new_rows, new_cols, filters) if data_format='channels_last'.",CONSTANT_NUM D D_STRUCTURE with shape BSTR if PARAM QSTR or CONSTANT_NUM D D_STRUCTURE with shape BSTR if PARAM QSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.extract_volume_patches,input,"A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `half`, `uint32`, `uint64`. 5-D Tensor with shape `[batch, in_planes, in_rows, in_cols, depth]`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.extract_volume_patches,input,"A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `half`, `uint32`, `uint64`. 5-D Tensor with shape `[batch, in_planes, in_rows, in_cols, depth]`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.extract_volume_patches,input,"A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `half`, `uint32`, `uint64`. 5-D Tensor with shape `[batch, in_planes, in_rows, in_cols, depth]`.",CONSTANT_NUM D D_STRUCTURE with shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",A RNN cell instance or a D_STRUCTURE of RNN cell instances,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",A RNN cell is a class that has A call BSTR method returning BSTR,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",The call method of the cell can also take the optional argument QSTR see section QSTR below A QSTR attribute,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",This can be a single D_TYPE BSTR in which case it is the size of the recurrent state,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",This can also be a D_STRUCTURE of D_TYPE BSTR,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",The QSTR can also be TensorShape or D_STRUCTURE of TensorShape to represent high dimension state A QSTR attribute,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",This can be a single D_TYPE or a TensorShape which represent the shape of the output,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",For backward compatible reason if this attribute is not available for the cell the value will be inferred by the first element of the QSTR A get_initial_state inputs None batch_size None dtype None QSTR call as the initial state if the user didn t specify any initial state via other means,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",The returned initial state should have a shape of BSTR,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",The cell might choose to create a D_STRUCTURE full of zeros or full of other values based on the cell implementation QSTR is the input D_STRUCTURE to the RNN layer which should contain the batch size as its shape BSTR and also dtype,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",Note that the shape BSTR might be QSTR during the graph construction,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",Either the QSTR or the pair of QSTR are provided QSTR is a scalar D_STRUCTURE that represents the batch size of the inputs,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",QSTR is D_TYPE that represents the dtype of the inputs,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",For backward compatible reason if this method is not implemented by the cell the RNN layer will create a zero filled D_STRUCTURE with the size of BSTR,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.RNN,cell,"A RNN cell instance or a list of RNN cell instances. A RNN cell is a class that has: A `call(input_at_t, states_at_t)` method, returning`(output_at_t, states_at_t_plus_1)`. The call method of the cell can also take the optional argument `constants`, see section ""Note on passing external constants"" below.A `state_size` attribute. This can be a single integer (single state) in which case it is the size of the recurrent state. This can also be a list/tuple of integers (one size per state). The `state_size` can also be TensorShape or tuple/list of TensorShape, to represent high dimension state.A `output_size` attribute. This can be a single integer or a TensorShape, which represent the shape of the output. For backward compatible reason, if this attribute is not available for the cell, the value will be inferred by the first element of the`state_size`.A `get_initial_state(inputs=None, batch_size=None, dtype=None)`method that creates a tensor meant to be fed to `call()` as the initial state, if the user didn't specify any initial state via other means. The returned initial state should have a shape of [batch_size, cell.state_size]. The cell might choose to create a tensor full of zeros, or full of other values based on the cell's implementation.`inputs` is the input tensor to the RNN layer, which should contain the batch size as its shape[0], and also dtype. Note that the shape[0] might be `None` during the graph construction. Either the `inputs` or the pair of `batch_size` and `dtype` are provided.`batch_size` is a scalar tensor that represents the batch size of the inputs. `dtype` is `tf.DType` that represents the dtype of the inputs. For backward compatible reason, if this method is not implemented by the cell, the RNN layer will create a zero filled tensor with the size of [batch_size, cell.state_size]. In the case that `cell` is a list of RNN cell instances, the cells will be stacked on top of each other in the RNN, resulting in an efficient stacked RNN. ",In the case that QSTR is a D_STRUCTURE of RNN cell instances the cells will be stacked on top of each other in the RNN resulting in an efficient stacked RNN,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.strings.unicode_transcode,input,A `Tensor` of type `string`. The text to be processed. Can have any shape.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.strings.unicode_transcode,input,A `Tensor` of type `string`. The text to be processed. Can have any shape.,The text to be processed,D_TYPE,D_STRUCTURE,,,,,
tf.strings.unicode_transcode,input,A `Tensor` of type `string`. The text to be processed. Can have any shape.,Can have any shape,D_TYPE,D_STRUCTURE,,,,,
tf.keras.layers.Conv2D,bias_initializer,Initializer for the bias vector.,Initializer for the bias vector,D_TYPE,,,,,,
tf.keras.layers.Conv2D,bias_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.debugging.assert_negative,summarize,Print this many entries of each tensor.,Print this many entries of each D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.assert_negative,summarize,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.config.list_logical_devices,device_type,"(optional string) Only include devices matching this device type. For example ""CPU"" or ""GPU"".",BSTR Only include devices matching this device type,D_TYPE,,,,,,
tf.config.list_logical_devices,device_type,"(optional string) Only include devices matching this device type. For example ""CPU"" or ""GPU"".",For example QSTR,D_TYPE,,,,,,
tf.config.list_logical_devices,device_type,DF: None,DEFAULT None,D_TYPE,,,,,,
tf.math.reciprocal_no_nan,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reciprocal_no_nan,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_near,atol,"`Tensor`.  Same `dtype` as, and broadcastable to, `x`. The absolute tolerance.  Default is `10 * eps`.",ONE_WORD D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_near,atol,"`Tensor`.  Same `dtype` as, and broadcastable to, `x`. The absolute tolerance.  Default is `10 * eps`.",Same QSTR as and broadcastable to QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_near,atol,"`Tensor`.  Same `dtype` as, and broadcastable to, `x`. The absolute tolerance.  Default is `10 * eps`.",The absolute tolerance,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_near,atol,"`Tensor`.  Same `dtype` as, and broadcastable to, `x`. The absolute tolerance.  Default is `10 * eps`.",Default is CONSTANT_NUM eps,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_near,atol,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,,,
tf.keras.layers.experimental.preprocessing.PreprocessingLayer,data,"The data to train on. It can be passed either as a tf.data Dataset, or as a numpy array.",The data to train on,,,,,,,
tf.keras.layers.experimental.preprocessing.PreprocessingLayer,data,"The data to train on. It can be passed either as a tf.data Dataset, or as a numpy array.",It can be passed either as a tf data Dataset or as a numpy D_STRUCTURE,,,,,,,
tf.keras.layers.experimental.preprocessing.PreprocessingLayer,data,DF: None,DEFAULT None,,,,,,,
tf.fingerprint,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.fingerprint,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.einsum,equation,"a `str` describing the contraction, in the same format as`numpy.einsum`.",a D_TYPE describing the contraction in the same format as numpy einsum,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.normalize,tensor,"`Tensor` of types `float32`, `float64`, `complex64`, `complex128`",D_STRUCTURE of types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.keras.backend.eye,size,"Integer, number of rows/columns.",D_TYPE number of rows columns,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.math.reduce_min,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reduce_min,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.compat.as_str_any,value,A object that can be converted to `str`.,A object that can be converted to D_TYPE,,,,,,,
tf.image.random_hue,seed,An operation-specific seed. It will be used in conjunction with the graph-level seed to determine the real seeds that will be used in this operation. Please see the documentation of set_random_seed for its interaction with the graph-level random seed.,An operation specific seed,,,,,,,
tf.image.random_hue,seed,An operation-specific seed. It will be used in conjunction with the graph-level seed to determine the real seeds that will be used in this operation. Please see the documentation of set_random_seed for its interaction with the graph-level random seed.,It will be used in conjunction with the graph level seed to determine the real seeds that will be used in this operation,,,,,,,
tf.image.random_hue,seed,An operation-specific seed. It will be used in conjunction with the graph-level seed to determine the real seeds that will be used in this operation. Please see the documentation of set_random_seed for its interaction with the graph-level random seed.,Please see the documentation of set_random_seed for its interaction with the graph level random seed,,,,,,,
tf.image.random_hue,seed,DF: None,DEFAULT None,,,,,,,
tf.space_to_batch,input,"A `Tensor`. N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`, where spatial_shape has `M` dimensions.",A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.space_to_batch,input,"A `Tensor`. N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`, where spatial_shape has `M` dimensions.",N D with shape input_shape BSTR spatial_shape remaining_shape where spatial_shape has QSTR dimensions,,D_STRUCTURE,,,,,
tf.keras.layers.SimpleRNN,go_backwards,"Boolean (default False). If True, process the input sequence backwards and return the reversed sequence.",D_TYPE BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNN,go_backwards,"Boolean (default False). If True, process the input sequence backwards and return the reversed sequence.",If CONSTANT_BOOL process the input D_STRUCTURE backwards and return the reversed D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNN,go_backwards,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.solve,matrix,"A `Tensor`. Must be one of the following types: `float64`, `float32`, `half`, `complex64`, `complex128`. Shape is `[..., M, M]`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.linalg.solve,matrix,"A `Tensor`. Must be one of the following types: `float64`, `float32`, `half`, `complex64`, `complex128`. Shape is `[..., M, M]`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.linalg.solve,matrix,"A `Tensor`. Must be one of the following types: `float64`, `float32`, `half`, `complex64`, `complex128`. Shape is `[..., M, M]`.",Shape is BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.io.decode_jpeg,contents,A `Tensor` of type `string`. 0-D.  The JPEG-encoded image.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.io.decode_jpeg,contents,A `Tensor` of type `string`. 0-D.  The JPEG-encoded image.,CONSTANT_NUM D,D_TYPE,D_STRUCTURE,,,,,
tf.io.decode_jpeg,contents,A `Tensor` of type `string`. 0-D.  The JPEG-encoded image.,The JPEG encoded image,D_TYPE,D_STRUCTURE,,,,,
tf.nn.atrous_conv2d_transpose,filters,"A 4-D `Tensor` with the same type as `value` and shape`[filter_height, filter_width, out_channels, in_channels]`. `filters`'`in_channels` dimension must match that of `value`. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height `filter_height + (filter_height - 1) * (rate - 1)` and effective width `filter_width + (filter_width - 1) * (rate - 1)`, produced by inserting `rate - 1` zeros along consecutive elements across the`filters`' spatial dimensions.",A CONSTANT_NUM D D_STRUCTURE with the same type as PARAM and shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.atrous_conv2d_transpose,filters,"A 4-D `Tensor` with the same type as `value` and shape`[filter_height, filter_width, out_channels, in_channels]`. `filters`'`in_channels` dimension must match that of `value`. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height `filter_height + (filter_height - 1) * (rate - 1)` and effective width `filter_width + (filter_width - 1) * (rate - 1)`, produced by inserting `rate - 1` zeros along consecutive elements across the`filters`' spatial dimensions.",QSTR in_channels dimension must match that of PARAM,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.atrous_conv2d_transpose,filters,"A 4-D `Tensor` with the same type as `value` and shape`[filter_height, filter_width, out_channels, in_channels]`. `filters`'`in_channels` dimension must match that of `value`. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height `filter_height + (filter_height - 1) * (rate - 1)` and effective width `filter_width + (filter_width - 1) * (rate - 1)`, produced by inserting `rate - 1` zeros along consecutive elements across the`filters`' spatial dimensions.",Atrous convolution is equivalent to standard convolution with upsampled filters with effective height QSTR filter_width BSTR produced by inserting PARAM CONSTANT_NUM zeros along consecutive elements across the QSTR spatial dimensions,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.linalg.matmul,transpose_b,"If `True`, `b` is transposed before multiplication.",If CONSTANT_BOOL QSTR is transposed before multiplication,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.matmul,transpose_b,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.bessel_i1e,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.bessel_i1e,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.quantization.fake_quant_with_min_max_vars_gradient,narrow_range,An optional `bool`. Defaults to `False`. Whether to quantize into 2^num_bits - 1 distinct values.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_vars_gradient,narrow_range,An optional `bool`. Defaults to `False`. Whether to quantize into 2^num_bits - 1 distinct values.,Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_vars_gradient,narrow_range,An optional `bool`. Defaults to `False`. Whether to quantize into 2^num_bits - 1 distinct values.,Whether to quantize into CONSTANT_NUM PARAM CONSTANT_NUM distinct values,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_vars_gradient,narrow_range,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.betainc,b,A `Tensor`. Must have the same type as `a`.,A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.betainc,b,A `Tensor`. Must have the same type as `a`.,Must have the same type as QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.nn.RNNCellDropoutWrapper,input_size,(optional) (possibly nested tuple of) `TensorShape` objects containing the depth(s) of the input tensors expected to be passed in to the `DropoutWrapper`.  Required and used <strong>iff</strong> `variational_recurrent = True` and `input_keep_prob < 1`.,BSTR QSTR objects containing the depth BSTR of the input D_STRUCTURE expected to be passed in to the QSTR,D_TYPE,,,,,"[0,inf)",
tf.nn.RNNCellDropoutWrapper,input_size,(optional) (possibly nested tuple of) `TensorShape` objects containing the depth(s) of the input tensors expected to be passed in to the `DropoutWrapper`.  Required and used <strong>iff</strong> `variational_recurrent = True` and `input_keep_prob < 1`.,Required and used REXPR REXPR strong REXPR CONSTANT_BOOL and PARAM REXPR,D_TYPE,,,,,"[0,inf)",
tf.nn.RNNCellDropoutWrapper,input_size,DF: None,DEFAULT None,D_TYPE,,,,,"[0,inf)",
tf.summary.experimental.write_raw_pb,name,Optional string name for this op.,Optional D_TYPE name for this op,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.experimental.write_raw_pb,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNN,kernel_constraint,Constraint function applied to the `kernel` weights matrix. Default: `None`.,Constraint function applied to the QSTR weights matrix,,,,,,,
tf.keras.layers.SimpleRNN,kernel_constraint,Constraint function applied to the `kernel` weights matrix. Default: `None`.,Default QSTR,,,,,,,
tf.keras.layers.SimpleRNN,kernel_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.depthwise_conv2d,padding,"string, `""same""` or `""valid""`.",D_TYPE QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.depthwise_conv2d,padding,DF: valid,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.linalg.lu_solve,name,"Python `str` name given to ops managed by this object. Default value: `None` (i.e., 'lu_solve').",Python D_TYPE name given to ops managed by this object,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.lu_solve,name,"Python `str` name given to ops managed by this object. Default value: `None` (i.e., 'lu_solve').",Default value QSTR i e QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.lu_solve,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.categorical_crossentropy,output,"A tensor resulting from a softmax (unless `from_logits` is True, in which case `output` is expected to be the logits).",A D_STRUCTURE resulting from a softmax unless PARAM is CONSTANT_BOOL in which case QSTR is expected to be the logits,,D_STRUCTURE,,,,,
tf.nn.selu,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.selu,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.control_dependencies,control_inputs,"A list of `Operation` or `Tensor` objects which must be executed or computed before running the operations defined in the context. Can also be `None` to clear the control dependencies. If eager execution is enabled, any callable object in the `control_inputs` list will be called.",A D_STRUCTURE of QSTR or D_STRUCTURE objects which must be executed or computed before running the operations defined in the context,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.control_dependencies,control_inputs,"A list of `Operation` or `Tensor` objects which must be executed or computed before running the operations defined in the context. Can also be `None` to clear the control dependencies. If eager execution is enabled, any callable object in the `control_inputs` list will be called.",Can also be QSTR to clear the control dependencies,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.control_dependencies,control_inputs,"A list of `Operation` or `Tensor` objects which must be executed or computed before running the operations defined in the context. Can also be `None` to clear the control dependencies. If eager execution is enabled, any callable object in the `control_inputs` list will be called.",If eager execution is enabled any callable object in the QSTR D_STRUCTURE will be called,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.math.polygamma,x,A `Tensor`. Must have the same type as `a`.,A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.polygamma,x,A `Tensor`. Must have the same type as `a`.,Must have the same type as QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.quantization.quantize,narrow_range,An optional `bool`. Defaults to `False`.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.quantize,narrow_range,An optional `bool`. Defaults to `False`.,Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.quantize,narrow_range,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.bucketized_column,source_column,A one-dimensional dense column which is generated with`numeric_column`.,A one dimensional dense column which is generated with QSTR,,,,,,,
tf.math.sinh,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.sinh,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.diag,num_cols,"The number of columns of the output matrix. If it is not provided, the op assumes the output matrix is a square matrix and infers the matrix size from `d_lower`, `d_upper`, and the innermost dimension of `diagonal`.",The number of columns of the output matrix,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.linalg.diag,num_cols,"The number of columns of the output matrix. If it is not provided, the op assumes the output matrix is a square matrix and infers the matrix size from `d_lower`, `d_upper`, and the innermost dimension of `diagonal`.",If it is not provided the op assumes the output matrix is a square matrix and infers the matrix size from QSTR and the innermost dimension of PARAM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.linalg.diag,num_cols,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.roll,shift,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Dimension must be 0-D or 1-D. `shift[i]` specifies the number of places by which elements are shifted positively (towards larger indices) along the dimension specified by `axis[i]`. Negative shifts will roll the elements in the opposite direction.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.roll,shift,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Dimension must be 0-D or 1-D. `shift[i]` specifies the number of places by which elements are shifted positively (towards larger indices) along the dimension specified by `axis[i]`. Negative shifts will roll the elements in the opposite direction.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.roll,shift,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Dimension must be 0-D or 1-D. `shift[i]` specifies the number of places by which elements are shifted positively (towards larger indices) along the dimension specified by `axis[i]`. Negative shifts will roll the elements in the opposite direction.",Dimension must be CONSTANT_NUM D or CONSTANT_NUM D shift BSTR specifies the number of places by which elements are shifted positively BSTR along the dimension specified by PARAM BSTR,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.roll,shift,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Dimension must be 0-D or 1-D. `shift[i]` specifies the number of places by which elements are shifted positively (towards larger indices) along the dimension specified by `axis[i]`. Negative shifts will roll the elements in the opposite direction.",Negative shifts will roll the elements in the opposite direction,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.summary.trace_on,graph,"If True, enables collection of executed graphs. It includes ones from tf.function invocation and ones from the legacy graph mode. The default is True.",If CONSTANT_BOOL enables collection of executed graphs,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.trace_on,graph,"If True, enables collection of executed graphs. It includes ones from tf.function invocation and ones from the legacy graph mode. The default is True.",It includes ones from tf function invocation and ones from the legacy graph mode,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.trace_on,graph,"If True, enables collection of executed graphs. It includes ones from tf.function invocation and ones from the legacy graph mode. The default is True.",The default is CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.trace_on,graph,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.copy_to_device,target_device,The name of a device to which elements will be copied.,The name of a device to which elements will be copied,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.experimental.enable_dump_debug_info,circular_buffer_size,"Size of the circular buffers for execution events. These circular buffers are designed to reduce the overhead of debugging dumping. They hold the most recent debug events concerning eager execution of ops and `tf.function`s and traces of tensor values computed inside`tf.function`s. They are written to the file system only when the proper flushing method is called (see description of return values below). Expected to be an integer. If <= 0, the circular-buffer behavior will be disabled, i.e., the execution debug events will be written to the file writers in the same way as non-execution events such as op creations and source-file snapshots.",Size of the circular buffers for execution events,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.experimental.enable_dump_debug_info,circular_buffer_size,"Size of the circular buffers for execution events. These circular buffers are designed to reduce the overhead of debugging dumping. They hold the most recent debug events concerning eager execution of ops and `tf.function`s and traces of tensor values computed inside`tf.function`s. They are written to the file system only when the proper flushing method is called (see description of return values below). Expected to be an integer. If <= 0, the circular-buffer behavior will be disabled, i.e., the execution debug events will be written to the file writers in the same way as non-execution events such as op creations and source-file snapshots.",These circular buffers are designed to reduce the overhead of debugging dumping,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.experimental.enable_dump_debug_info,circular_buffer_size,"Size of the circular buffers for execution events. These circular buffers are designed to reduce the overhead of debugging dumping. They hold the most recent debug events concerning eager execution of ops and `tf.function`s and traces of tensor values computed inside`tf.function`s. They are written to the file system only when the proper flushing method is called (see description of return values below). Expected to be an integer. If <= 0, the circular-buffer behavior will be disabled, i.e., the execution debug events will be written to the file writers in the same way as non-execution events such as op creations and source-file snapshots.",They hold the most recent debug events concerning eager execution of ops and tf function QSTR tf function s,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.experimental.enable_dump_debug_info,circular_buffer_size,"Size of the circular buffers for execution events. These circular buffers are designed to reduce the overhead of debugging dumping. They hold the most recent debug events concerning eager execution of ops and `tf.function`s and traces of tensor values computed inside`tf.function`s. They are written to the file system only when the proper flushing method is called (see description of return values below). Expected to be an integer. If <= 0, the circular-buffer behavior will be disabled, i.e., the execution debug events will be written to the file writers in the same way as non-execution events such as op creations and source-file snapshots.",They are written to the file system only when the proper flushing method is called BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.experimental.enable_dump_debug_info,circular_buffer_size,"Size of the circular buffers for execution events. These circular buffers are designed to reduce the overhead of debugging dumping. They hold the most recent debug events concerning eager execution of ops and `tf.function`s and traces of tensor values computed inside`tf.function`s. They are written to the file system only when the proper flushing method is called (see description of return values below). Expected to be an integer. If <= 0, the circular-buffer behavior will be disabled, i.e., the execution debug events will be written to the file writers in the same way as non-execution events such as op creations and source-file snapshots.",Expected to be an D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.experimental.enable_dump_debug_info,circular_buffer_size,"Size of the circular buffers for execution events. These circular buffers are designed to reduce the overhead of debugging dumping. They hold the most recent debug events concerning eager execution of ops and `tf.function`s and traces of tensor values computed inside`tf.function`s. They are written to the file system only when the proper flushing method is called (see description of return values below). Expected to be an integer. If <= 0, the circular-buffer behavior will be disabled, i.e., the execution debug events will be written to the file writers in the same way as non-execution events such as op creations and source-file snapshots.",If REXPR the circular buffer behavior will be disabled i e the execution debug events will be written to the file writers in the same way as non execution events such as op creations and source file snapshots,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.experimental.enable_dump_debug_info,circular_buffer_size,DF: 1000,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.io.gfile.stat,path,"string, path to a file",D_TYPE path to a file,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_batched_features_dataset,features,A `dict` mapping feature keys to `FixedLenFeature` or`VarLenFeature` values. See `tf.io.parse_example`.,A D_STRUCTURE mapping feature keys to QSTR values,,,D_STRUCTURE,,,,
tf.data.experimental.make_batched_features_dataset,features,A `dict` mapping feature keys to `FixedLenFeature` or`VarLenFeature` values. See `tf.io.parse_example`.,See tf io parse_example,,,D_STRUCTURE,,,,
tf.estimator.classifier_parse_example_spec,feature_columns,An iterable containing all feature columns. All items should be instances of classes derived from `FeatureColumn`.,An D_STRUCTURE containing all feature columns,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.estimator.classifier_parse_example_spec,feature_columns,An iterable containing all feature columns. All items should be instances of classes derived from `FeatureColumn`.,All items should be instances of classes derived from QSTR,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.math.softplus,features,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.softplus,features,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_greater,y,"Numeric `Tensor`, same dtype as and broadcastable to `x`.",D_TYPE D_STRUCTURE same dtype as and broadcastable to QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.config.threading.set_intra_op_parallelism_threads,num_threads,Number of parallel threads,Number of parallel threads,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.random.uniform_candidate_sampler,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.random.uniform_candidate_sampler,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cosh,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cosh,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_raw,input_bytes,Each element of the input Tensor is converted to an array of bytes.,Each element of the input D_STRUCTURE is converted to an D_STRUCTURE of bytes,,,D_STRUCTURE,,,,
tf.guarantee_const,input,A `Tensor`.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.keras.backend.resize_images,height_factor,Positive integer.,Positive D_TYPE,D_TYPE,,,,CONSTANT_VAL,"(0,inf)",
tf.nn.conv2d_transpose,input,"A 4-D `Tensor` of type `float` and shape `[batch, height, width, in_channels]` for `NHWC` data format or `[batch, in_channels, height, width]` for `NCHW` data format.",A CONSTANT_NUM D D_STRUCTURE of type D_TYPE and shape BSTR for QSTR data format or BSTR for QSTR data format,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.feature_column.sequence_numeric_column,normalizer_fn,"If not `None`, a function that can be used to normalize the value of the tensor after `default_value` is applied for parsing. Normalizer function takes the input `Tensor` as its argument, and returns the output `Tensor`. (e.g. lambda x: (x - 3.0) / 4.2). Please note that even though the most common use case of this function is normalization, it can be used for any kind of Tensorflow transformations.",If not QSTR a function that can be used to normalize the value of the D_STRUCTURE after PARAM is applied for parsing,,,,,,,
tf.feature_column.sequence_numeric_column,normalizer_fn,"If not `None`, a function that can be used to normalize the value of the tensor after `default_value` is applied for parsing. Normalizer function takes the input `Tensor` as its argument, and returns the output `Tensor`. (e.g. lambda x: (x - 3.0) / 4.2). Please note that even though the most common use case of this function is normalization, it can be used for any kind of Tensorflow transformations.",Normalizer function takes the input D_STRUCTURE as its argument and returns the output D_STRUCTURE,,,,,,,
tf.feature_column.sequence_numeric_column,normalizer_fn,"If not `None`, a function that can be used to normalize the value of the tensor after `default_value` is applied for parsing. Normalizer function takes the input `Tensor` as its argument, and returns the output `Tensor`. (e.g. lambda x: (x - 3.0) / 4.2). Please note that even though the most common use case of this function is normalization, it can be used for any kind of Tensorflow transformations.",e g,,,,,,,
tf.feature_column.sequence_numeric_column,normalizer_fn,"If not `None`, a function that can be used to normalize the value of the tensor after `default_value` is applied for parsing. Normalizer function takes the input `Tensor` as its argument, and returns the output `Tensor`. (e.g. lambda x: (x - 3.0) / 4.2). Please note that even though the most common use case of this function is normalization, it can be used for any kind of Tensorflow transformations.",lambda x BSTR,,,,,,,
tf.feature_column.sequence_numeric_column,normalizer_fn,"If not `None`, a function that can be used to normalize the value of the tensor after `default_value` is applied for parsing. Normalizer function takes the input `Tensor` as its argument, and returns the output `Tensor`. (e.g. lambda x: (x - 3.0) / 4.2). Please note that even though the most common use case of this function is normalization, it can be used for any kind of Tensorflow transformations.",Please note that even though the most common use case of this function is normalization it can be used for any kind of Tensorflow transformations,,,,,,,
tf.feature_column.sequence_numeric_column,normalizer_fn,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.Lambda,mask,"Either None (indicating no masking) or a callable with the same signature as the `compute_mask` layer method, or a tensor that will be returned as output mask regardless what the input is.",Either None BSTR or a callable with the same signature as the QSTR layer method or a D_STRUCTURE that will be returned as output mask regardless what the input is,,,,,,,
tf.keras.layers.Lambda,mask,DF: None,DEFAULT None,,,,,,,
tf.keras.datasets.mnist.load_data,path,path where to cache the dataset locally (relative to ~/.keras/datasets).,path where to cache the dataset locally relative to keras datasets,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.datasets.mnist.load_data,path,DF: mnist.npz,mnist npz,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv_transpose,input,"An N+2 dimensional `Tensor` of shape`[batch_size] + input_spatial_shape + [in_channels]` if data_format does not start with ""NC"" (default), or`[batch_size, in_channels] + input_spatial_shape` if data_format starts with ""NC"". It must be one of the following types:`half`, `bfloat16`, `float32`, `float64`.",An N CONSTANT_NUM dimensional D_STRUCTURE of shape BSTR input_spatial_shape BSTR if PARAM does not start with QSTR BSTR or BSTR input_spatial_shape QSTR NC,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.conv_transpose,input,"An N+2 dimensional `Tensor` of shape`[batch_size] + input_spatial_shape + [in_channels]` if data_format does not start with ""NC"" (default), or`[batch_size, in_channels] + input_spatial_shape` if data_format starts with ""NC"". It must be one of the following types:`half`, `bfloat16`, `float32`, `float64`.",It must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.test.compute_gradient,x,a list arguments for the function,a D_STRUCTURE arguments for the function,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.nn.batch_normalization,variance,A variance `Tensor`.,A variance D_STRUCTURE,,D_STRUCTURE,,,,,
tf.debugging.assert_rank,rank,Scalar integer `Tensor`.,Scalar D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNN,recurrent_constraint,Constraint function applied to the `recurrent_kernel`weights matrix.  Default: `None`.,Constraint function applied to the QSTR weights matrix,,,,,,,
tf.keras.layers.SimpleRNN,recurrent_constraint,Constraint function applied to the `recurrent_kernel`weights matrix.  Default: `None`.,Default QSTR,,,,,,,
tf.keras.layers.SimpleRNN,recurrent_constraint,DF: None,DEFAULT None,,,,,,,
tf.linalg.lu_reconstruct,validate_args,"Python `bool` indicating whether arguments should be checked for correctness. Default value: `False` (i.e., don't validate arguments).",Python D_TYPE indicating whether arguments should be checked for correctness,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.lu_reconstruct,validate_args,"Python `bool` indicating whether arguments should be checked for correctness. Default value: `False` (i.e., don't validate arguments).",Default value CONSTANT_BOOL i e don t validate arguments,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.lu_reconstruct,validate_args,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_and_crop_jpeg,channels,An optional `int`. Defaults to `0`. Number of color channels for the decoded image.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.io.decode_and_crop_jpeg,channels,An optional `int`. Defaults to `0`. Number of color channels for the decoded image.,Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.io.decode_and_crop_jpeg,channels,An optional `int`. Defaults to `0`. Number of color channels for the decoded image.,Number of color channels for the decoded image,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.io.decode_and_crop_jpeg,channels,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.math.angle,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.angle,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.image.resize,antialias,Whether to use an anti-aliasing filter when downsampling an image.,Whether to use an anti aliasing filter when downsampling an image,D_TYPE,,,,CONSTANT_VAL,,
tf.image.resize,antialias,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,kernel_initializer,"Initializer for the `kernel` weights matrix, used for the linear transformation of the inputs. Default: `glorot_uniform`.",Initializer for the QSTR weights matrix used for the linear transformation of the inputs,D_TYPE,,,,,,
tf.keras.layers.LSTMCell,kernel_initializer,"Initializer for the `kernel` weights matrix, used for the linear transformation of the inputs. Default: `glorot_uniform`.",Default QSTR,D_TYPE,,,,,,
tf.keras.layers.LSTMCell,kernel_initializer,DF: glorot_uniform,DEFAULT DF_STR,D_TYPE,,,,,,
tf.signal.dct,name,An optional name for the operation.,An optional name for the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.dct,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.batch_normalization,beta,Tensor with which to center the input.,D_STRUCTURE with which to center the input,,D_STRUCTURE,,,,,
tf.debugging.assert_all_finite,name,A name for this operation (optional).,A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_all_finite,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.reshape,sp_input,The input `SparseTensor`.,The input D_STRUCTURE,,D_STRUCTURE,,,,,
tf.bitwise.invert,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.bitwise.invert,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_base64,pad,An optional `bool`. Defaults to `False`. Bool whether padding is applied at the ends.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_base64,pad,An optional `bool`. Defaults to `False`. Bool whether padding is applied at the ends.,Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_base64,pad,An optional `bool`. Defaults to `False`. Bool whether padding is applied at the ends.,D_TYPE whether padding is applied at the ends,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_base64,pad,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ReLU,negative_slope,Float >= 0. Negative slope coefficient.,D_TYPE REXPR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ReLU,negative_slope,Float >= 0. Negative slope coefficient.,Negative slope coefficient,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ReLU,negative_slope,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,label_name,"A optional string corresponding to the label column. If provided, the data for this column is returned as a separate `Tensor` from the features dictionary, so that the dataset complies with the format expected by a `tf.Estimator.train` or `tf.Estimator.evaluate` input function.",A optional D_TYPE corresponding to the label column,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,label_name,"A optional string corresponding to the label column. If provided, the data for this column is returned as a separate `Tensor` from the features dictionary, so that the dataset complies with the format expected by a `tf.Estimator.train` or `tf.Estimator.evaluate` input function.",If provided the data for this column is returned as a separate D_STRUCTURE from the features D_STRUCTURE so that the dataset complies with the format expected by a tf Estimator train QSTR tf Estimator evaluate input function,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,label_name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.batch_to_space,block_shape,"A `Tensor`. Must be one of the following types: `int32`,`int64`. 1-D with shape `[M]`, all values must be >= 1. For backwards compatibility with TF 1.0, this parameter may be an int, in which case it is converted to `numpy.array([block_shape, block_shape], dtype=numpy.int64)`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[1,inf)",
tf.batch_to_space,block_shape,"A `Tensor`. Must be one of the following types: `int32`,`int64`. 1-D with shape `[M]`, all values must be >= 1. For backwards compatibility with TF 1.0, this parameter may be an int, in which case it is converted to `numpy.array([block_shape, block_shape], dtype=numpy.int64)`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[1,inf)",
tf.batch_to_space,block_shape,"A `Tensor`. Must be one of the following types: `int32`,`int64`. 1-D with shape `[M]`, all values must be >= 1. For backwards compatibility with TF 1.0, this parameter may be an int, in which case it is converted to `numpy.array([block_shape, block_shape], dtype=numpy.int64)`.",CONSTANT_NUM D with shape BSTR all values must be REXPR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[1,inf)",
tf.batch_to_space,block_shape,"A `Tensor`. Must be one of the following types: `int32`,`int64`. 1-D with shape `[M]`, all values must be >= 1. For backwards compatibility with TF 1.0, this parameter may be an int, in which case it is converted to `numpy.array([block_shape, block_shape], dtype=numpy.int64)`.",For backwards compatibility with TF CONSTANT_FLOAT this parameter may be an D_TYPE in which case it is converted to numpy D_STRUCTURE BSTR dtype numpy D_TYPE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[1,inf)",
tf.edit_distance,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.edit_distance,name,DF: edit_distance,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.sequence.skipgrams,sequence,"A word sequence (sentence), encoded as a list     of word indices (integers). If using a `sampling_table`,     word indices are expected to match the rank     of the words in a reference dataset (e.g. 10 would encode     the 10-th most frequently occurring token).     Note that index 0 is expected to be a non-word and will be skipped.",A word D_STRUCTURE BSTR,,,D_STRUCTURE,,,,
tf.keras.preprocessing.sequence.skipgrams,sequence,"A word sequence (sentence), encoded as a list     of word indices (integers). If using a `sampling_table`,     word indices are expected to match the rank     of the words in a reference dataset (e.g. 10 would encode     the 10-th most frequently occurring token).     Note that index 0 is expected to be a non-word and will be skipped.",If using a PARAM word indices are expected to match the rank of the words in a reference dataset e g,,,D_STRUCTURE,,,,
tf.keras.preprocessing.sequence.skipgrams,sequence,"A word sequence (sentence), encoded as a list     of word indices (integers). If using a `sampling_table`,     word indices are expected to match the rank     of the words in a reference dataset (e.g. 10 would encode     the 10-th most frequently occurring token).     Note that index 0 is expected to be a non-word and will be skipped.",CONSTANT_NUM would encode the CONSTANT_NUM th most frequently occurring token,,,D_STRUCTURE,,,,
tf.keras.preprocessing.sequence.skipgrams,sequence,"A word sequence (sentence), encoded as a list     of word indices (integers). If using a `sampling_table`,     word indices are expected to match the rank     of the words in a reference dataset (e.g. 10 would encode     the 10-th most frequently occurring token).     Note that index 0 is expected to be a non-word and will be skipped.",Note that index CONSTANT_NUM is expected to be a non word and will be skipped,,,D_STRUCTURE,,,,
tf.einsum,**kwargs,"- optimize: Optimization strategy to use to find contraction path using opt_einsum. Must be 'greedy', 'optimal', 'branch-2', 'branch-all' or   'auto'. (optional, default: 'greedy'). name: A name for the operation (optional). ",optimize Optimization strategy to use to find contraction path using opt_einsum,D_TYPE,,,,CONSTANT_VAL,,
tf.einsum,**kwargs,"- optimize: Optimization strategy to use to find contraction path using opt_einsum. Must be 'greedy', 'optimal', 'branch-2', 'branch-all' or   'auto'. (optional, default: 'greedy'). name: A name for the operation (optional). ",Must be QSTR branch CONSTANT_NUM QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.einsum,**kwargs,"- optimize: Optimization strategy to use to find contraction path using opt_einsum. Must be 'greedy', 'optimal', 'branch-2', 'branch-all' or   'auto'. (optional, default: 'greedy'). name: A name for the operation (optional). ",optional default QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.einsum,**kwargs,"- optimize: Optimization strategy to use to find contraction path using opt_einsum. Must be 'greedy', 'optimal', 'branch-2', 'branch-all' or   'auto'. (optional, default: 'greedy'). name: A name for the operation (optional). ",name A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.binary_crossentropy,output,A tensor.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.summary.flush,writer,The `tf.summary.SummaryWriter` resource to flush. The thread default will be used if this parameter is None. Otherwise a `tf.no_op` is returned.,The tf summary SummaryWriter resource to flush,,,,,,,
tf.summary.flush,writer,The `tf.summary.SummaryWriter` resource to flush. The thread default will be used if this parameter is None. Otherwise a `tf.no_op` is returned.,The thread default will be used if this parameter is None,,,,,,,
tf.summary.flush,writer,The `tf.summary.SummaryWriter` resource to flush. The thread default will be used if this parameter is None. Otherwise a `tf.no_op` is returned.,Otherwise a tf no_op is returned,,,,,,,
tf.summary.flush,writer,DF: None,DEFAULT None,,,,,,,
tf.quantization.fake_quant_with_min_max_vars,narrow_range,An optional `bool`. Defaults to `False`.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_vars,narrow_range,An optional `bool`. Defaults to `False`.,Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_vars,narrow_range,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.safe_embedding_lookup_sparse,sparse_ids,"`SparseTensor` of shape `[d_0, d_1, ..., d_n]` containing the ids. `d_0` is typically batch size.",D_STRUCTURE of shape BSTR containing the ids,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.safe_embedding_lookup_sparse,sparse_ids,"`SparseTensor` of shape `[d_0, d_1, ..., d_n]` containing the ids. `d_0` is typically batch size.",d CONSTANT_NUM is typically batch size,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.math.is_nan,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.is_nan,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.identity_n,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.identity_n,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.batch_norm_with_global_normalization,mean,"A 1D mean Tensor with size matching the last dimension of t. This is the first output from tf.nn.moments, or a saved moving average thereof.",A CONSTANT_NUM D mean D_STRUCTURE with size matching the last dimension of t This is the first output from tf nn moments or a saved moving average thereof,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.random.stateless_uniform,seed,A shape [2] integer Tensor of seeds to the random number generator.,A PARAM BSTR D_TYPE D_STRUCTURE of seeds to the random number generator,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.initializers.he_uniform,seed,A Python integer. Used to seed the random generator.,A Python D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.initializers.he_uniform,seed,A Python integer. Used to seed the random generator.,Used to seed the random generator,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.initializers.he_uniform,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.sequence_categorical_column_with_identity,num_buckets,"Range of inputs. Namely, inputs are expected to be in the range `[0, num_buckets)`.",Range of inputs,D_TYPE,,,,CONSTANT_VAL,"[0,&num_buckets)",
tf.feature_column.sequence_categorical_column_with_identity,num_buckets,"Range of inputs. Namely, inputs are expected to be in the range `[0, num_buckets)`.",Namely inputs are expected to be in the range BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,&num_buckets)",
tf.tpu.experimental.initialize_tpu_system,cluster_resolver,"A tf.distribute.cluster_resolver.TPUClusterResolver, which provides information about the TPU cluster.",A tf distribute cluster_resolver TPUClusterResolver which provides information about the TPU cluster,,,,,,,
tf.tpu.experimental.initialize_tpu_system,cluster_resolver,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.ZeroPadding3D,padding,"Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints. If int: the same symmetric padding is applied to height and width.If tuple of 3 ints: interpreted as two different symmetric padding values for height and width:`(symmetric_dim1_pad, symmetric_dim2_pad, symmetric_dim3_pad)`.If tuple of 3 tuples of 2 ints: interpreted as`((left_dim1_pad, right_dim1_pad), (left_dim2_pad, right_dim2_pad), (left_dim3_pad, right_dim3_pad))` ",D_TYPE or D_STRUCTURE of CONSTANT_NUM D_TYPE or D_STRUCTURE of CONSTANT_NUM tuples of CONSTANT_NUM D_TYPE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.ZeroPadding3D,padding,"Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints. If int: the same symmetric padding is applied to height and width.If tuple of 3 ints: interpreted as two different symmetric padding values for height and width:`(symmetric_dim1_pad, symmetric_dim2_pad, symmetric_dim3_pad)`.If tuple of 3 tuples of 2 ints: interpreted as`((left_dim1_pad, right_dim1_pad), (left_dim2_pad, right_dim2_pad), (left_dim3_pad, right_dim3_pad))` ",If D_TYPE the same symmetric padding is applied to height and width If D_STRUCTURE of CONSTANT_NUM D_TYPE interpreted as two different symmetric padding values for height and width BSTR If D_STRUCTURE of CONSTANT_NUM tuples of CONSTANT_NUM D_TYPE interpreted as BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.ZeroPadding3D,padding,"DF: (1, 1, 1)",DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.eye,dtype,The type of an element in the resulting `Tensor`,The type of an element in the resulting D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.eye,dtype,DF: tf.dtypes.float32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.cumprod,axis,"An integer, the axis to compute the product.",An D_TYPE the axis to compute the product,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.cumprod,axis,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNN,recurrent_initializer,"Initializer for the `recurrent_kernel`weights matrix, used for the linear transformation of the recurrent state. Default: `orthogonal`.",Initializer for the QSTR weights matrix used for the linear transformation of the recurrent state,D_TYPE,,,,,,
tf.keras.layers.SimpleRNN,recurrent_initializer,"Initializer for the `recurrent_kernel`weights matrix, used for the linear transformation of the recurrent state. Default: `orthogonal`.",Default QSTR,D_TYPE,,,,,,
tf.keras.layers.SimpleRNN,recurrent_initializer,DF: orthogonal,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.layers.InputSpec,axes,Dictionary mapping integer axes to a specific dimension value.,D_STRUCTURE mapping D_TYPE axes to a specific dimension value,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.layers.InputSpec,axes,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.tuple,name,(optional) A name to use as a `name_scope` for the operation.,BSTR A name to use as a QSTR for the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.tuple,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_input,dilations,"An optional list of `ints`. Defaults to `[1, 1, 1, 1]`. 1-D tensor of length 4.  The dilation factor for each dimension of`input`. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. The dimension order is determined by the value of`data_format`, see above for details. Dilations in the batch and depth dimensions must be 1.",An optional D_STRUCTURE of D_TYPE,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_input,dilations,"An optional list of `ints`. Defaults to `[1, 1, 1, 1]`. 1-D tensor of length 4.  The dilation factor for each dimension of`input`. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. The dimension order is determined by the value of`data_format`, see above for details. Dilations in the batch and depth dimensions must be 1.",Defaults to BSTR,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_input,dilations,"An optional list of `ints`. Defaults to `[1, 1, 1, 1]`. 1-D tensor of length 4.  The dilation factor for each dimension of`input`. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. The dimension order is determined by the value of`data_format`, see above for details. Dilations in the batch and depth dimensions must be 1.",CONSTANT_NUM D D_STRUCTURE of length CONSTANT_NUM,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_input,dilations,"An optional list of `ints`. Defaults to `[1, 1, 1, 1]`. 1-D tensor of length 4.  The dilation factor for each dimension of`input`. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. The dimension order is determined by the value of`data_format`, see above for details. Dilations in the batch and depth dimensions must be 1.",The dilation factor for each dimension of QSTR,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_input,dilations,"An optional list of `ints`. Defaults to `[1, 1, 1, 1]`. 1-D tensor of length 4.  The dilation factor for each dimension of`input`. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. The dimension order is determined by the value of`data_format`, see above for details. Dilations in the batch and depth dimensions must be 1.",If set to k REXPR there will be k CONSTANT_NUM skipped cells between each PARAM element on that dimension,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_input,dilations,"An optional list of `ints`. Defaults to `[1, 1, 1, 1]`. 1-D tensor of length 4.  The dilation factor for each dimension of`input`. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. The dimension order is determined by the value of`data_format`, see above for details. Dilations in the batch and depth dimensions must be 1.",The dimension order is determined by the value of PARAM see above for details,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_input,dilations,"An optional list of `ints`. Defaults to `[1, 1, 1, 1]`. 1-D tensor of length 4.  The dilation factor for each dimension of`input`. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. The dimension order is determined by the value of`data_format`, see above for details. Dilations in the batch and depth dimensions must be 1.",Dilations in the batch and depth dimensions must be CONSTANT_NUM,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_input,dilations,"DF: [1, 1, 1, 1]",DEFAULT CONSTANT_NUM,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.io.decode_proto,field_names,"A list of `strings`. List of strings containing proto field names. An extension field can be decoded by using its full name, e.g. EXT_PACKAGE.EXT_FIELD_NAME.",A D_STRUCTURE of D_TYPE,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.io.decode_proto,field_names,"A list of `strings`. List of strings containing proto field names. An extension field can be decoded by using its full name, e.g. EXT_PACKAGE.EXT_FIELD_NAME.",D_STRUCTURE of D_TYPE containing proto field names,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.io.decode_proto,field_names,"A list of `strings`. List of strings containing proto field names. An extension field can be decoded by using its full name, e.g. EXT_PACKAGE.EXT_FIELD_NAME.",An extension field can be decoded by using its full PARAM e g,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.io.decode_proto,field_names,"A list of `strings`. List of strings containing proto field names. An extension field can be decoded by using its full name, e.g. EXT_PACKAGE.EXT_FIELD_NAME.",EXT_PACKAGE EXT_FIELD_NAME,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.nest.map_structure,*structure,"scalar, or tuple or list of constructed scalars and/or other tuples/lists, or scalars.  Note: numpy arrays are considered as scalars.",scalar or D_STRUCTURE of constructed scalars and or other tuples D_STRUCTURE or scalars,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.nest.map_structure,*structure,"scalar, or tuple or list of constructed scalars and/or other tuples/lists, or scalars.  Note: numpy arrays are considered as scalars.",Note numpy D_STRUCTURE are considered as scalars,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.preprocessing.image.apply_channel_shift,x,Input tensor. Must be 3D.,Input D_STRUCTURE,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.apply_channel_shift,x,Input tensor. Must be 3D.,Must be CONSTANT_NUM D,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,use_quote_delim,"An optional bool. Defaults to `True`. If false, treats double quotation marks as regular characters inside of the string fields.",An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,use_quote_delim,"An optional bool. Defaults to `True`. If false, treats double quotation marks as regular characters inside of the string fields.",Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,use_quote_delim,"An optional bool. Defaults to `True`. If false, treats double quotation marks as regular characters inside of the string fields.",If CONSTANT_BOOL treats D_TYPE quotation marks as regular characters inside of the D_TYPE fields,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,use_quote_delim,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.utils.get_file,archive_format,"Archive format to try for extracting the file. Options are 'auto', 'tar', 'zip', and None. 'tar' includes tar, tar.gz, and tar.bz files. The default 'auto' is ['tar', 'zip']. None or an empty list will return no matches found.",Archive format to try for extracting the file,D_TYPE,,,,,,
tf.keras.utils.get_file,archive_format,"Archive format to try for extracting the file. Options are 'auto', 'tar', 'zip', and None. 'tar' includes tar, tar.gz, and tar.bz files. The default 'auto' is ['tar', 'zip']. None or an empty list will return no matches found.",Options are QSTR and None,D_TYPE,,,,,,
tf.keras.utils.get_file,archive_format,"Archive format to try for extracting the file. Options are 'auto', 'tar', 'zip', and None. 'tar' includes tar, tar.gz, and tar.bz files. The default 'auto' is ['tar', 'zip']. None or an empty list will return no matches found.",QSTR includes tar tar gz and tar bz files,D_TYPE,,,,,,
tf.keras.utils.get_file,archive_format,"Archive format to try for extracting the file. Options are 'auto', 'tar', 'zip', and None. 'tar' includes tar, tar.gz, and tar.bz files. The default 'auto' is ['tar', 'zip']. None or an empty list will return no matches found.",The default QSTR is QSTR,D_TYPE,,,,,,
tf.keras.utils.get_file,archive_format,"Archive format to try for extracting the file. Options are 'auto', 'tar', 'zip', and None. 'tar' includes tar, tar.gz, and tar.bz files. The default 'auto' is ['tar', 'zip']. None or an empty list will return no matches found.",None or an empty D_STRUCTURE will return no matches found,D_TYPE,,,,,,
tf.keras.utils.get_file,archive_format,DF: auto,DEFAULT DF_STR,D_TYPE,,,,,,
tf.debugging.assert_rank_at_least,x,`Tensor`.,ONE_WORD D_STRUCTURE,,D_STRUCTURE,,,,,
tf.keras.preprocessing.sequence.skipgrams,shuffle,Whether to shuffle the word couples before returning them.,Whether to shuffle the word couples before returning them,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.sequence.skipgrams,shuffle,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,remove_accidental_hits,"A `bool`.  whether to remove ""accidental hits"" where a sampled class equals one of the target classes.  Default is True.",A D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,remove_accidental_hits,"A `bool`.  whether to remove ""accidental hits"" where a sampled class equals one of the target classes.  Default is True.",whether to remove QSTR where a sampled class equals one of the target classes,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,remove_accidental_hits,"A `bool`.  whether to remove ""accidental hits"" where a sampled class equals one of the target classes.  Default is True.",Default is CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,remove_accidental_hits,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.dynamic_stitch,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.dynamic_stitch,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.bitwise.right_shift,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.bitwise.right_shift,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GlobalMaxPool2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",A D_TYPE one of QSTR BSTR or QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.GlobalMaxPool2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",The ordering of the dimensions in the inputs QSTR corresponds to inputs with shape BSTR while QSTR corresponds to inputs with shape BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.GlobalMaxPool2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",It defaults to the QSTR value found in your Keras config file at keras keras json,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.GlobalMaxPool2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",If you never set it then it will be QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.GlobalMaxPool2D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.backend.conv2d_transpose,dilation_rate,Tuple of 2 integers.,D_STRUCTURE of CONSTANT_NUM D_TYPE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.backend.conv2d_transpose,dilation_rate,"DF: (1, 1)",DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.config.experimental_connect_to_cluster,task_index,The local task index.,The local task index,D_TYPE,,,,CONSTANT_VAL,,
tf.config.experimental_connect_to_cluster,task_index,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.random_rotation,row_axis,Index of axis for rows in the input tensor.,Index of axis for rows in the input D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.random_rotation,row_axis,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.function,experimental_relax_shapes,"When True, `tf.function` may generate fewer, graphs that are less specialized on input shapes.",When CONSTANT_BOOL tf function may generate fewer graphs that are less specialized on input shapes,D_TYPE,,,,CONSTANT_VAL,,
tf.function,experimental_relax_shapes,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.image.random_jpeg_quality,max_jpeg_quality,Maximum jpeg encoding quality to use.,Maximum jpeg encoding quality to use,,,,,,,
tf.math.tan,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.tan,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.estimator.experimental.make_early_stopping_hook,estimator,A `tf.estimator.Estimator` instance.,A tf estimator Estimator instance,,,,,,,
tf.keras.backend.random_uniform,maxval,"A float, upper boundary of the uniform distribution to draw samples.",A D_TYPE upper boundary of the uniform distribution to draw samples,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.random_uniform,maxval,DF: 1.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.InputLayer,input_shape,"Shape tuple (not including the batch axis), or `TensorShape`instance (not including the batch axis).",Shape D_STRUCTURE BSTR or QSTR instance BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.InputLayer,input_shape,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.parallel_stack,values,A list of `Tensor` objects with the same shape and type.,A D_STRUCTURE of D_STRUCTURE objects with the same shape and type,,,D_STRUCTURE,,,,
tf.gradients,stop_gradients,Optional. A `Tensor` or list of tensors not to differentiate through.,ONE_WORD Optional,,,D_STRUCTURE,,,,
tf.gradients,stop_gradients,Optional. A `Tensor` or list of tensors not to differentiate through.,A D_STRUCTURE of D_STRUCTURE not to differentiate through,,,D_STRUCTURE,,,,
tf.gradients,stop_gradients,DF: None,DEFAULT None,,,D_STRUCTURE,,,,
tf.nn.elu,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.elu,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cumulative_logsumexp,axis,"A `Tensor` of type `int32` or `int64` (default: 0). Must be in the range `[-rank(x), rank(x))`.",A D_STRUCTURE of type D_TYPE default CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[-ndim:&x,ndim:&x)",
tf.math.cumulative_logsumexp,axis,"A `Tensor` of type `int32` or `int64` (default: 0). Must be in the range `[-rank(x), rank(x))`.",Must be in the range BSTR,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[-ndim:&x,ndim:&x)",
tf.math.cumulative_logsumexp,axis,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[-ndim:&x,ndim:&x)",
tf.sparse.minimum,sp_b,the other `SparseTensor` operand with the same requirements (and the same shape).,the other D_STRUCTURE operand with the same requirements BSTR,,D_STRUCTURE,,,,,
tf.quantization.fake_quant_with_min_max_args,max,An optional `float`. Defaults to `6`.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_args,max,An optional `float`. Defaults to `6`.,Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_args,max,DF: 6,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.math.conj,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.conj,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,return_sequences,"Boolean. Whether to return the last output in the output sequence, or the full sequence. Default: `False`.",ONE_WORD D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,return_sequences,"Boolean. Whether to return the last output in the output sequence, or the full sequence. Default: `False`.",Whether to return the last output in the output D_STRUCTURE or the full D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,return_sequences,"Boolean. Whether to return the last output in the output sequence, or the full sequence. Default: `False`.",Default CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,return_sequences,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nondifferentiable_batch_function,max_enqueued_batches,The maximum depth of the batch queue. Defaults to 10.,The maximum depth of the batch queue,D_TYPE,,,,CONSTANT_VAL,,
tf.nondifferentiable_batch_function,max_enqueued_batches,The maximum depth of the batch queue. Defaults to 10.,Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.nondifferentiable_batch_function,max_enqueued_batches,DF: 10,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.depthwise_conv2d,data_format,"string, `""channels_last""` or `""channels_first""`.",D_TYPE QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.depthwise_conv2d,data_format,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.layers.DepthwiseConv2D,bias_constraint,Constraint function applied to the bias vector.,Constraint function applied to the bias vector,,,,,,,
tf.keras.layers.DepthwiseConv2D,bias_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.LocallyConnected2D,bias_constraint,Constraint function applied to the bias vector.,Constraint function applied to the bias vector,,,,,,,
tf.keras.layers.LocallyConnected2D,bias_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.ConvLSTM2D,activity_regularizer,Regularizer function applied to.,Regularizer function applied to,,,,,,,
tf.keras.layers.ConvLSTM2D,activity_regularizer,DF: None,DEFAULT None,,,,,,,
tf.linalg.expm,input,"A `Tensor`. Must be `float16`, `float32`, `float64`, `complex64`, or`complex128` with shape `[..., M, M]`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.linalg.expm,input,"A `Tensor`. Must be `float16`, `float32`, `float64`, `complex64`, or`complex128` with shape `[..., M, M]`.",Must be D_TYPE with shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.separable_conv2d,dilations,"1-D of size 2. The dilation rate in which we sample input values across the `height` and `width` dimensions in atrous convolution. If it is greater than 1, then all values of strides must be 1.",CONSTANT_NUM D of size CONSTANT_NUM,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,1]",
tf.nn.separable_conv2d,dilations,"1-D of size 2. The dilation rate in which we sample input values across the `height` and `width` dimensions in atrous convolution. If it is greater than 1, then all values of strides must be 1.",The dilation rate in which we sample PARAM values across the QSTR dimensions in atrous convolution,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,1]",
tf.nn.separable_conv2d,dilations,"1-D of size 2. The dilation rate in which we sample input values across the `height` and `width` dimensions in atrous convolution. If it is greater than 1, then all values of strides must be 1.",If it is greater than CONSTANT_NUM then all values of PARAM must be CONSTANT_NUM,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,1]",
tf.nn.separable_conv2d,dilations,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,1]",
tf.keras.layers.Conv3D,bias_initializer,Initializer for the bias vector.,Initializer for the bias vector,D_TYPE,,,,,,
tf.keras.layers.Conv3D,bias_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.datasets.reuters.get_word_index,path,where to cache the data (relative to `~/.keras/dataset`).,where to cache the data relative to keras dataset,D_TYPE,,,,,,
tf.keras.datasets.reuters.get_word_index,path,DF: reuters_word_index.json,reuters_word_index json,D_TYPE,,,,,,
tf.keras.backend.argmax,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.math.is_strictly_increasing,name,"A name for this operation (optional). Defaults to ""is_strictly_increasing""",A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.is_strictly_increasing,name,"A name for this operation (optional). Defaults to ""is_strictly_increasing""",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.is_strictly_increasing,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.image.non_max_suppression_padded,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.image.non_max_suppression_padded,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.ones_like,x,Keras variable or tensor.,Keras variable or D_STRUCTURE,,,,,,,
tf.io.encode_jpeg,y_density,An optional `int`. Defaults to `300`. Vertical pixels per density unit.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_jpeg,y_density,An optional `int`. Defaults to `300`. Vertical pixels per density unit.,Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_jpeg,y_density,An optional `int`. Defaults to `300`. Vertical pixels per density unit.,Vertical pixels per density unit,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_jpeg,y_density,DF: 300,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.softsign,x,A tensor or variable.,A D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.keras.preprocessing.image.random_zoom,zoom_range,Tuple of floats; zoom range for width and height.,D_STRUCTURE of D_TYPE zoom range for width and height,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.train.checkpoints_iterator,timeout,"The maximum number of seconds to wait between checkpoints. If left as `None`, then the process will wait indefinitely.",The maximum number of seconds to wait between checkpoints,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.train.checkpoints_iterator,timeout,"The maximum number of seconds to wait between checkpoints. If left as `None`, then the process will wait indefinitely.",If left as QSTR then the process will wait indefinitely,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.train.checkpoints_iterator,timeout,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.boolean_mask,tensor,N-D tensor.,N D D_STRUCTURE,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.ones_like,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.ones_like,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.regex_replace,pattern,"string or scalar string `Tensor`, regular expression to use, see more details at https://github.com/google/re2/wiki/Syntax",D_TYPE or scalar D_TYPE D_STRUCTURE regular expression to use see more details at https github com google re2 wiki Syntax,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,unit_forget_bias,"Boolean (default `True`). If True, add 1 to the bias of the forget gate at initialization. Setting it to true will also force`bias_initializer=""zeros""`. This is recommended in Jozefowicz et al.",D_TYPE default CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,unit_forget_bias,"Boolean (default `True`). If True, add 1 to the bias of the forget gate at initialization. Setting it to true will also force`bias_initializer=""zeros""`. This is recommended in Jozefowicz et al.",If CONSTANT_BOOL add CONSTANT_NUM to the bias of the forget gate at initialization,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,unit_forget_bias,"Boolean (default `True`). If True, add 1 to the bias of the forget gate at initialization. Setting it to true will also force`bias_initializer=""zeros""`. This is recommended in Jozefowicz et al.",Setting it to CONSTANT_BOOL will also force PARAM QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,unit_forget_bias,"Boolean (default `True`). If True, add 1 to the bias of the forget gate at initialization. Setting it to true will also force`bias_initializer=""zeros""`. This is recommended in Jozefowicz et al.",This is recommended in Jozefowicz et al,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,unit_forget_bias,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.random.truncated_normal,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.random.truncated_normal,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv1d,dilations,"An int or list of `ints` that has length `1` or `3` which defaults to 1. The dilation factor for each dimension of input. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. Dilations in the batch and depth dimensions must be 1.",An D_TYPE or D_STRUCTURE of D_TYPE that has length CONSTANT_NUM which defaults to CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.conv1d,dilations,"An int or list of `ints` that has length `1` or `3` which defaults to 1. The dilation factor for each dimension of input. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. Dilations in the batch and depth dimensions must be 1.",The dilation factor for each dimension of PARAM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.conv1d,dilations,"An int or list of `ints` that has length `1` or `3` which defaults to 1. The dilation factor for each dimension of input. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. Dilations in the batch and depth dimensions must be 1.",If set to k REXPR there will be k CONSTANT_NUM skipped cells between each filter element on that dimension,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.conv1d,dilations,"An int or list of `ints` that has length `1` or `3` which defaults to 1. The dilation factor for each dimension of input. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. Dilations in the batch and depth dimensions must be 1.",Dilations in the batch and depth dimensions must be CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.conv1d,dilations,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.linalg.diag,num_rows,"The number of rows of the output matrix. If it is not provided, the op assumes the output matrix is a square matrix and infers the matrix size from `d_lower`, `d_upper`, and the innermost dimension of `diagonal`.",The number of rows of the output matrix,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.linalg.diag,num_rows,"The number of rows of the output matrix. If it is not provided, the op assumes the output matrix is a square matrix and infers the matrix size from `d_lower`, `d_upper`, and the innermost dimension of `diagonal`.",If it is not provided the op assumes the output matrix is a square matrix and infers the matrix size from QSTR and the innermost dimension of PARAM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.linalg.diag,num_rows,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.register_tensor_conversion_function,conversion_func,A function that converts instances of `base_type` to`Tensor`.,A function that converts instances of PARAM toD_STRUCTURE,,,,,,,
tf.keras.layers.BatchNormalization,beta_initializer,Initializer for the beta weight.,Initializer for the beta weight,D_TYPE,,,,,,
tf.keras.layers.BatchNormalization,beta_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.math.is_nan,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.is_nan,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.print,end,End character that is appended at the end the printed string. Defaults to the newline character.,End character that is appended at the end the printed D_TYPE,,,,,,,
tf.print,end,End character that is appended at the end the printed string. Defaults to the newline character.,Defaults to the newline character,,,,,,,
tf.print,end,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.LocallyConnected1D,bias_initializer,Initializer for the bias vector.,Initializer for the bias vector,D_TYPE,,,,,,
tf.keras.layers.LocallyConnected1D,bias_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.layers.Dense,units,"Positive integer, dimensionality of the output space.",Positive D_TYPE dimensionality of the output space,D_TYPE,,,,CONSTANT_VAL,"(0,inf)",
tf.quantization.quantized_concat,values,"A list of at least 2 `Tensor` objects with the same type. The `N` Tensors to concatenate. Their ranks and types must match, and their sizes must match in all dimensions except `concat_dim`.",A D_STRUCTURE of at least CONSTANT_NUM D_STRUCTURE objects with the same type,,,D_STRUCTURE,,,,
tf.quantization.quantized_concat,values,"A list of at least 2 `Tensor` objects with the same type. The `N` Tensors to concatenate. Their ranks and types must match, and their sizes must match in all dimensions except `concat_dim`.",The QSTR D_STRUCTURE to concatenate,,,D_STRUCTURE,,,,
tf.quantization.quantized_concat,values,"A list of at least 2 `Tensor` objects with the same type. The `N` Tensors to concatenate. Their ranks and types must match, and their sizes must match in all dimensions except `concat_dim`.",Their ranks and types must match and their sizes must match in all dimensions except PARAM,,,D_STRUCTURE,,,,
tf.image.non_max_suppression,iou_threshold,A float representing the threshold for deciding whether boxes overlap too much with respect to IOU.,A D_TYPE representing the threshold for deciding whether PARAM overlap too much with respect to IOU,D_TYPE,,,,CONSTANT_VAL,,
tf.image.non_max_suppression,iou_threshold,DF: 0.5,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.mixed_precision.experimental.set_policy,policy,"A Policy, or a string that will be converted to a Policy..",A Policy or a D_TYPE that will be converted to a Policy,,,,,,,
tf.keras.backend.ctc_decode,y_pred,"tensor `(samples, time_steps, num_categories)`containing the prediction, or output of the softmax.",D_STRUCTURE BSTRcontaining the prediction or output of the softmax,,D_STRUCTURE,,,,,
tf.image.adjust_brightness,delta,A scalar. Amount to add to the pixel values.,A scalar,D_TYPE,,,,CONSTANT_VAL,,
tf.image.adjust_brightness,delta,A scalar. Amount to add to the pixel values.,Amount to add to the pixel values,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.write,step,"Explicit `int64`-castable monotonic step value for this summary. If omitted, this defaults to `tf.summary.experimental.get_step()`, which must not be None.",Explicit D_TYPE castable monotonic step value for this summary,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.write,step,"Explicit `int64`-castable monotonic step value for this summary. If omitted, this defaults to `tf.summary.experimental.get_step()`, which must not be None.",If omitted this defaults to tf summary experimental get_step which must not be None,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.write,step,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_jpeg,density_unit,"An optional `string` from: `""in"", ""cm""`. Defaults to `""in""`. Unit used to specify `x_density` and `y_density`: pixels per inch (`'in'`) or centimeter (`'cm'`).",An optional D_TYPE from QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.io.encode_jpeg,density_unit,"An optional `string` from: `""in"", ""cm""`. Defaults to `""in""`. Unit used to specify `x_density` and `y_density`: pixels per inch (`'in'`) or centimeter (`'cm'`).",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.io.encode_jpeg,density_unit,"An optional `string` from: `""in"", ""cm""`. Defaults to `""in""`. Unit used to specify `x_density` and `y_density`: pixels per inch (`'in'`) or centimeter (`'cm'`).",Unit used to specify PARAM and PARAM pixels per inch QSTR or centimeter QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.io.encode_jpeg,density_unit,DF: in,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.shape,input,A `Tensor` or `SparseTensor`.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.tensordot,b,`Tensor` with the same type as `a`.,D_STRUCTURE with the same type as QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.math.reduce_min,keepdims,"If true, retains reduced dimensions with length 1.",If CONSTANT_BOOL retains reduced dimensions with length CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reduce_min,keepdims,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.convolution,dilations,Alias of dilation_rate.,Alias of dilation_rate,,,,,,,
tf.nn.convolution,dilations,DF: None,DEFAULT None,,,,,,,
tf.math.cumulative_logsumexp,exclusive,"If `True`, perform exclusive cumulative log-sum-exp.",If CONSTANT_BOOL perform exclusive cumulative log sum exp,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cumulative_logsumexp,exclusive,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_jpeg,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_jpeg,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.sequence_categorical_column_with_vocabulary_list,vocabulary_list,An ordered iterable defining the vocabulary. Each feature is mapped to the index of its value (if present) in `vocabulary_list`. Must be castable to `dtype`.,An ordered D_STRUCTURE defining the vocabulary,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.feature_column.sequence_categorical_column_with_vocabulary_list,vocabulary_list,An ordered iterable defining the vocabulary. Each feature is mapped to the index of its value (if present) in `vocabulary_list`. Must be castable to `dtype`.,Each feature is mapped to the index of its value BSTR in QSTR,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.feature_column.sequence_categorical_column_with_vocabulary_list,vocabulary_list,An ordered iterable defining the vocabulary. Each feature is mapped to the index of its value (if present) in `vocabulary_list`. Must be castable to `dtype`.,Must be castable to PARAM,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.data.experimental.make_batched_features_dataset,batch_size,An int representing the number of records to combine in a single batch.,An D_TYPE representing the number of records to combine in a single batch,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.math.xdivy,x,"A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `complex64`, `complex128`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.xdivy,x,"A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `complex64`, `complex128`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.signal.ifftshift,name,An optional name for the operation.,An optional name for the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.ifftshift,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.matvec,b_is_sparse,"If `True`, `b` is treated as a sparse matrix.",If CONSTANT_BOOL QSTR is treated as a sparse matrix,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.matvec,b_is_sparse,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SeparableConv1D,pointwise_constraint,Optional projection function to be applied to the pointwise kernel after being updated by an `Optimizer`.,Optional projection function to be applied to the pointwise kernel after being updated by an QSTR,,,,,,,
tf.keras.layers.SeparableConv1D,pointwise_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.local_conv2d,kernel,"the unshared weight for convolution, with shape (output_items, feature_dim, filters).",the unshared weight for convolution with shape BSTR,,,,BSTR,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,kernel_size,"An integer or tuple/list of 3 integers, specifying the depth, height and width of the 3D convolution window. Can be a single integer to specify the same value for all spatial dimensions.",An D_TYPE or D_STRUCTURE of CONSTANT_NUM D_TYPE specifying the depth height and width of the CONSTANT_NUM D convolution window,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.Conv3DTranspose,kernel_size,"An integer or tuple/list of 3 integers, specifying the depth, height and width of the 3D convolution window. Can be a single integer to specify the same value for all spatial dimensions.",Can be a single D_TYPE to specify the same value for all spatial dimensions,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.RNNCellDropoutWrapper,input_keep_prob,"unit Tensor or float between 0 and 1, input keep probability; if it is constant and 1, no input dropout will be added.",unit D_STRUCTURE or D_TYPE between CONSTANT_NUM input keep probability if it is constant and CONSTANT_NUM no input dropout will be added,,D_STRUCTURE,,,,,
tf.nn.RNNCellDropoutWrapper,input_keep_prob,DF: None,DEFAULT None,,D_STRUCTURE,,,,,
tf.keras.layers.DepthwiseConv2D,use_bias,"Boolean, whether the layer uses a bias vector.",D_TYPE whether the layer uses a bias vector,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.DepthwiseConv2D,use_bias,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.lstsq,name,"string, optional name of the operation.",D_TYPE optional name of the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.lstsq,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.linear_to_mel_weight_matrix,num_spectrogram_bins,"An integer `Tensor`. How many bins there are in the source spectrogram data, which is understood to be `fft_size // 2 + 1`, i.e. the spectrogram only contains the nonredundant FFT bins.",An D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.signal.linear_to_mel_weight_matrix,num_spectrogram_bins,"An integer `Tensor`. How many bins there are in the source spectrogram data, which is understood to be `fft_size // 2 + 1`, i.e. the spectrogram only contains the nonredundant FFT bins.",How many bins there are in the source spectrogram data which is understood to be fft_size CONSTANT_NUM CONSTANT_NUM i e,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.signal.linear_to_mel_weight_matrix,num_spectrogram_bins,"An integer `Tensor`. How many bins there are in the source spectrogram data, which is understood to be `fft_size // 2 + 1`, i.e. the spectrogram only contains the nonredundant FFT bins.",the spectrogram only contains the nonredundant FFT bins,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.signal.linear_to_mel_weight_matrix,num_spectrogram_bins,DF: 129,DEFAULT CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.var,axis,"An integer, the axis to compute the variance.",An D_TYPE the axis to compute the variance,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.var,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.matrix_transpose,a,A `Tensor` with `rank >= 2`.,A D_STRUCTURE with rank REXPR,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.quantization.quantize,min_range,"A `Tensor` of type `float32`. The minimum value of the quantization range. This value may be adjusted by the op depending on other parameters. The adjusted value is written to `output_min`. If the `axis` attribute is specified, this must be a 1-D tensor whose size matches the `axis` dimension of the input and output tensors.",A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.quantization.quantize,min_range,"A `Tensor` of type `float32`. The minimum value of the quantization range. This value may be adjusted by the op depending on other parameters. The adjusted value is written to `output_min`. If the `axis` attribute is specified, this must be a 1-D tensor whose size matches the `axis` dimension of the input and output tensors.",The minimum value of the quantization range,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.quantization.quantize,min_range,"A `Tensor` of type `float32`. The minimum value of the quantization range. This value may be adjusted by the op depending on other parameters. The adjusted value is written to `output_min`. If the `axis` attribute is specified, this must be a 1-D tensor whose size matches the `axis` dimension of the input and output tensors.",This value may be adjusted by the op depending on other parameters,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.quantization.quantize,min_range,"A `Tensor` of type `float32`. The minimum value of the quantization range. This value may be adjusted by the op depending on other parameters. The adjusted value is written to `output_min`. If the `axis` attribute is specified, this must be a 1-D tensor whose size matches the `axis` dimension of the input and output tensors.",The adjusted value is written to QSTR,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.quantization.quantize,min_range,"A `Tensor` of type `float32`. The minimum value of the quantization range. This value may be adjusted by the op depending on other parameters. The adjusted value is written to `output_min`. If the `axis` attribute is specified, this must be a 1-D tensor whose size matches the `axis` dimension of the input and output tensors.",If the PARAM attribute is specified this must be a CONSTANT_NUM D D_STRUCTURE whose size matches the PARAM dimension of the PARAM and output D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.bitwise.bitwise_or,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.bitwise.bitwise_or,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.activations.tanh,x,Input tensor.,Input D_STRUCTURE,,D_STRUCTURE,,,,,
tf.bitwise.left_shift,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.bitwise.left_shift,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.broadcast_to,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.broadcast_to,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.igammac,a,"A `Tensor`. Must be one of the following types: `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.igammac,a,"A `Tensor`. Must be one of the following types: `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.sparse.segment_sqrt_n,indices,A 1-D `Tensor` with indices into `data`. Has same rank as`segment_ids`.,A CONSTANT_NUM D D_STRUCTURE with indices into PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.sparse.segment_sqrt_n,indices,A 1-D `Tensor` with indices into `data`. Has same rank as`segment_ids`.,Has same rank as PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.backend.map_fn,dtype,Output data type.,Output data type,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.map_fn,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,D_TYPE between CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,Fraction of the PARAM to drop for the linear transformation of the inputs,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,Default CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.zeros_like,dtype,"A type for the returned `Tensor`. Must be `float16`, `float32`,`float64`, `int8`, `uint8`, `int16`, `uint16`, `int32`, `int64`,`complex64`, `complex128`, `bool` or `string`.",A type for the returned D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.zeros_like,dtype,"A type for the returned `Tensor`. Must be `float16`, `float32`,`float64`, `int8`, `uint8`, `int16`, `uint16`, `int32`, `int64`,`complex64`, `complex128`, `bool` or `string`.",Must be D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.zeros_like,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.local_conv1d,kernel_size,"a tuple of a single integer, specifying the length of the 1D convolution window.",a D_STRUCTURE of a single D_TYPE specifying the length of the CONSTANT_NUM D convolution window,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.fractional_avg_pool,seed,"An optional `int`.  Defaults to `0`.  If set to be non-zero, the random number generator is seeded by the given seed.  Otherwise it is seeded by a random seed.",An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,seed,"An optional `int`.  Defaults to `0`.  If set to be non-zero, the random number generator is seeded by the given seed.  Otherwise it is seeded by a random seed.",Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,seed,"An optional `int`.  Defaults to `0`.  If set to be non-zero, the random number generator is seeded by the given seed.  Otherwise it is seeded by a random seed.",If set to be non zero the random number generator is seeded by the given seed,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,seed,"An optional `int`.  Defaults to `0`.  If set to be non-zero, the random number generator is seeded by the given seed.  Otherwise it is seeded by a random seed.",Otherwise it is seeded by a random seed,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,seed,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_near,summarize,Print this many entries of each tensor.,Print this many entries of each D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.assert_near,summarize,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.tensordot,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.tensordot,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.sin,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.debugging.assert_all_finite,message,Message to log on failure.,Message to log on failure,,,,,,,
tf.linalg.triangular_solve,adjoint,An optional `bool`. Defaults to `False`. Boolean indicating whether to solve with `matrix` or its (block-wise)        adjoint.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.triangular_solve,adjoint,An optional `bool`. Defaults to `False`. Boolean indicating whether to solve with `matrix` or its (block-wise)        adjoint.,Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.triangular_solve,adjoint,An optional `bool`. Defaults to `False`. Boolean indicating whether to solve with `matrix` or its (block-wise)        adjoint.,D_TYPE indicating whether to solve with PARAM or its BSTR adjoint,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.triangular_solve,adjoint,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_near,rtol,"`Tensor`.  Same `dtype` as, and broadcastable to, `x`. The relative tolerance.  Default is `10 * eps`.",ONE_WORD D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_near,rtol,"`Tensor`.  Same `dtype` as, and broadcastable to, `x`. The relative tolerance.  Default is `10 * eps`.",Same QSTR as and broadcastable to QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_near,rtol,"`Tensor`.  Same `dtype` as, and broadcastable to, `x`. The relative tolerance.  Default is `10 * eps`.",The relative tolerance,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_near,rtol,"`Tensor`.  Same `dtype` as, and broadcastable to, `x`. The relative tolerance.  Default is `10 * eps`.",Default is CONSTANT_NUM eps,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_near,rtol,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,,,
tf.keras.backend.rnn,initial_states,"Tensor with shape `(samples, state_size)`(no time dimension), containing the initial values for the states used in the step function. In the case that state_size is in a nested shape, the shape of initial_states will also follow the nested structure.",D_STRUCTURE with shape BSTR BSTR containing the initial values for the states used in the step function,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.rnn,initial_states,"Tensor with shape `(samples, state_size)`(no time dimension), containing the initial values for the states used in the step function. In the case that state_size is in a nested shape, the shape of initial_states will also follow the nested structure.",In the case that state_size is in a nested shape the shape of initial_states will also follow the nested structure,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.math.softplus,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.softplus,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.AveragePooling3D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`while `channels_first` corresponds to inputs with shape`(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",A D_TYPE one of QSTR BSTR or QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.AveragePooling3D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`while `channels_first` corresponds to inputs with shape`(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",The ordering of the dimensions in the inputs QSTR corresponds to inputs with shape BSTRwhile QSTR corresponds to inputs with shape BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.AveragePooling3D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`while `channels_first` corresponds to inputs with shape`(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",It defaults to the QSTR value found in your Keras config file at keras keras json,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.AveragePooling3D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`while `channels_first` corresponds to inputs with shape`(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",If you never set it then it will be QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.AveragePooling3D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.foldr,initializer,"(optional) A tensor or (possibly nested) sequence of tensors, as the initial value for the accumulator.",BSTR D_STRUCTURE of D_STRUCTURE as the initial value for the accumulator,,,D_STRUCTURE,,,,
tf.foldr,initializer,DF: None,DEFAULT None,,,D_STRUCTURE,,,,
tf.foldl,name,(optional) Name prefix for the returned tensors.,BSTR Name prefix for the returned D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.foldl,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Dot,**kwargs,Standard layer keyword arguments.,Standard layer keyword arguments,,,,,,,
tf.linalg.cross,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.cross,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reduce_logsumexp,keepdims,"If true, retains reduced dimensions with length 1.",If CONSTANT_BOOL retains reduced dimensions with length CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reduce_logsumexp,keepdims,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTM,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,D_TYPE between CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTM,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,Fraction of the PARAM to drop for the linear transformation of the inputs,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTM,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,Default CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTM,dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_args_gradient,num_bits,An optional `int`. Defaults to `8`.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.quantization.fake_quant_with_min_max_args_gradient,num_bits,An optional `int`. Defaults to `8`.,Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.quantization.fake_quant_with_min_max_args_gradient,num_bits,DF: 8,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.image.random_flip_left_right,seed,A Python integer. Used to create a random seed. See`tf.compat.v1.set_random_seed` for behavior.,A Python D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.image.random_flip_left_right,seed,A Python integer. Used to create a random seed. See`tf.compat.v1.set_random_seed` for behavior.,Used to create a random seed,D_TYPE,,,,CONSTANT_VAL,,
tf.image.random_flip_left_right,seed,A Python integer. Used to create a random seed. See`tf.compat.v1.set_random_seed` for behavior.,See tf compat v1 set_random_seed for behavior,D_TYPE,,,,CONSTANT_VAL,,
tf.image.random_flip_left_right,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.train_and_evaluate,train_spec,A `TrainSpec` instance to specify the training specification.,A QSTR instance to specify the training specification,,,,,,,
tf.math.reduce_variance,input_tensor,The tensor to reduce. Should have numeric type.,The D_STRUCTURE to reduce,D_TYPE,D_STRUCTURE,,,,,
tf.math.reduce_variance,input_tensor,The tensor to reduce. Should have numeric type.,Should have D_TYPE type,D_TYPE,D_STRUCTURE,,,,,
tf.nn.ctc_loss,blank_index,"(optional) Set the class index to use for the blank label. Negative values will start from num_classes, ie, -1 will reproduce the ctc_loss behavior of using num_classes - 1 for the blank symbol. There is some memory/performance overhead to switching from the default of 0 as an additional shifted copy of the logits may be created.",BSTR Set the class index to use for the blank label,D_TYPE,,,,,,
tf.nn.ctc_loss,blank_index,"(optional) Set the class index to use for the blank label. Negative values will start from num_classes, ie, -1 will reproduce the ctc_loss behavior of using num_classes - 1 for the blank symbol. There is some memory/performance overhead to switching from the default of 0 as an additional shifted copy of the logits may be created.",Negative values will start from num_classes ie CONSTANT_NUM will reproduce the ctc_loss behavior of using num_classes CONSTANT_NUM for the blank symbol,D_TYPE,,,,,,
tf.nn.ctc_loss,blank_index,"(optional) Set the class index to use for the blank label. Negative values will start from num_classes, ie, -1 will reproduce the ctc_loss behavior of using num_classes - 1 for the blank symbol. There is some memory/performance overhead to switching from the default of 0 as an additional shifted copy of the logits may be created.",There is some memory performance overhead to switching from the default of CONSTANT_NUM as an additional shifted copy of the PARAM may be created,D_TYPE,,,,,,
tf.nn.ctc_loss,blank_index,DF: None,DEFAULT None,D_TYPE,,,,,,
tf.gather_nd,indices,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Index tensor.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.gather_nd,indices,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Index tensor.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.gather_nd,indices,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Index tensor.",Index D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.keras.layers.multiply,**kwargs,Standard layer keyword arguments.,Standard layer keyword arguments,,,,,,,
tf.math.digamma,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.digamma,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.keras.backend.softmax,axis,The dimension softmax would be performed on. The default is -1 which indicates the last dimension.,The dimension softmax would be performed on,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.softmax,axis,The dimension softmax would be performed on. The default is -1 which indicates the last dimension.,The default is CONSTANT_NUM which indicates the last dimension,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.softmax,axis,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.models.clone_model,model,Instance of `Model`(could be a functional model or a Sequential model).,Instance of Model BSTR,,,,,,,
tf.data.experimental.Counter,dtype,(Optional.) The data type for counter elements. Defaults to`tf.int64`.,ONE_WORD BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.Counter,dtype,(Optional.) The data type for counter elements. Defaults to`tf.int64`.,The data type for counter elements,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.Counter,dtype,(Optional.) The data type for counter elements. Defaults to`tf.int64`.,Defaults toD_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.Counter,dtype,DF: tf.dtypes.int64,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,alpha,"An optional `float`. Defaults to `1`. A scale factor, usually positive.",An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,alpha,"An optional `float`. Defaults to `1`. A scale factor, usually positive.",Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,alpha,"An optional `float`. Defaults to `1`. A scale factor, usually positive.",A scale factor usually positive,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,alpha,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Embedding,output_dim,int >= 0. Dimension of the dense embedding.,D_TYPE REXPR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Embedding,output_dim,int >= 0. Dimension of the dense embedding.,Dimension of the dense embedding,D_TYPE,,,,CONSTANT_VAL,,
tf.image.convert_image_dtype,name,A name for this operation (optional).,A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.image.convert_image_dtype,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.random.gamma,beta,A Tensor or Python value or N-D array of type `dtype`. Defaults to 1.`beta` provides the inverse scale parameter(s) of the gamma distribution(s) to sample. Must be broadcastable with `alpha`.,A D_STRUCTURE or Python value or N D D_STRUCTURE of type PARAM,D_TYPE,D_STRUCTURE,D_STRUCTURE,,CONSTANT_VAL,,
tf.random.gamma,beta,A Tensor or Python value or N-D array of type `dtype`. Defaults to 1.`beta` provides the inverse scale parameter(s) of the gamma distribution(s) to sample. Must be broadcastable with `alpha`.,Defaults to CONSTANT_FLOATbeta provides the inverse scale parameter BSTR to sample,D_TYPE,D_STRUCTURE,D_STRUCTURE,,CONSTANT_VAL,,
tf.random.gamma,beta,A Tensor or Python value or N-D array of type `dtype`. Defaults to 1.`beta` provides the inverse scale parameter(s) of the gamma distribution(s) to sample. Must be broadcastable with `alpha`.,Must be broadcastable with PARAM,D_TYPE,D_STRUCTURE,D_STRUCTURE,,CONSTANT_VAL,,
tf.random.gamma,beta,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected2D,use_bias,"Boolean, whether the layer uses a bias vector.",D_TYPE whether the layer uses a bias vector,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected2D,use_bias,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.scan,fn,"The callable to be performed.  It accepts two arguments.  The first will have the same structure as `initializer` if one is provided, otherwise it will have the same structure as `elems`.  The second will have the same (possibly nested) structure as `elems`.  Its output must have the same structure as `initializer` if one is provided, otherwise it must have the same structure as `elems`.",The callable to be performed,,,,,,,
tf.scan,fn,"The callable to be performed.  It accepts two arguments.  The first will have the same structure as `initializer` if one is provided, otherwise it will have the same structure as `elems`.  The second will have the same (possibly nested) structure as `elems`.  Its output must have the same structure as `initializer` if one is provided, otherwise it must have the same structure as `elems`.",It accepts two arguments,,,,,,,
tf.scan,fn,"The callable to be performed.  It accepts two arguments.  The first will have the same structure as `initializer` if one is provided, otherwise it will have the same structure as `elems`.  The second will have the same (possibly nested) structure as `elems`.  Its output must have the same structure as `initializer` if one is provided, otherwise it must have the same structure as `elems`.",The first will have the same structure as PARAM if one is provided otherwise it will have the same structure as PARAM,,,,,,,
tf.scan,fn,"The callable to be performed.  It accepts two arguments.  The first will have the same structure as `initializer` if one is provided, otherwise it will have the same structure as `elems`.  The second will have the same (possibly nested) structure as `elems`.  Its output must have the same structure as `initializer` if one is provided, otherwise it must have the same structure as `elems`.",The second will have the same BSTR structure as PARAM,,,,,,,
tf.scan,fn,"The callable to be performed.  It accepts two arguments.  The first will have the same structure as `initializer` if one is provided, otherwise it will have the same structure as `elems`.  The second will have the same (possibly nested) structure as `elems`.  Its output must have the same structure as `initializer` if one is provided, otherwise it must have the same structure as `elems`.",Its output must have the same structure as PARAM if one is provided otherwise it must have the same structure as PARAM,,,,,,,
tf.math.bessel_i0e,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.bessel_i0e,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.keras.backend.gather,indices,An integer tensor of indices.,An D_TYPE D_STRUCTURE of indices,D_TYPE,D_STRUCTURE,,,,,
tf.nn.collapse_repeated,labels,"Tensor of shape [batch, max value in seq_length]",D_STRUCTURE of shape BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.signal.linear_to_mel_weight_matrix,dtype,The `DType` of the result matrix. Must be a floating point type.,The QSTR of the result matrix,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.linear_to_mel_weight_matrix,dtype,The `DType` of the result matrix. Must be a floating point type.,Must be a D_TYPE point type,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.linear_to_mel_weight_matrix,dtype,DF: tf.dtypes.float32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,batch_size,An int representing the number of records to combine in a single batch.,An D_TYPE representing the number of records to combine in a single batch,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.math.reduce_mean,keepdims,"If true, retains reduced dimensions with length 1.",If CONSTANT_BOOL retains reduced dimensions with length CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reduce_mean,keepdims,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.experimental.stop_if_higher_hook,run_every_secs,"If specified, calls `should_stop_fn` at an interval of`run_every_secs` seconds. Defaults to 60 seconds. Either this or`run_every_steps` must be set.",If specified calls QSTR at an interval of QSTR seconds,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.experimental.stop_if_higher_hook,run_every_secs,"If specified, calls `should_stop_fn` at an interval of`run_every_secs` seconds. Defaults to 60 seconds. Either this or`run_every_steps` must be set.",Defaults to CONSTANT_NUM seconds,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.experimental.stop_if_higher_hook,run_every_secs,"If specified, calls `should_stop_fn` at an interval of`run_every_secs` seconds. Defaults to 60 seconds. Either this or`run_every_steps` must be set.",Either this or PARAM must be set,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.experimental.stop_if_higher_hook,run_every_secs,DF: 60,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.random.uniform,maxval,"A Tensor or Python value of type `dtype`, broadcastable with`minval`. The upper bound on the range of random values to generate (exclusive). Defaults to 1 if `dtype` is floating point.",A D_STRUCTURE or Python value of type PARAM broadcastable with PARAM,D_TYPE,D_STRUCTURE,,,,,
tf.random.uniform,maxval,"A Tensor or Python value of type `dtype`, broadcastable with`minval`. The upper bound on the range of random values to generate (exclusive). Defaults to 1 if `dtype` is floating point.",The upper bound on the range of random values to generate BSTR,D_TYPE,D_STRUCTURE,,,,,
tf.random.uniform,maxval,"A Tensor or Python value of type `dtype`, broadcastable with`minval`. The upper bound on the range of random values to generate (exclusive). Defaults to 1 if `dtype` is floating point.",Defaults to CONSTANT_NUM if PARAM is D_TYPE point,D_TYPE,D_STRUCTURE,,,,,
tf.random.uniform,maxval,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_negative,message,A string to prefix to the default message.,A D_TYPE to prefix to the default message,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_negative,message,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.image.resize,size,"A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The new size for the images.",A CONSTANT_NUM D D_TYPE D_STRUCTURE of CONSTANT_NUM elements new_height new_width,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.image.resize,size,"A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The new size for the images.",The new size for the PARAM,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.estimator.experimental.stop_if_no_decrease_hook,run_every_steps,"If specified, calls `should_stop_fn` every`run_every_steps` steps. Either this or `run_every_secs` must be set.",If specified calls QSTR every QSTR steps,,,,,,,
tf.estimator.experimental.stop_if_no_decrease_hook,run_every_steps,"If specified, calls `should_stop_fn` every`run_every_steps` steps. Either this or `run_every_secs` must be set.",Either this or PARAM must be set,,,,,,,
tf.estimator.experimental.stop_if_no_decrease_hook,run_every_steps,DF: None,DEFAULT None,,,,,,,
tf.random.stateless_normal,mean,A 0-D Tensor or Python value of type `dtype`. The mean of the normal distribution.,A CONSTANT_NUM D D_STRUCTURE or Python value of type PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.random.stateless_normal,mean,A 0-D Tensor or Python value of type `dtype`. The mean of the normal distribution.,The mean of the normal distribution,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.random.stateless_normal,mean,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.nn.max_pool3d,padding,"A string, either `'VALID'` or `'SAME'`. The padding algorithm. See the ""returns"" section of `tf.nn.convolution` for details.",A D_TYPE either QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.max_pool3d,padding,"A string, either `'VALID'` or `'SAME'`. The padding algorithm. See the ""returns"" section of `tf.nn.convolution` for details.",The padding algorithm,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.max_pool3d,padding,"A string, either `'VALID'` or `'SAME'`. The padding algorithm. See the ""returns"" section of `tf.nn.convolution` for details.",See the QSTR section of tf nn convolution for details,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.utils.get_file,origin,Original URL of the file.,Original URL of the file,,,,,,,
tf.nn.pool,dilations,"Optional.  Dilation rate.  List of N ints >= 1. Defaults to [1]*N.  If any value of dilation_rate is > 1, then all values of strides must be 1.",ONE_WORD Optional,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,1]",
tf.nn.pool,dilations,"Optional.  Dilation rate.  List of N ints >= 1. Defaults to [1]*N.  If any value of dilation_rate is > 1, then all values of strides must be 1.",Dilation rate,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,1]",
tf.nn.pool,dilations,"Optional.  Dilation rate.  List of N ints >= 1. Defaults to [1]*N.  If any value of dilation_rate is > 1, then all values of strides must be 1.",D_STRUCTURE of N D_TYPE REXPR,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,1]",
tf.nn.pool,dilations,"Optional.  Dilation rate.  List of N ints >= 1. Defaults to [1]*N.  If any value of dilation_rate is > 1, then all values of strides must be 1.",Defaults to BSTR N If any value of dilation_rate is REXPR then all values of PARAM must be CONSTANT_NUM,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,1]",
tf.nn.pool,dilations,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,1]",
tf.io.decode_raw,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_raw,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.image.encode_png,compression,An optional `int`. Defaults to `-1`. Compression level.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.image.encode_png,compression,An optional `int`. Defaults to `-1`. Compression level.,Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.image.encode_png,compression,An optional `int`. Defaults to `-1`. Compression level.,Compression level,D_TYPE,,,,CONSTANT_VAL,,
tf.image.encode_png,compression,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.image.resize_with_pad,antialias,Whether to use anti-aliasing when resizing. See 'image.resize()'.,Whether to use anti aliasing when resizing,D_TYPE,,,,CONSTANT_VAL,,
tf.image.resize_with_pad,antialias,Whether to use anti-aliasing when resizing. See 'image.resize()'.,See PARAM resize,D_TYPE,,,,CONSTANT_VAL,,
tf.image.resize_with_pad,antialias,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.triangular_solve,lower,An optional `bool`. Defaults to `True`. Boolean indicating whether the innermost matrices in `matrix` are lower or upper triangular.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.triangular_solve,lower,An optional `bool`. Defaults to `True`. Boolean indicating whether the innermost matrices in `matrix` are lower or upper triangular.,Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.triangular_solve,lower,An optional `bool`. Defaults to `True`. Boolean indicating whether the innermost matrices in `matrix` are lower or upper triangular.,D_TYPE indicating whether the innermost matrices in PARAM are lower or upper triangular,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.triangular_solve,lower,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.ctc_loss,logits,"tensor of shape [frames, batch_size, num_labels], if logits_time_major == False, shape is [batch_size, frames, num_labels].",D_STRUCTURE of shape BSTR if PARAM CONSTANT_BOOL shape is BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.relu6,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.relu6,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNNCell,kernel_initializer,"Initializer for the `kernel` weights matrix, used for the linear transformation of the inputs. Default:`glorot_uniform`.",Initializer for the QSTR weights matrix used for the linear transformation of the inputs,D_TYPE,,,,,,
tf.keras.layers.SimpleRNNCell,kernel_initializer,"Initializer for the `kernel` weights matrix, used for the linear transformation of the inputs. Default:`glorot_uniform`.",Default QSTR,D_TYPE,,,,,,
tf.keras.layers.SimpleRNNCell,kernel_initializer,DF: glorot_uniform,DEFAULT DF_STR,D_TYPE,,,,,,
tf.dtypes.saturate_cast,value,A `Tensor`.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.dtypes.complex,imag,A `Tensor`. Must have the same type as `real`.,A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.dtypes.complex,imag,A `Tensor`. Must have the same type as `real`.,Must have the same type as PARAM,D_TYPE,D_STRUCTURE,,,,,
tf.keras.backend.transpose,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.truncatediv,y,A `Tensor`. Must have the same type as `x`.,A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.truncatediv,y,A `Tensor`. Must have the same type as `x`.,Must have the same type as QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.strided_slice,begin,An `int32` or `int64` `Tensor`.,An D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,activity_regularizer,"Regularizer function applied to the output of the layer (its ""activation"")..",Regularizer function applied to the output of the layer BSTR,,,,,,,
tf.keras.layers.LocallyConnected1D,activity_regularizer,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.max,axis,"An integer, the axis to find maximum values.",An D_TYPE the axis to find maximum values,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.max,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.sets.union,validate_indices,Whether to validate the order and range of sparse indices in `a` and `b`.,Whether to validate the order and range of sparse indices in QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.sets.union,validate_indices,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.foldr,elems,"A tensor or (possibly nested) sequence of tensors, each of which will be unpacked along their first dimension.  The nested sequence of the resulting slices will be the first argument to `fn`.",A D_STRUCTURE or BSTR D_STRUCTURE of D_STRUCTURE each of which will be unpacked along their first dimension,,D_STRUCTURE,D_STRUCTURE,,,,
tf.foldr,elems,"A tensor or (possibly nested) sequence of tensors, each of which will be unpacked along their first dimension.  The nested sequence of the resulting slices will be the first argument to `fn`.",The nested D_STRUCTURE of the resulting slices will be the first argument to PARAM,,D_STRUCTURE,D_STRUCTURE,,,,
tf.quantization.quantize_and_dequantize,round_mode,"Rounding mode when rounding from float values to quantized ones. one of ['HALF_TO_EVEN', 'HALF_UP']",Rounding mode when rounding from D_TYPE values to quantized ones,D_TYPE,,,,,,
tf.quantization.quantize_and_dequantize,round_mode,"Rounding mode when rounding from float values to quantized ones. one of ['HALF_TO_EVEN', 'HALF_UP']",one of QSTR,D_TYPE,,,,,,
tf.quantization.quantize_and_dequantize,round_mode,DF: HALF_TO_EVEN,DEFAULT DF_STR,D_TYPE,,,,,,
tf.nn.embedding_lookup_sparse,params,"A single tensor representing the complete embedding tensor, or a list of P tensors all of same shape except for the first dimension, representing sharded embedding tensors.  Alternatively, a`PartitionedVariable`, created by partitioning along dimension 0. Each element must be appropriately sized for `""div""` `partition_strategy`.",A single D_STRUCTURE representing the complete embedding D_STRUCTURE of P D_STRUCTURE all of same shape except for the first dimension representing sharded embedding D_STRUCTURE,,D_STRUCTURE,D_STRUCTURE,,,,
tf.nn.embedding_lookup_sparse,params,"A single tensor representing the complete embedding tensor, or a list of P tensors all of same shape except for the first dimension, representing sharded embedding tensors.  Alternatively, a`PartitionedVariable`, created by partitioning along dimension 0. Each element must be appropriately sized for `""div""` `partition_strategy`.",Alternatively a QSTR created by partitioning along dimension CONSTANT_NUM,,D_STRUCTURE,D_STRUCTURE,,,,
tf.nn.embedding_lookup_sparse,params,"A single tensor representing the complete embedding tensor, or a list of P tensors all of same shape except for the first dimension, representing sharded embedding tensors.  Alternatively, a`PartitionedVariable`, created by partitioning along dimension 0. Each element must be appropriately sized for `""div""` `partition_strategy`.",Each element must be appropriately sized for QSTR,,D_STRUCTURE,D_STRUCTURE,,,,
tf.keras.backend.depthwise_conv2d,strides,strides tuple (length 2).,strides D_STRUCTURE BSTR,,,,,CONSTANT_VAL,,
tf.keras.backend.depthwise_conv2d,strides,"DF: (1, 1)",DEFAULT CONSTANT_NUM,,,,,CONSTANT_VAL,,
tf.random.fixed_unigram_candidate_sampler,seed,An `int`. An operation-specific seed. Default is 0.,An D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.random.fixed_unigram_candidate_sampler,seed,An `int`. An operation-specific seed. Default is 0.,An operation specific seed,D_TYPE,,,,CONSTANT_VAL,,
tf.random.fixed_unigram_candidate_sampler,seed,An `int`. An operation-specific seed. Default is 0.,Default is CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.random.fixed_unigram_candidate_sampler,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,kernel_size,"An integer or tuple/list of a single integer, specifying the length of the 1D convolution window.",An D_TYPE or D_STRUCTURE of a single D_TYPE specifying the length of the CONSTANT_NUM D convolution window,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.image.crop_to_bounding_box,target_height,Height of the result.,Height of the result,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.math.rint,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.rint,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.io.decode_image,expand_animations,"Controls the shape of the returned op's output. If`True`, the returned op will produce a 3-D tensor for PNG, JPEG, and BMP files; and a 4-D tensor for all GIFs, whether animated or not. If,`False`, the returned op will produce a 3-D tensor for all file types and will truncate animated GIFs to the first frame.",Controls the shape of the returned op output,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.io.decode_image,expand_animations,"Controls the shape of the returned op's output. If`True`, the returned op will produce a 3-D tensor for PNG, JPEG, and BMP files; and a 4-D tensor for all GIFs, whether animated or not. If,`False`, the returned op will produce a 3-D tensor for all file types and will truncate animated GIFs to the first frame.",If CONSTANT_BOOL the returned op will produce a CONSTANT_NUM D D_STRUCTURE for PNG JPEG and BMP files and a CONSTANT_NUM D D_STRUCTURE for all GIFs whether animated or not,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.io.decode_image,expand_animations,"Controls the shape of the returned op's output. If`True`, the returned op will produce a 3-D tensor for PNG, JPEG, and BMP files; and a 4-D tensor for all GIFs, whether animated or not. If,`False`, the returned op will produce a 3-D tensor for all file types and will truncate animated GIFs to the first frame.",If CONSTANT_BOOL the returned op will produce a CONSTANT_NUM D D_STRUCTURE for all file types and will truncate animated GIFs to the first frame,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.io.decode_image,expand_animations,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.reduce_logsumexp,input_tensor,The tensor to reduce. Should have numeric type.,The D_STRUCTURE to reduce,D_TYPE,D_STRUCTURE,,,,,
tf.math.reduce_logsumexp,input_tensor,The tensor to reduce. Should have numeric type.,Should have D_TYPE type,D_TYPE,D_STRUCTURE,,,,,
tf.where,y,"A Tensor which is of the same type as `x`, and may be broadcastable with`condition` and `x`.",A D_STRUCTURE which is of the same type as QSTR and may be broadcastable with PARAM and QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.where,y,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,,,
tf.keras.layers.LayerNormalization,beta_initializer,Initializer for the beta weight.,Initializer for the beta weight,D_TYPE,,,,,,
tf.keras.layers.LayerNormalization,beta_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.data.experimental.bucket_by_sequence_length,drop_remainder,"(Optional.) A `tf.bool` scalar `tf.Tensor`, representing whether the last batch should be dropped in the case it has fewer than`batch_size` elements; the default behavior is not to drop the smaller batch.",ONE_WORD BSTR,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.data.experimental.bucket_by_sequence_length,drop_remainder,"(Optional.) A `tf.bool` scalar `tf.Tensor`, representing whether the last batch should be dropped in the case it has fewer than`batch_size` elements; the default behavior is not to drop the smaller batch.",A D_TYPE scalar D_STRUCTURE representing whether the last batch should be dropped in the case it has fewer than QSTR elements the default behavior is not to drop the smaller batch,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.data.experimental.bucket_by_sequence_length,drop_remainder,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.adjust_jpeg_quality,name,A name for this operation (optional).,A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.image.adjust_jpeg_quality,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.image.adjust_gamma,image,RGB image or images to adjust.,RGB image or images to adjust,D_TYPE,,,,,,
tf.random.stateless_normal,seed,A shape [2] integer Tensor of seeds to the random number generator.,A PARAM BSTR D_TYPE D_STRUCTURE of seeds to the random number generator,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.sparse.slice,sp_input,The `SparseTensor` to split.,The D_STRUCTURE to split,,D_STRUCTURE,,,,,
tf.ragged.range,dtype,"The type of the elements of the resulting tensor.  If not specified, then a value is chosen based on the other args.",The type of the elements of the resulting D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.range,dtype,"The type of the elements of the resulting tensor.  If not specified, then a value is chosen based on the other args.",If not specified then a value is chosen based on the other args,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.range,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.unstack,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.unstack,name,DF: unstack,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.DepthwiseConv2D,depth_multiplier,The number of depthwise convolution output channels for each input channel. The total number of depthwise convolution output channels will be equal to `filters_in * depth_multiplier`.,The number of depthwise convolution output channels for each input channel,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.DepthwiseConv2D,depth_multiplier,The number of depthwise convolution output channels for each input channel. The total number of depthwise convolution output channels will be equal to `filters_in * depth_multiplier`.,The total number of depthwise convolution output channels will be equal to filters_in depth_multiplier,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.DepthwiseConv2D,depth_multiplier,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.preprocessing.text.text_to_word_sequence,filters,"list (or concatenation) of characters to filter out, such as     punctuation. Default: ``!""#$%&()*+,-./:;<=>?@[\]^_`{|}~\t\n``,     includes basic punctuation, tabs, and newlines.",D_STRUCTURE BSTR of characters to filter out such as punctuation,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.preprocessing.text.text_to_word_sequence,filters,"list (or concatenation) of characters to filter out, such as     punctuation. Default: ``!""#$%&()*+,-./:;<=>?@[\]^_`{|}~\t\n``,     includes basic punctuation, tabs, and newlines.",ONE_WORD Default,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.preprocessing.text.text_to_word_sequence,filters,"list (or concatenation) of characters to filter out, such as     punctuation. Default: ``!""#$%&()*+,-./:;<=>?@[\]^_`{|}~\t\n``,     includes basic punctuation, tabs, and newlines.",t n includes basic punctuation tabs and newlines,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.preprocessing.text.text_to_word_sequence,filters,"DF: !""#$%&()*+,-./:;<=>?@[\\]^_`{|}~\t\n",t n,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.layers.SeparableConv1D,name,"A string, the name of the layer.",A D_TYPE the name of the layer,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SeparableConv1D,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.extract_volume_patches,strides,"A list of `ints` that has length `>= 5`. 1-D of length 5. How far the centers of two consecutive patches are in`input`. Must be: `[1, stride_planes, stride_rows, stride_cols, 1]`.",A D_STRUCTURE of D_TYPE that has length REXPR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.extract_volume_patches,strides,"A list of `ints` that has length `>= 5`. 1-D of length 5. How far the centers of two consecutive patches are in`input`. Must be: `[1, stride_planes, stride_rows, stride_cols, 1]`.",CONSTANT_NUM D of length CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.extract_volume_patches,strides,"A list of `ints` that has length `>= 5`. 1-D of length 5. How far the centers of two consecutive patches are in`input`. Must be: `[1, stride_planes, stride_rows, stride_cols, 1]`.",How far the centers of two consecutive patches are in PARAM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.extract_volume_patches,strides,"A list of `ints` that has length `>= 5`. 1-D of length 5. How far the centers of two consecutive patches are in`input`. Must be: `[1, stride_planes, stride_rows, stride_cols, 1]`.",Must be BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.ragged.stack,axis,"A python integer, indicating the dimension along which to stack. (Note: Unlike `tf.stack`, the `axis` parameter must be statically known.) Negative values are supported only if the rank of at least one`values` value is statically known.",A python D_TYPE indicating the dimension along which to stack,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.stack,axis,"A python integer, indicating the dimension along which to stack. (Note: Unlike `tf.stack`, the `axis` parameter must be statically known.) Negative values are supported only if the rank of at least one`values` value is statically known.",Note Unlike tf stack the QSTR parameter must be statically known,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.stack,axis,"A python integer, indicating the dimension along which to stack. (Note: Unlike `tf.stack`, the `axis` parameter must be statically known.) Negative values are supported only if the rank of at least one`values` value is statically known.",Negative PARAM are supported only if the rank of at least one PARAM value is statically known,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.stack,axis,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.math.unsorted_segment_sqrt_n,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.unsorted_segment_sqrt_n,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ConvLSTM2D,recurrent_activation,Activation function to use for the recurrent step.,PARAM function to use for the recurrent step,,,,,,,
tf.keras.layers.ConvLSTM2D,recurrent_activation,DF: hard_sigmoid,DEFAULT DF_STR,,,,,,,
tf.keras.utils.plot_model,show_shapes,whether to display shape information.,whether to display shape information,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.utils.plot_model,show_shapes,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.not_equal,y,A `tf.Tensor` or `tf.SparseTensor` or `tf.IndexedSlices`.,A D_STRUCTURE or tf IndexedSlices,,D_STRUCTURE,,,,,
tf.sparse.minimum,name,optional name of the operation.,optional name of the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.minimum,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.sparse_dense_matmul,adjoint_a,"Use the adjoint of A in the matrix multiply.  If A is complex, this is transpose(conj(A)).  Otherwise it's transpose(A).",Use the adjoint of A in the matrix multiply,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.sparse_dense_matmul,adjoint_a,"Use the adjoint of A in the matrix multiply.  If A is complex, this is transpose(conj(A)).  Otherwise it's transpose(A).",If A is D_TYPE this is transpose BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.sparse_dense_matmul,adjoint_a,"Use the adjoint of A in the matrix multiply.  If A is complex, this is transpose(conj(A)).  Otherwise it's transpose(A).",Otherwise it transpose BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.sparse_dense_matmul,adjoint_a,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.substr,pos,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Scalar defining the position of first character in each substring",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.strings.substr,pos,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Scalar defining the position of first character in each substring",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.strings.substr,pos,"A `Tensor`. Must be one of the following types: `int32`, `int64`. Scalar defining the position of first character in each substring",Scalar defining the position of first character in each substring,D_TYPE,D_STRUCTURE,,,,,
tf.math.acosh,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.acosh,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.segment_sum,data,A `Tensor` with data that will be assembled in the output.,A D_STRUCTURE with data that will be assembled in the output,,D_STRUCTURE,,,,,
tf.keras.backend.variable,constraint,Optional projection function to be applied to the variable after an optimizer update.,Optional projection function to be applied to the variable after an optimizer update,,,,,,,
tf.keras.backend.variable,constraint,DF: None,DEFAULT None,,,,,,,
tf.math.count_nonzero,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.count_nonzero,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.expm1,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `complex64`, `complex128`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.expm1,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `complex64`, `complex128`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.linalg.cross,b,"A `Tensor`. Must have the same type as `a`. Another tensor, of same type and shape as `a`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,BSTR,,,
tf.linalg.cross,b,"A `Tensor`. Must have the same type as `a`. Another tensor, of same type and shape as `a`.",Must have the same type as QSTR,D_TYPE,D_STRUCTURE,,BSTR,,,
tf.linalg.cross,b,"A `Tensor`. Must have the same type as `a`. Another tensor, of same type and shape as `a`.",Another D_STRUCTURE of same type and shape as QSTR,D_TYPE,D_STRUCTURE,,BSTR,,,
tf.keras.backend.random_normal_variable,seed,"Integer, random seed.",D_TYPE random seed,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.random_normal_variable,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.collapse_repeated,name,"A name for this `Op`. Defaults to ""collapse_repeated_labels"".",A name for this QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.collapse_repeated,name,"A name for this `Op`. Defaults to ""collapse_repeated_labels"".",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.collapse_repeated,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_proto,bytes,A `Tensor` of type `string`. Tensor of serialized protos with shape `batch_shape`.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.io.decode_proto,bytes,A `Tensor` of type `string`. Tensor of serialized protos with shape `batch_shape`.,D_STRUCTURE of serialized protos with shape QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.signal.idct,axis,For future expansion. The axis to compute the DCT along. Must be `-1`.,For future expansion,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.idct,axis,For future expansion. The axis to compute the DCT along. Must be `-1`.,The axis to compute the DCT along,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.idct,axis,For future expansion. The axis to compute the DCT along. Must be `-1`.,Must be CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.idct,axis,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.pool2d,pool_mode,"string, `""max""` or `""avg""`.",D_TYPE QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.pool2d,pool_mode,DF: max,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.conv3d,data_format,"string, `""channels_last""` or `""channels_first""`.",D_TYPE QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.conv3d,data_format,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.separable_conv2d,x,input tensor,input D_STRUCTURE,,D_STRUCTURE,,,,,
tf.boolean_mask,mask,"K-D boolean tensor, K <= N and K must be known statically.",K D D_TYPE D_STRUCTURE K REXPR and K must be known statically,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.linalg.adjoint,name,A name to give this `Op` (optional).,A name to give this QSTR BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.adjoint,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.array_to_img,scale,"Whether to rescale image values to be within `[0, 255]`.",Whether to rescale image values to be within BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,255]",
tf.keras.preprocessing.image.array_to_img,scale,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,"[0,255]",
tf.strings.reduce_join,axis,"Which axis to join along. The default behavior is to join all elements, producing a scalar.",Which axis to join along,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.reduce_join,axis,"Which axis to join along. The default behavior is to join all elements, producing a scalar.",The default behavior is to join all elements producing a scalar,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.reduce_join,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.einsum,*inputs,"the inputs to contract (each one a `Tensor`), whose shapes should be consistent with `equation`.",the inputs to contract BSTR whose shapes should be consistent with PARAM,,,,,,,
tf.graph_util.import_graph_def,return_elements,A list of strings containing operation names in`graph_def` that will be returned as `Operation` objects; and/or tensor names in `graph_def` that will be returned as `Tensor` objects.,A D_STRUCTURE of D_TYPE containing operation names in PARAM that will be returned as QSTR objects and or D_STRUCTURE names in PARAM that will be returned as D_STRUCTURE objects,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.graph_util.import_graph_def,return_elements,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.ragged.boolean_mask,name,A name prefix for the returned tensor (optional).,A name prefix for the returned D_STRUCTURE BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.boolean_mask,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.random.stateless_normal,dtype,The type of the output.,The type of the output,D_TYPE,,,,CONSTANT_VAL,,
tf.random.stateless_normal,dtype,DF: tf.dtypes.float32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.searchsorted,side,'left' or 'right'; 'left' corresponds to lower_bound and 'right' to upper_bound.,QSTR QSTR corresponds to lower_bound and QSTR to upper_bound,D_TYPE,,,,,,
tf.searchsorted,side,DF: left,DEFAULT DF_STR,D_TYPE,,,,,,
tf.image.non_max_suppression_overlaps,overlap_threshold,A float representing the threshold for deciding whether boxes overlap too much with respect to the provided overlap values.,A D_TYPE representing the threshold for deciding whether boxes overlap too much with respect to the provided overlap values,D_TYPE,,,,CONSTANT_VAL,,
tf.image.non_max_suppression_overlaps,overlap_threshold,DF: 0.5,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.random.categorical,seed,A Python integer. Used to create a random seed for the distribution. See `tf.compat.v1.set_random_seed` for behavior.,A Python D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.random.categorical,seed,A Python integer. Used to create a random seed for the distribution. See `tf.compat.v1.set_random_seed` for behavior.,Used to create a random seed for the distribution,D_TYPE,,,,CONSTANT_VAL,,
tf.random.categorical,seed,A Python integer. Used to create a random seed for the distribution. See `tf.compat.v1.set_random_seed` for behavior.,See tf compat v1 set_random_seed for behavior,D_TYPE,,,,CONSTANT_VAL,,
tf.random.categorical,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.dtype,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.strings.regex_replace,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.regex_replace,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.ctc_loss,unique,"(optional) Unique label indices as computed by ctc_unique_labels(labels).  If supplied, enable a faster, memory efficient implementation on TPU.",ONE_WORD BSTR,,,,,,,
tf.nn.ctc_loss,unique,"(optional) Unique label indices as computed by ctc_unique_labels(labels).  If supplied, enable a faster, memory efficient implementation on TPU.",If supplied enable a faster memory efficient implementation on TPU,,,,,,,
tf.nn.ctc_loss,unique,DF: None,DEFAULT None,,,,,,,
tf.nn.max_pool,ksize,"An int or list of `ints` that has length `1`, `N` or `N+2`. The size of the window for each dimension of the input tensor.",An D_TYPE or D_STRUCTURE of D_TYPE that has length CONSTANT_NUM QSTR or N CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.max_pool,ksize,"An int or list of `ints` that has length `1`, `N` or `N+2`. The size of the window for each dimension of the input tensor.",The size of the window for each dimension of the PARAM D_STRUCTURE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.quantization.fake_quant_with_min_max_vars_gradient,min,A `Tensor` of type `float32`.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.cond,pred,A scalar determining whether to return the result of `true_fn` or`false_fn`.,A scalar determining whether to return the result of PARAM or PARAM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.array_to_img,x,Input Numpy array.,Input Numpy D_STRUCTURE,,,,,,,
tf.nn.max_pool3d,strides,"An int or list of `ints` that has length `1`, `3` or `5`. The stride of the sliding window for each dimension of the input tensor.",An D_TYPE or D_STRUCTURE of D_TYPE that has length CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.max_pool3d,strides,"An int or list of `ints` that has length `1`, `3` or `5`. The stride of the sliding window for each dimension of the input tensor.",The stride of the sliding window for each dimension of the PARAM D_STRUCTURE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.linalg.tridiagonal_matmul,name,A name to give this `Op` (optional).,A name to give this QSTR BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.tridiagonal_matmul,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.argmax,axis,"A `Tensor`. Must be one of the following types: `int32`, `int64`. int32 or int64, must be in the range `-rank(input), rank(input))`. Describes which axis of the input Tensor to reduce across. For vectors, use axis = 0.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.argmax,axis,"A `Tensor`. Must be one of the following types: `int32`, `int64`. int32 or int64, must be in the range `-rank(input), rank(input))`. Describes which axis of the input Tensor to reduce across. For vectors, use axis = 0.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.argmax,axis,"A `Tensor`. Must be one of the following types: `int32`, `int64`. int32 or int64, must be in the range `-rank(input), rank(input))`. Describes which axis of the input Tensor to reduce across. For vectors, use axis = 0.",D_TYPE must be in the range rank BSTR,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.argmax,axis,"A `Tensor`. Must be one of the following types: `int32`, `int64`. int32 or int64, must be in the range `-rank(input), rank(input))`. Describes which axis of the input Tensor to reduce across. For vectors, use axis = 0.",Describes which axis of the PARAM D_STRUCTURE to reduce across,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.argmax,axis,"A `Tensor`. Must be one of the following types: `int32`, `int64`. int32 or int64, must be in the range `-rank(input), rank(input))`. Describes which axis of the input Tensor to reduce across. For vectors, use axis = 0.",For vectors use axis CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.argmax,axis,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.linalg.triangular_solve,rhs,"A `Tensor`. Must have the same type as `matrix`. Shape is `[..., M, K]`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.linalg.triangular_solve,rhs,"A `Tensor`. Must have the same type as `matrix`. Shape is `[..., M, K]`.",Must have the same type as PARAM,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.linalg.triangular_solve,rhs,"A `Tensor`. Must have the same type as `matrix`. Shape is `[..., M, K]`.",Shape is BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.random.uniform_candidate_sampler,num_sampled,"An `int`.  The number of classes to randomly sample. The`sampled_candidates` return value will have shape `[num_sampled]`. If`unique=True`, `num_sampled` must be less than or equal to `range_max`.",An D_TYPE,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.random.uniform_candidate_sampler,num_sampled,"An `int`.  The number of classes to randomly sample. The`sampled_candidates` return value will have shape `[num_sampled]`. If`unique=True`, `num_sampled` must be less than or equal to `range_max`.",The number of classes to randomly sample,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.random.uniform_candidate_sampler,num_sampled,"An `int`.  The number of classes to randomly sample. The`sampled_candidates` return value will have shape `[num_sampled]`. If`unique=True`, `num_sampled` must be less than or equal to `range_max`.",The QSTR return value will have shape BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.random.uniform_candidate_sampler,num_sampled,"An `int`.  The number of classes to randomly sample. The`sampled_candidates` return value will have shape `[num_sampled]`. If`unique=True`, `num_sampled` must be less than or equal to `range_max`.",If PARAM CONSTANT_BOOL QSTR must be less than or equal to PARAM,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.io.serialize_sparse,sp_input,The input `SparseTensor`.,The input D_STRUCTURE,,D_STRUCTURE,,,,,
tf.sparse.fill_empty_rows,sp_input,"A `SparseTensor` with shape `[N, M]`.",A D_STRUCTURE with shape BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.math.xlogy,x,"A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `complex64`, `complex128`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.xlogy,x,"A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `complex64`, `complex128`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.sparse.segment_mean,segment_ids,A 1-D `Tensor` with indices into the output `Tensor`. Values should be sorted and can be repeated.,A CONSTANT_NUM D D_STRUCTURE with PARAM into the output D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.sparse.segment_mean,segment_ids,A 1-D `Tensor` with indices into the output `Tensor`. Values should be sorted and can be repeated.,Values should be sorted and can be repeated,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.strings.regex_replace,input,"string `Tensor`, the source strings to process.",D_TYPE D_STRUCTURE the source D_TYPE to process,D_TYPE,D_STRUCTURE,,,,,
tf.keras.layers.average,**kwargs,Standard layer keyword arguments.,Standard layer keyword arguments,,,,,,,
tf.linalg.pinv,a,(Batch of) `float`-like matrix-shaped `Tensor`(s) which are to be pseudo-inverted.,BSTR which are to be pseudo inverted,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,value,"A `Tensor`. 4-D with shape `[batch, height, width, channels]`.",A D_STRUCTURE,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,value,"A `Tensor`. 4-D with shape `[batch, height, width, channels]`.",CONSTANT_NUM D with shape BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.map_fn,name,(optional) Name prefix for the returned tensors.,BSTR Name prefix for the returned D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.map_fn,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.parse_single_sequence_example,sequence_features,A `dict` mapping feature keys to`FixedLenSequenceFeature` or `VarLenFeature` or `RaggedFeature` values. These features are associated with data within the `FeatureList` section of the `SequenceExample` proto.,A D_STRUCTURE mapping feature keys to QSTR values,,,D_STRUCTURE,,,,
tf.io.parse_single_sequence_example,sequence_features,A `dict` mapping feature keys to`FixedLenSequenceFeature` or `VarLenFeature` or `RaggedFeature` values. These features are associated with data within the `FeatureList` section of the `SequenceExample` proto.,These features are associated with data within the QSTR section of the QSTR proto,,,D_STRUCTURE,,,,
tf.io.parse_single_sequence_example,sequence_features,DF: None,DEFAULT None,,,D_STRUCTURE,,,,
tf.signal.hann_window,name,An optional name for the operation.,An optional name for the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.hann_window,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.minimum,y,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.train.list_variables,ckpt_dir_or_file,Directory with checkpoints file or path to checkpoint.,Directory with checkpoints file or path to checkpoint,D_TYPE,,,,,,
tf.image.crop_to_bounding_box,offset_width,Horizontal coordinate of the top-left corner of the result in the input.,Horizontal coordinate of the top left corner of the result in the input,D_TYPE,,,,,"[0,inf)",
tf.image.extract_patches,sizes,"The size of the extracted patches. Must be [1, size_rows, size_cols, 1].",The size of the extracted patches,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.image.extract_patches,sizes,"The size of the extracted patches. Must be [1, size_rows, size_cols, 1].",Must be BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.data.experimental.dense_to_ragged_batch,drop_remainder,"(Optional.) A `tf.bool` scalar `tf.Tensor`, representing whether the last batch should be dropped in the case it has fewer than`batch_size` elements; the default behavior is not to drop the smaller batch.",ONE_WORD BSTR,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.data.experimental.dense_to_ragged_batch,drop_remainder,"(Optional.) A `tf.bool` scalar `tf.Tensor`, representing whether the last batch should be dropped in the case it has fewer than`batch_size` elements; the default behavior is not to drop the smaller batch.",A D_TYPE scalar D_STRUCTURE representing whether the last batch should be dropped in the case it has fewer than PARAM elements the default behavior is not to drop the smaller batch,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.data.experimental.dense_to_ragged_batch,drop_remainder,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.utils.get_file,file_hash,The expected hash string of the file after download. The sha256 and md5 hash algorithms are both supported.,The expected hash D_TYPE of the file after download,,,,,,,
tf.keras.utils.get_file,file_hash,The expected hash string of the file after download. The sha256 and md5 hash algorithms are both supported.,The sha256 and md5 hash algorithms are both supported,,,,,,,
tf.keras.utils.get_file,file_hash,DF: None,DEFAULT None,,,,,,,
tf.autograph.trace,*args,Arguments to print to `sys.stdout`.,Arguments to print to sys stdout,,,,,,,
tf.keras.Input,batch_size,optional static batch size (integer).,optional static batch size BSTR,D_TYPE,,,,,"[0,inf)",
tf.keras.Input,batch_size,DF: None,DEFAULT None,D_TYPE,,,,,"[0,inf)",
tf.sets.difference,b,"`Tensor` or `SparseTensor` of the same type as `a`. If sparse, indices must be sorted in row-major order.",D_STRUCTURE of the same type as QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.sets.difference,b,"`Tensor` or `SparseTensor` of the same type as `a`. If sparse, indices must be sorted in row-major order.",If sparse indices must be sorted in row major order,D_TYPE,D_STRUCTURE,,,,,
tf.estimator.experimental.stop_if_lower_hook,run_every_steps,"If specified, calls `should_stop_fn` every`run_every_steps` steps. Either this or `run_every_secs` must be set.",If specified calls QSTR every QSTR steps,,,,,,,
tf.estimator.experimental.stop_if_lower_hook,run_every_steps,"If specified, calls `should_stop_fn` every`run_every_steps` steps. Either this or `run_every_secs` must be set.",Either this or PARAM must be set,,,,,,,
tf.estimator.experimental.stop_if_lower_hook,run_every_steps,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.local_conv2d,data_format,"the data format, channels_first or channels_last.",the data format channels_first or channels_last,,,,,,,
tf.keras.backend.local_conv2d,data_format,DF: None,DEFAULT None,,,,,,,
tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient,max,A `Tensor` of type `float32`.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.sparse.split,num_split,A Python integer. The number of ways to split.,A Python D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.sparse.split,num_split,A Python integer. The number of ways to split.,The number of ways to split,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.sparse.split,num_split,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.random.fixed_unigram_candidate_sampler,vocab_file,"Each valid line in this file (which should have a CSV-like format) corresponds to a valid word ID. IDs are in sequential order, starting from num_reserved_ids. The last entry in each line is expected to be a value corresponding to the count or relative probability. Exactly one of `vocab_file` and `unigrams` needs to be passed to this operation.",Each valid line in this file BSTR corresponds to a valid word ID,D_TYPE,,,,,,QSTR
tf.random.fixed_unigram_candidate_sampler,vocab_file,"Each valid line in this file (which should have a CSV-like format) corresponds to a valid word ID. IDs are in sequential order, starting from num_reserved_ids. The last entry in each line is expected to be a value corresponding to the count or relative probability. Exactly one of `vocab_file` and `unigrams` needs to be passed to this operation.",IDs are in sequential order starting from PARAM,D_TYPE,,,,,,QSTR
tf.random.fixed_unigram_candidate_sampler,vocab_file,"Each valid line in this file (which should have a CSV-like format) corresponds to a valid word ID. IDs are in sequential order, starting from num_reserved_ids. The last entry in each line is expected to be a value corresponding to the count or relative probability. Exactly one of `vocab_file` and `unigrams` needs to be passed to this operation.",The last entry in each line is expected to be a value corresponding to the count or relative probability,D_TYPE,,,,,,QSTR
tf.random.fixed_unigram_candidate_sampler,vocab_file,"Each valid line in this file (which should have a CSV-like format) corresponds to a valid word ID. IDs are in sequential order, starting from num_reserved_ids. The last entry in each line is expected to be a value corresponding to the count or relative probability. Exactly one of `vocab_file` and `unigrams` needs to be passed to this operation.",Exactly one of QSTR and PARAM needs to be passed to this operation,D_TYPE,,,,,,QSTR
tf.random.fixed_unigram_candidate_sampler,vocab_file,DF: ,,D_TYPE,,,,,,QSTR
tf.keras.layers.SimpleRNN,use_bias,"Boolean, (default `True`), whether the layer uses a bias vector.",D_TYPE default CONSTANT_BOOL whether the layer uses a bias vector,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNN,use_bias,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.unstack,num,An `int`. The length of the dimension `axis`. Automatically inferred if`None` (the default).,An D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.unstack,num,An `int`. The length of the dimension `axis`. Automatically inferred if`None` (the default).,The length of the dimension PARAM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.unstack,num,An `int`. The length of the dimension `axis`. Automatically inferred if`None` (the default).,Automatically inferred if QSTR BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.unstack,num,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.preprocessing.image.random_shift,hrg,"Height shift range, as a float fraction of the height.",Height shift range as a D_TYPE fraction of the height,D_TYPE,,,,CONSTANT_VAL,,
tf.rank,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.rank,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,beta,An optional `float`. Defaults to `0.5`. An exponent.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,beta,An optional `float`. Defaults to `0.5`. An exponent.,Defaults to CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,beta,An optional `float`. Defaults to `0.5`. An exponent.,An exponent,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,beta,DF: 0.5,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.utils.plot_model,expand_nested,Whether to expand nested models into clusters.,Whether to expand nested models into clusters,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.utils.plot_model,expand_nested,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_shapes,shapes,dictionary with (`Tensor` to shape) items. A shape must be an iterable.,D_STRUCTURE with BSTR items,,,D_STRUCTURE,,,,
tf.debugging.assert_shapes,shapes,dictionary with (`Tensor` to shape) items. A shape must be an iterable.,A shape must be an D_STRUCTURE,,,D_STRUCTURE,,,,
tf.nn.sampled_softmax_loss,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,name,DF: sampled_softmax_loss,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_compressed,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_compressed,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Layer,**kwargs,Additional keyword arguments.,Additional keyword arguments,,,,,,,
tf.image.non_max_suppression_padded,max_output_size,A scalar integer `Tensor` representing the maximum number of boxes to be selected by non max suppression.,A scalar D_TYPE D_STRUCTURE representing the maximum number of PARAM to be selected by non max suppression,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.nn.conv1d_transpose,filters,"A 3-D `Tensor` with the same type as `value` and shape`[filter_width, output_channels, in_channels]`.  `filter`'s`in_channels` dimension must match that of `value`.",A CONSTANT_NUM D D_STRUCTURE with the same type as QSTR and shape BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.conv1d_transpose,filters,"A 3-D `Tensor` with the same type as `value` and shape`[filter_width, output_channels, in_channels]`.  `filter`'s`in_channels` dimension must match that of `value`.",QSTR s QSTR dimension must match that of QSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.keras.backend.prod,x,A tensor or variable.,A D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.linalg.trace,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.trace,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.tile,n,A list of integer. The length must be the same as the number of dimensions in `x`.,A D_STRUCTURE of D_TYPE,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.tile,n,A list of integer. The length must be the same as the number of dimensions in `x`.,The length must be the same as the number of dimensions in QSTR,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.nn.selu,features,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.nn.selu,features,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.function,experimental_implements,"If provided, contains a name of a ""known"" function this implements. For example ""mycompany.my_recurrent_cell"". This is stored as an attribute in inference function, which can then be detected when processing serialized function. Seehttps://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.mdfor details.  For an example of utilizing this attribute see:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.ccThe code above automatically detects and substitutes function that implements ""embedded_matmul"" and allows TFLite to substitute its own implementations. For instance, a tensorflow user can use this attribute to mark that their function also implements`embedded_matmul``` (perhaps more efficiently!) by specifying it using this flag.",If provided contains a name of a QSTR function this implements,,,,,,,
tf.function,experimental_implements,"If provided, contains a name of a ""known"" function this implements. For example ""mycompany.my_recurrent_cell"". This is stored as an attribute in inference function, which can then be detected when processing serialized function. Seehttps://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.mdfor details.  For an example of utilizing this attribute see:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.ccThe code above automatically detects and substitutes function that implements ""embedded_matmul"" and allows TFLite to substitute its own implementations. For instance, a tensorflow user can use this attribute to mark that their function also implements`embedded_matmul``` (perhaps more efficiently!) by specifying it using this flag.",For example mycompany my_recurrent_cell,,,,,,,
tf.function,experimental_implements,"If provided, contains a name of a ""known"" function this implements. For example ""mycompany.my_recurrent_cell"". This is stored as an attribute in inference function, which can then be detected when processing serialized function. Seehttps://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.mdfor details.  For an example of utilizing this attribute see:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.ccThe code above automatically detects and substitutes function that implements ""embedded_matmul"" and allows TFLite to substitute its own implementations. For instance, a tensorflow user can use this attribute to mark that their function also implements`embedded_matmul``` (perhaps more efficiently!) by specifying it using this flag.",This is stored as an attribute in inference function which can then be detected when processing serialized function,,,,,,,
tf.function,experimental_implements,"If provided, contains a name of a ""known"" function this implements. For example ""mycompany.my_recurrent_cell"". This is stored as an attribute in inference function, which can then be detected when processing serialized function. Seehttps://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.mdfor details.  For an example of utilizing this attribute see:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.ccThe code above automatically detects and substitutes function that implements ""embedded_matmul"" and allows TFLite to substitute its own implementations. For instance, a tensorflow user can use this attribute to mark that their function also implements`embedded_matmul``` (perhaps more efficiently!) by specifying it using this flag.",Seehttps github com tensorflow community blob master rfcs CONSTANT_NUM standardizing composite_ops mdfor details,,,,,,,
tf.function,experimental_implements,"If provided, contains a name of a ""known"" function this implements. For example ""mycompany.my_recurrent_cell"". This is stored as an attribute in inference function, which can then be detected when processing serialized function. Seehttps://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.mdfor details.  For an example of utilizing this attribute see:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.ccThe code above automatically detects and substitutes function that implements ""embedded_matmul"" and allows TFLite to substitute its own implementations. For instance, a tensorflow user can use this attribute to mark that their function also implements`embedded_matmul``` (perhaps more efficiently!) by specifying it using this flag.",For an example of utilizing this attribute see https github com tensorflow tensorflow blob master tensorflow compiler mlir lite transforms prepare_composite_functions_tf ccThe code above automatically detects and substitutes function that implements QSTR and allows TFLite to substitute its own implementations,,,,,,,
tf.function,experimental_implements,"If provided, contains a name of a ""known"" function this implements. For example ""mycompany.my_recurrent_cell"". This is stored as an attribute in inference function, which can then be detected when processing serialized function. Seehttps://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.mdfor details.  For an example of utilizing this attribute see:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.ccThe code above automatically detects and substitutes function that implements ""embedded_matmul"" and allows TFLite to substitute its own implementations. For instance, a tensorflow user can use this attribute to mark that their function also implements`embedded_matmul``` (perhaps more efficiently!) by specifying it using this flag.",For instance a tensorflow user can use this attribute to mark that their function also implements QSTR perhaps more efficiently,,,,,,,
tf.function,experimental_implements,"If provided, contains a name of a ""known"" function this implements. For example ""mycompany.my_recurrent_cell"". This is stored as an attribute in inference function, which can then be detected when processing serialized function. Seehttps://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.mdfor details.  For an example of utilizing this attribute see:https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.ccThe code above automatically detects and substitutes function that implements ""embedded_matmul"" and allows TFLite to substitute its own implementations. For instance, a tensorflow user can use this attribute to mark that their function also implements`embedded_matmul``` (perhaps more efficiently!) by specifying it using this flag.",by specifying it using this flag,,,,,,,
tf.function,experimental_implements,DF: None,DEFAULT None,,,,,,,
tf.config.set_logical_device_configuration,logical_devices,"(optional) List of `tf.config.LogicalDeviceConfiguration`objects to allocate for the specified `PhysicalDevice`. If None, the default configuration will be used.",BSTR D_STRUCTURE of tf config LogicalDeviceConfiguration QSTR PhysicalDevice,,,D_STRUCTURE,,,,
tf.config.set_logical_device_configuration,logical_devices,"(optional) List of `tf.config.LogicalDeviceConfiguration`objects to allocate for the specified `PhysicalDevice`. If None, the default configuration will be used.",If None the default configuration will be used,,,D_STRUCTURE,,,,
tf.math.top_k,name,Optional name for the operation.,Optional name for the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.math.top_k,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.compat.forward_compatibility_horizon,day,"A day (1 <= day <= 31, or 30, or 29, or 28) in month. Must be an`int`.",A day CONSTANT_NUM REXPR REXPR or CONSTANT_NUM in PARAM,,,,,,,
tf.compat.forward_compatibility_horizon,day,"A day (1 <= day <= 31, or 30, or 29, or 28) in month. Must be an`int`.",Must be anD_TYPE,,,,,,,
tf.feature_column.make_parse_example_spec,feature_columns,An iterable containing all feature columns. All items should be instances of classes derived from `FeatureColumn`.,An D_STRUCTURE containing all feature columns,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.feature_column.make_parse_example_spec,feature_columns,An iterable containing all feature columns. All items should be instances of classes derived from `FeatureColumn`.,All items should be instances of classes derived from QSTR,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.backend.var,x,A tensor or variable.,A D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.keras.backend.clip,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.keras.layers.LSTM,bias_regularizer,Regularizer function applied to the bias vector. Default:`None`.,Regularizer function applied to the bias vector,,,,,,,
tf.keras.layers.LSTM,bias_regularizer,Regularizer function applied to the bias vector. Default:`None`.,Default QSTR,,,,,,,
tf.keras.layers.LSTM,bias_regularizer,DF: None,DEFAULT None,,,,,,,
tf.is_tensor,x,A python object to check.,A python object to check,,,,,,,
tf.keras.layers.Softmax,axis,"Integer, axis along which the softmax normalization is applied.",D_TYPE axis along which the softmax normalization is applied,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Softmax,axis,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.nondifferentiable_batch_function,batch_timeout_micros,Maximum number of microseconds to wait before outputting an incomplete batch.,Maximum number of microseconds to wait before outputting an incomplete batch,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.compat.dimension_value,dimension,"Either a `Dimension` instance, an integer, or None.",Either a QSTR instance an D_TYPE or None,D_TYPE,,,,,,
tf.linspace,num,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 0-D tensor. Number of values to generate.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.linspace,num,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 0-D tensor. Number of values to generate.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.linspace,num,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 0-D tensor. Number of values to generate.",CONSTANT_NUM D D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.linspace,num,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 0-D tensor. Number of values to generate.",Number of values to generate,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.math.is_finite,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.is_finite,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.categorical_column_with_identity,key,"A unique string identifying the input feature. It is used as the column name and the dictionary key for feature parsing configs, feature`Tensor` objects, and feature columns.",A unique D_TYPE identifying the input feature,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.categorical_column_with_identity,key,"A unique string identifying the input feature. It is used as the column name and the dictionary key for feature parsing configs, feature`Tensor` objects, and feature columns.",It is used as the column name and the D_STRUCTURE key for feature parsing configs featureD_STRUCTURE objects and feature columns,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",A D_TYPE one of QSTR BSTR or QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.Conv2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",The ordering of the dimensions in the inputs QSTR corresponds to inputs with shape BSTR while QSTR corresponds to inputs with shape BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.Conv2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",It defaults to the QSTR value found in your Keras config file at keras keras json,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.Conv2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",If you never set it then it will be QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.Conv2D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.strings.ngrams,data,A Tensor or RaggedTensor containing the source data for the ngrams.,A D_STRUCTURE or RaggedTensor containing the source data for the ngrams,,D_STRUCTURE,,,,,
tf.math.cumprod,x,"A `Tensor`. Must be one of the following types: `float32`, `float64`,`int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,`complex128`, `qint8`, `quint8`, `qint32`, `half`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.cumprod,x,"A `Tensor`. Must be one of the following types: `float32`, `float64`,`int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,`complex128`, `qint8`, `quint8`, `qint32`, `half`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.keras.layers.LSTM,stateful,"Boolean (default `False`). If True, the last state for each sample at index i in a batch will be used as initial state for the sample of index i in the following batch.",D_TYPE default CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTM,stateful,"Boolean (default `False`). If True, the last state for each sample at index i in a batch will be used as initial state for the sample of index i in the following batch.",If CONSTANT_BOOL the last state for each sample at index i in a batch will be used as initial state for the sample of index i in the following batch,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTM,stateful,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.sequence.pad_sequences,padding,"String, 'pre' or 'post':     pad either before or after each sequence.",D_TYPE QSTR pad either before or after each D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.preprocessing.sequence.pad_sequences,padding,DF: pre,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.reshape,name,Optional string. A name for the operation.,Optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.reshape,name,Optional string. A name for the operation.,A name for the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.reshape,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.int_shape,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.keras.backend.conv2d_transpose,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.nn.nce_loss,weights,"A `Tensor` of shape `[num_classes, dim]`, or a list of `Tensor`objects whose concatenation along dimension 0 has shape [num_classes, dim].  The (possibly-partitioned) class embeddings.",A D_STRUCTURE of shape BSTR or a D_STRUCTURE of D_STRUCTUREobjects whose concatenation along dimension CONSTANT_NUM has shape BSTR,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.nce_loss,weights,"A `Tensor` of shape `[num_classes, dim]`, or a list of `Tensor`objects whose concatenation along dimension 0 has shape [num_classes, dim].  The (possibly-partitioned) class embeddings.",The BSTR class embeddings,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.random.normal,stddev,"A Tensor or Python value of type `dtype`, broadcastable with `mean`. The standard deviation of the normal distribution.",A D_STRUCTURE or Python value of type PARAM broadcastable with PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.random.normal,stddev,"A Tensor or Python value of type `dtype`, broadcastable with `mean`. The standard deviation of the normal distribution.",The standard deviation of the normal distribution,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.random.normal,stddev,DF: 1.0,DEFAULT CONSTANT_FLOAT,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.saved_model.save,export_dir,A directory in which to write the SavedModel.,A directory in which to write the SavedModel,D_TYPE,,,,,,
tf.shape,out_type,(Optional) The specified output type of the operation (`int32` or`int64`). Defaults to `tf.int32`.,ONE_WORD BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.shape,out_type,(Optional) The specified output type of the operation (`int32` or`int64`). Defaults to `tf.int32`.,Defaults to D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.shape,out_type,DF: tf.dtypes.int32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.audio.decode_wav,desired_channels,An optional `int`. Defaults to `-1`. Number of sample channels wanted.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.audio.decode_wav,desired_channels,An optional `int`. Defaults to `-1`. Number of sample channels wanted.,Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.audio.decode_wav,desired_channels,An optional `int`. Defaults to `-1`. Number of sample channels wanted.,Number of sample channels wanted,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.audio.decode_wav,desired_channels,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.debugging.assert_type,name,"A name for this operation. Defaults to ""assert_type""",A name for this operation,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_type,name,"A name for this operation. Defaults to ""assert_type""",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_type,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.eye,num_columns,Optional non-negative `int32` scalar `Tensor` giving the number of columns in each batch matrix.  Defaults to `num_rows`.,Optional non negative D_TYPE scalar D_STRUCTURE giving the number of columns in each batch matrix,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.eye,num_columns,Optional non-negative `int32` scalar `Tensor` giving the number of columns in each batch matrix.  Defaults to `num_rows`.,Defaults to PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.eye,num_columns,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.foldr,name,A string name for the foldr node in the graph,A D_TYPE name for the foldr node in the graph,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.foldr,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Embedding,embeddings_constraint,Constraint function applied to the `embeddings` matrix.,Constraint function applied to the QSTR matrix,,,,,,,
tf.keras.layers.Embedding,embeddings_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.foldl,name,A string name for the foldl node in the graph,A D_TYPE name for the foldl node in the graph,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.foldl,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.less_equal,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.math.betainc,a,"A `Tensor`. Must be one of the following types: `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.betainc,a,"A `Tensor`. Must be one of the following types: `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.image.crop_to_bounding_box,offset_height,Vertical coordinate of the top-left corner of the result in the input.,Vertical coordinate of the top left corner of the result in the input,D_TYPE,,,,,"[0,inf)",
tf.linalg.tridiagonal_solve,diagonals,"A `Tensor` or tuple of `Tensor`s describing left-hand sides. The shape depends of `diagonals_format`, see description above. Must be`float32`, `float64`, `complex64`, or `complex128`.",A D_STRUCTURE of D_STRUCTUREs describing left hand sides,D_TYPE,D_STRUCTURE,D_STRUCTURE,,,,
tf.linalg.tridiagonal_solve,diagonals,"A `Tensor` or tuple of `Tensor`s describing left-hand sides. The shape depends of `diagonals_format`, see description above. Must be`float32`, `float64`, `complex64`, or `complex128`.",The shape depends of PARAM see description above,D_TYPE,D_STRUCTURE,D_STRUCTURE,,,,
tf.linalg.tridiagonal_solve,diagonals,"A `Tensor` or tuple of `Tensor`s describing left-hand sides. The shape depends of `diagonals_format`, see description above. Must be`float32`, `float64`, `complex64`, or `complex128`.",Must beD_TYPE,D_TYPE,D_STRUCTURE,D_STRUCTURE,,,,
tf.keras.layers.ConvLSTM2D,unit_forget_bias,"Boolean. If True, add 1 to the bias of the forget gate at initialization. Use in combination with `bias_initializer=""zeros""`. This is recommended in Jozefowicz et al.",ONE_WORD D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ConvLSTM2D,unit_forget_bias,"Boolean. If True, add 1 to the bias of the forget gate at initialization. Use in combination with `bias_initializer=""zeros""`. This is recommended in Jozefowicz et al.",If CONSTANT_BOOL add CONSTANT_NUM to the bias of the forget gate at initialization,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ConvLSTM2D,unit_forget_bias,"Boolean. If True, add 1 to the bias of the forget gate at initialization. Use in combination with `bias_initializer=""zeros""`. This is recommended in Jozefowicz et al.",Use in combination with PARAM QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ConvLSTM2D,unit_forget_bias,"Boolean. If True, add 1 to the bias of the forget gate at initialization. Use in combination with `bias_initializer=""zeros""`. This is recommended in Jozefowicz et al.",This is recommended in Jozefowicz et al,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ConvLSTM2D,unit_forget_bias,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.unicode_transcode,input_encoding,"A `string`. Text encoding of the input strings. This is any of the encodings supported by ICU ucnv algorithmic converters. Examples: `""UTF-16"", ""US ASCII"", ""UTF-8""`.",A D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.unicode_transcode,input_encoding,"A `string`. Text encoding of the input strings. This is any of the encodings supported by ICU ucnv algorithmic converters. Examples: `""UTF-16"", ""US ASCII"", ""UTF-8""`.",Text encoding of the PARAM D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.unicode_transcode,input_encoding,"A `string`. Text encoding of the input strings. This is any of the encodings supported by ICU ucnv algorithmic converters. Examples: `""UTF-16"", ""US ASCII"", ""UTF-8""`.",This is any of the encodings supported by ICU ucnv algorithmic converters,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.unicode_transcode,input_encoding,"A `string`. Text encoding of the input strings. This is any of the encodings supported by ICU ucnv algorithmic converters. Examples: `""UTF-16"", ""US ASCII"", ""UTF-8""`.",Examples UTF CONSTANT_NUM QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.gradients,ys,A `Tensor` or list of tensors to be differentiated.,A D_STRUCTURE of D_STRUCTURE to be differentiated,,D_STRUCTURE,D_STRUCTURE,,,,
tf.summary.write,metadata,"Optional SummaryMetadata, as a proto or serialized bytes",Optional SummaryMetadata as a proto or serialized bytes,,,,,,,
tf.summary.write,metadata,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.ConvLSTM2D,bias_constraint,Constraint function applied to the bias vector.,Constraint function applied to the bias vector,,,,,,,
tf.keras.layers.ConvLSTM2D,bias_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.concatenate,tensors,list of tensors to concatenate.,D_STRUCTURE of D_STRUCTURE to concatenate,,D_STRUCTURE,D_STRUCTURE,,,,
tf.math.greater,y,A `Tensor`. Must have the same type as `x`.,A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.greater,y,A `Tensor`. Must have the same type as `x`.,Must have the same type as QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.assert_rank_at_least,name,"A name for this operation (optional).  Defaults to ""assert_rank_at_least"".",A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_rank_at_least,name,"A name for this operation (optional).  Defaults to ""assert_rank_at_least"".",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_rank_at_least,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,reset_after,"GRU convention (whether to apply reset gate after or before matrix multiplication). False = ""before"", True = ""after"" (default and CuDNN compatible).",GRU convention BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,reset_after,"GRU convention (whether to apply reset gate after or before matrix multiplication). False = ""before"", True = ""after"" (default and CuDNN compatible).",CONSTANT_BOOL QSTR CONSTANT_BOOL QSTR BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,reset_after,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv2D,activity_regularizer,"Regularizer function applied to the output of the layer (its ""activation"")..",Regularizer function applied to the output of the layer BSTR,,,,,,,
tf.keras.layers.Conv2D,activity_regularizer,DF: None,DEFAULT None,,,,,,,
tf.keras.activations.linear,x,Input tensor.,Input D_STRUCTURE,,D_STRUCTURE,,,,,
tf.keras.preprocessing.text.hashing_trick,lower,boolean. Whether to set the text to lowercase.,ONE_WORD D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.text.hashing_trick,lower,boolean. Whether to set the text to lowercase.,Whether to set the PARAM to lowercase,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.text.hashing_trick,lower,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.sequence.skipgrams,vocabulary_size,"Int, maximum possible word index + 1",D_TYPE maximum possible word index CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.LocallyConnected2D,bias_initializer,Initializer for the bias vector.,Initializer for the bias vector,D_TYPE,,,,,,
tf.keras.layers.LocallyConnected2D,bias_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.nn.with_space_to_batch,op,"Function that maps (input, num_spatial_dims, padding) -> output",Function that maps BSTR REXPR,,,,,,,
tf.eig,tensor,"`Tensor` of shape `[..., N, N]`. Only the lower triangular part of each inner inner matrix is referenced.",D_STRUCTURE of shape BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.eig,tensor,"`Tensor` of shape `[..., N, N]`. Only the lower triangular part of each inner inner matrix is referenced.",Only the lower triangular part of each inner inner matrix is referenced,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.keras.preprocessing.image.apply_affine_transform,tx,Width shift.,Width shift,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.apply_affine_transform,tx,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.sqrt,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.keras.layers.Conv3D,bias_regularizer,Regularizer function applied to the bias vector.,Regularizer function applied to the bias vector,,,,,,,
tf.keras.layers.Conv3D,bias_regularizer,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.truncated_normal,stddev,Standard deviation of the values.,Standard deviation of the values,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.truncated_normal,stddev,DF: 1.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.binary_crossentropy,target,A tensor with the same shape as `output`.,A D_STRUCTURE with the same shape as PARAM,,D_STRUCTURE,,BSTR,,,
tf.summary.audio,description,"Optional long-form description for this summary, as a constant `str`. Markdown is supported. Defaults to empty.",Optional long form description for this summary as a constant D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.audio,description,"Optional long-form description for this summary, as a constant `str`. Markdown is supported. Defaults to empty.",Markdown is supported,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.audio,description,"Optional long-form description for this summary, as a constant `str`. Markdown is supported. Defaults to empty.",Defaults to empty,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.audio,description,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.gather,reference,A tensor.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.math.real,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.real,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.unsorted_segment_sqrt_n,data,A `Tensor` with floating point or complex dtype.,A D_STRUCTURE with D_TYPE point or D_TYPE dtype,D_TYPE,D_STRUCTURE,,,,,
tf.nn.sparse_softmax_cross_entropy_with_logits,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sparse_softmax_cross_entropy_with_logits,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.reverse,axes,Integer or iterable of integers. Axes to reverse.,D_TYPE or D_STRUCTURE of D_TYPE,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.backend.reverse,axes,Integer or iterable of integers. Axes to reverse.,Axes to reverse,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.one_hot,off_value,A scalar defining the value to fill in output when `indices[j] != i`. (default: 0),A scalar defining the value to fill in output when PARAM BSTR i,D_TYPE,,,,CONSTANT_VAL,,
tf.one_hot,off_value,A scalar defining the value to fill in output when `indices[j] != i`. (default: 0),default CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.one_hot,off_value,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv2DTranspose,output_padding,"An integer or tuple/list of 2 integers, specifying the amount of padding along the height and width of the output tensor. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to `None` (default), the output shape is inferred.",An D_TYPE or D_STRUCTURE of CONSTANT_NUM D_TYPE specifying the amount of PARAM along the height and width of the output D_STRUCTURE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.Conv2DTranspose,output_padding,"An integer or tuple/list of 2 integers, specifying the amount of padding along the height and width of the output tensor. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to `None` (default), the output shape is inferred.",Can be a single D_TYPE to specify the same value for all spatial dimensions,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.Conv2DTranspose,output_padding,"An integer or tuple/list of 2 integers, specifying the amount of padding along the height and width of the output tensor. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to `None` (default), the output shape is inferred.",The amount of output PARAM along a given dimension must be lower than the stride along that same dimension,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.Conv2DTranspose,output_padding,"An integer or tuple/list of 2 integers, specifying the amount of padding along the height and width of the output tensor. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to `None` (default), the output shape is inferred.",If set to QSTR BSTR the output shape is inferred,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.Conv2DTranspose,output_padding,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.Cropping2D,cropping,"Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints. If int: the same symmetric cropping is applied to height and width.If tuple of 2 ints: interpreted as two different symmetric cropping values for height and width:`(symmetric_height_crop, symmetric_width_crop)`.If tuple of 2 tuples of 2 ints: interpreted as`((top_crop, bottom_crop), (left_crop, right_crop))` ",D_TYPE or D_STRUCTURE of CONSTANT_NUM D_TYPE or D_STRUCTURE of CONSTANT_NUM tuples of CONSTANT_NUM D_TYPE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Cropping2D,cropping,"Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints. If int: the same symmetric cropping is applied to height and width.If tuple of 2 ints: interpreted as two different symmetric cropping values for height and width:`(symmetric_height_crop, symmetric_width_crop)`.If tuple of 2 tuples of 2 ints: interpreted as`((top_crop, bottom_crop), (left_crop, right_crop))` ",If D_TYPE the same symmetric cropping is applied to height and width If D_STRUCTURE of CONSTANT_NUM D_TYPE interpreted as two different symmetric cropping values for height and width BSTR If D_STRUCTURE of CONSTANT_NUM tuples of CONSTANT_NUM D_TYPE interpreted as BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Cropping2D,cropping,"DF: ((0, 0), (0, 0))",DEFAULT BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.sparse.reshape,name,A name prefix for the returned tensors (optional),A name prefix for the returned D_STRUCTURE BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.reshape,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.local_response_normalization,depth_radius,An optional `int`. Defaults to `5`. 0-D.  Half-width of the 1-D normalization window.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.nn.local_response_normalization,depth_radius,An optional `int`. Defaults to `5`. 0-D.  Half-width of the 1-D normalization window.,Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.nn.local_response_normalization,depth_radius,An optional `int`. Defaults to `5`. 0-D.  Half-width of the 1-D normalization window.,CONSTANT_NUM D D_TYPE width of the CONSTANT_NUM D normalization window,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.nn.local_response_normalization,depth_radius,DF: 5,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.data.experimental.make_csv_dataset,shuffle_buffer_size,"Buffer size to use for shuffling. A large buffer size ensures better shuffling, but increases memory usage and startup time.",Buffer size to use for shuffling,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.data.experimental.make_csv_dataset,shuffle_buffer_size,"Buffer size to use for shuffling. A large buffer size ensures better shuffling, but increases memory usage and startup time.",A large buffer size ensures better shuffling but increases memory usage and startup time,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.data.experimental.make_csv_dataset,shuffle_buffer_size,DF: 10000,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.ActivityRegularization,l1,L1 regularization factor (positive float).,L1 regularization factor BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ActivityRegularization,l1,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.rnn,step_function,"RNN step function. Args;     input; Tensor with shape `(samples, ...)` (no time dimension),         representing input for the batch of samples at a certain         time step.     states; List of tensors. Returns;     output; Tensor with shape `(samples, output_dim)`        (no time dimension).     new_states; List of tensors, same length and shapes         as 'states'. The first state in the list must be the         output tensor at the previous timestep.",RNN step function,,,,,,,
tf.keras.backend.rnn,step_function,"RNN step function. Args;     input; Tensor with shape `(samples, ...)` (no time dimension),         representing input for the batch of samples at a certain         time step.     states; List of tensors. Returns;     output; Tensor with shape `(samples, output_dim)`        (no time dimension).     new_states; List of tensors, same length and shapes         as 'states'. The first state in the list must be the         output tensor at the previous timestep.",Args input D_STRUCTURE with shape BSTR BSTR representing input for the batch of samples at a certain time step,,,,,,,
tf.keras.backend.rnn,step_function,"RNN step function. Args;     input; Tensor with shape `(samples, ...)` (no time dimension),         representing input for the batch of samples at a certain         time step.     states; List of tensors. Returns;     output; Tensor with shape `(samples, output_dim)`        (no time dimension).     new_states; List of tensors, same length and shapes         as 'states'. The first state in the list must be the         output tensor at the previous timestep.",states D_STRUCTURE of D_STRUCTURE,,,,,,,
tf.keras.backend.rnn,step_function,"RNN step function. Args;     input; Tensor with shape `(samples, ...)` (no time dimension),         representing input for the batch of samples at a certain         time step.     states; List of tensors. Returns;     output; Tensor with shape `(samples, output_dim)`        (no time dimension).     new_states; List of tensors, same length and shapes         as 'states'. The first state in the list must be the         output tensor at the previous timestep.",Returns output D_STRUCTURE with shape BSTR BSTR,,,,,,,
tf.keras.backend.rnn,step_function,"RNN step function. Args;     input; Tensor with shape `(samples, ...)` (no time dimension),         representing input for the batch of samples at a certain         time step.     states; List of tensors. Returns;     output; Tensor with shape `(samples, output_dim)`        (no time dimension).     new_states; List of tensors, same length and shapes         as 'states'. The first state in the list must be the         output tensor at the previous timestep.",new_states D_STRUCTURE of D_STRUCTURE same length and shapes as QSTR,,,,,,,
tf.keras.backend.rnn,step_function,"RNN step function. Args;     input; Tensor with shape `(samples, ...)` (no time dimension),         representing input for the batch of samples at a certain         time step.     states; List of tensors. Returns;     output; Tensor with shape `(samples, output_dim)`        (no time dimension).     new_states; List of tensors, same length and shapes         as 'states'. The first state in the list must be the         output tensor at the previous timestep.",The first state in the D_STRUCTURE must be the output D_STRUCTURE at the previous timestep,,,,,,,
tf.io.decode_bmp,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_bmp,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient,num_bits,"An optional `int`. Defaults to `8`. The bitwidth of the quantization; between 2 and 16, inclusive.",An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient,num_bits,"An optional `int`. Defaults to `8`. The bitwidth of the quantization; between 2 and 16, inclusive.",Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient,num_bits,"An optional `int`. Defaults to `8`. The bitwidth of the quantization; between 2 and 16, inclusive.",The bitwidth of the quantization between CONSTANT_NUM inclusive,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient,num_bits,DF: 8,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.hard_sigmoid,x,A tensor or variable.,A D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.register_tensor_conversion_function,base_type,The base type or tuple of base types for all objects that`conversion_func` accepts.,The base type or D_STRUCTURE of base types for all objects that PARAM accepts,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.image.ssim_multiscale,img2,Second image batch. Must have the same rank as img1.,Second image batch,D_TYPE,,,,,,
tf.image.ssim_multiscale,img2,Second image batch. Must have the same rank as img1.,Must have the same rank as PARAM,D_TYPE,,,,,,
tf.keras.backend.ctc_decode,beam_width,if `greedy` is `false`: a beam search decoder will be used with a beam of this width.,if PARAM is CONSTANT_BOOL a beam search decoder will be used with a beam of this width,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.ctc_decode,beam_width,DF: 100,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.one_hot,depth,A scalar defining the depth of the one hot dimension.,A scalar defining the depth of the one hot dimension,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,biases,A `Tensor` of shape `[num_classes]`.  The class biases.,A D_STRUCTURE of shape BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,biases,A `Tensor` of shape `[num_classes]`.  The class biases.,The class biases,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.conv1d,stride,An int or list of `ints` that has length `1` or `3`.  The number of entries by which the filter is moved right at each step.,An D_TYPE or D_STRUCTURE of D_TYPE that has length CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.conv1d,stride,An int or list of `ints` that has length `1` or `3`.  The number of entries by which the filter is moved right at each step.,The number of entries by which the filter is moved right at each step,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.data.experimental.make_csv_dataset,select_columns,"An optional list of integer indices or string column names, that specifies a subset of columns of CSV data to select. If column names are provided, these must correspond to names provided in`column_names` or inferred from the file header lines. When this argument is specified, only a subset of CSV columns will be parsed and returned, corresponding to the columns specified. Using this results in faster parsing and lower memory usage. If both this and `column_defaults` are specified, these must have the same lengths, and `column_defaults` is assumed to be sorted in order of increasing column index.",An optional D_STRUCTURE of D_TYPE indices or D_TYPE column names that specifies a subset of columns of CSV data to select,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,select_columns,"An optional list of integer indices or string column names, that specifies a subset of columns of CSV data to select. If column names are provided, these must correspond to names provided in`column_names` or inferred from the file header lines. When this argument is specified, only a subset of CSV columns will be parsed and returned, corresponding to the columns specified. Using this results in faster parsing and lower memory usage. If both this and `column_defaults` are specified, these must have the same lengths, and `column_defaults` is assumed to be sorted in order of increasing column index.",If column names are provided these must correspond to names provided in PARAM or inferred from the file PARAM lines,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,select_columns,"An optional list of integer indices or string column names, that specifies a subset of columns of CSV data to select. If column names are provided, these must correspond to names provided in`column_names` or inferred from the file header lines. When this argument is specified, only a subset of CSV columns will be parsed and returned, corresponding to the columns specified. Using this results in faster parsing and lower memory usage. If both this and `column_defaults` are specified, these must have the same lengths, and `column_defaults` is assumed to be sorted in order of increasing column index.",When this argument is specified only a subset of CSV columns will be parsed and returned corresponding to the columns specified,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,select_columns,"An optional list of integer indices or string column names, that specifies a subset of columns of CSV data to select. If column names are provided, these must correspond to names provided in`column_names` or inferred from the file header lines. When this argument is specified, only a subset of CSV columns will be parsed and returned, corresponding to the columns specified. Using this results in faster parsing and lower memory usage. If both this and `column_defaults` are specified, these must have the same lengths, and `column_defaults` is assumed to be sorted in order of increasing column index.",Using this results in faster parsing and lower memory usage,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,select_columns,"An optional list of integer indices or string column names, that specifies a subset of columns of CSV data to select. If column names are provided, these must correspond to names provided in`column_names` or inferred from the file header lines. When this argument is specified, only a subset of CSV columns will be parsed and returned, corresponding to the columns specified. Using this results in faster parsing and lower memory usage. If both this and `column_defaults` are specified, these must have the same lengths, and `column_defaults` is assumed to be sorted in order of increasing column index.",If both this and PARAM are specified these must have the same lengths and PARAM is assumed to be sorted in order of increasing column index,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,select_columns,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.signal.hann_window,window_length,A scalar `Tensor` indicating the window length to generate.,A scalar D_STRUCTURE indicating the window length to generate,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.data.experimental.make_csv_dataset,shuffle_seed,Randomization seed to use for shuffling.,Randomization seed to use for shuffling,,,,,,,
tf.data.experimental.make_csv_dataset,shuffle_seed,DF: None,DEFAULT None,,,,,,,
tf.range,limit,"A 0-D `Tensor` (scalar). Upper limit of sequence, exclusive. If None, defaults to the value of `start` while the first entry of the range defaults to 0.",A CONSTANT_NUM D D_STRUCTURE BSTR,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.range,limit,"A 0-D `Tensor` (scalar). Upper limit of sequence, exclusive. If None, defaults to the value of `start` while the first entry of the range defaults to 0.",Upper limit of D_STRUCTURE exclusive,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.range,limit,"A 0-D `Tensor` (scalar). Upper limit of sequence, exclusive. If None, defaults to the value of `start` while the first entry of the range defaults to 0.",If None defaults to the value of PARAM while the first entry of the range defaults to CONSTANT_NUM,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.atan,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.atan,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.truncated_normal,seed,"Integer, random seed.",D_TYPE random seed,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.truncated_normal,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.all,keepdims,whether the drop or broadcast the reduction axes.,whether the drop or broadcast the reduction axes,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.all,keepdims,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.constant,dtype,"The type of elements for the returned `RaggedTensor`.  If not specified, then a default is chosen based on the scalar values in`pylist`.",The type of elements for the returned QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.constant,dtype,"The type of elements for the returned `RaggedTensor`.  If not specified, then a default is chosen based on the scalar values in`pylist`.",If not specified then a default is chosen based on the scalar values in PARAM,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.constant,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.log_poisson_loss,compute_full_loss,"whether to compute the full loss. If false, a constant term is dropped in favor of more efficient optimization.",whether to compute the full loss,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.log_poisson_loss,compute_full_loss,"whether to compute the full loss. If false, a constant term is dropped in favor of more efficient optimization.",If CONSTANT_BOOL a constant term is dropped in favor of more efficient optimization,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.log_poisson_loss,compute_full_loss,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.random.stateless_truncated_normal,shape,A 1-D integer Tensor or Python array. The shape of the output tensor.,A CONSTANT_NUM D D_TYPE D_STRUCTURE or Python D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.random.stateless_truncated_normal,shape,A 1-D integer Tensor or Python array. The shape of the output tensor.,The shape of the output D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.keras.preprocessing.sequence.skipgrams,window_size,"Int, size of sampling windows (technically half-window).     The window of a word `w_i` will be     `[i - window_size, i + window_size+1]`.",D_TYPE size of sampling windows BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.preprocessing.sequence.skipgrams,window_size,"Int, size of sampling windows (technically half-window).     The window of a word `w_i` will be     `[i - window_size, i + window_size+1]`.",The window of a word QSTR will be BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.preprocessing.sequence.skipgrams,window_size,DF: 4,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.required_space_to_batch_paddings,base_paddings,"Optional int32 Tensor of shape [N, 2].  Specifies the minimum amount of padding to use.  All elements must be >= 0.  If not specified, defaults to 0.",Optional D_TYPE D_STRUCTURE of shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.required_space_to_batch_paddings,base_paddings,"Optional int32 Tensor of shape [N, 2].  Specifies the minimum amount of padding to use.  All elements must be >= 0.  If not specified, defaults to 0.",Specifies the minimum amount of padding to use,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.required_space_to_batch_paddings,base_paddings,"Optional int32 Tensor of shape [N, 2].  Specifies the minimum amount of padding to use.  All elements must be >= 0.  If not specified, defaults to 0.",All elements must be REXPR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.required_space_to_batch_paddings,base_paddings,"Optional int32 Tensor of shape [N, 2].  Specifies the minimum amount of padding to use.  All elements must be >= 0.  If not specified, defaults to 0.",If not specified defaults to CONSTANT_NUM,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.required_space_to_batch_paddings,base_paddings,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.feature_column.shared_embeddings,shared_embedding_collection_name,"Optional collective name of these columns. If not given, a reasonable name will be chosen based on the names of`categorical_columns`.",Optional collective name of these columns,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.shared_embeddings,shared_embedding_collection_name,"Optional collective name of these columns. If not given, a reasonable name will be chosen based on the names of`categorical_columns`.",If not given a reasonable name will be chosen based on the names of PARAM,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.shared_embeddings,shared_embedding_collection_name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cumsum,exclusive,"If `True`, perform exclusive cumsum.",If CONSTANT_BOOL perform exclusive cumsum,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cumsum,exclusive,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.conv1d,dilation_rate,integer dilate rate.,D_TYPE dilate rate,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.conv1d,dilation_rate,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.max_pool,data_format,"A string. Specifies the channel dimension. For N=1 it can be either ""NWC"" (default) or ""NCW"", for N=2 it can be either ""NHWC"" (default) or ""NCHW"" and for N=3 either ""NDHWC"" (default) or ""NCDHW"".",A D_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.max_pool,data_format,"A string. Specifies the channel dimension. For N=1 it can be either ""NWC"" (default) or ""NCW"", for N=2 it can be either ""NHWC"" (default) or ""NCHW"" and for N=3 either ""NDHWC"" (default) or ""NCDHW"".",Specifies the channel dimension,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.max_pool,data_format,"A string. Specifies the channel dimension. For N=1 it can be either ""NWC"" (default) or ""NCW"", for N=2 it can be either ""NHWC"" (default) or ""NCHW"" and for N=3 either ""NDHWC"" (default) or ""NCDHW"".",For N CONSTANT_NUM it can be either QSTR BSTR or QSTR for N CONSTANT_NUM it can be either QSTR BSTR or QSTR and for N CONSTANT_NUM either QSTR BSTR or QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.max_pool,data_format,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.spatial_3d_padding,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.keras.layers.Conv3DTranspose,output_padding,"An integer or tuple/list of 3 integers, specifying the amount of padding along the depth, height, and width. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to `None` (default), the output shape is inferred.",An D_TYPE or D_STRUCTURE of CONSTANT_NUM D_TYPE specifying the amount of PARAM along the depth height and width,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,output_padding,"An integer or tuple/list of 3 integers, specifying the amount of padding along the depth, height, and width. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to `None` (default), the output shape is inferred.",Can be a single D_TYPE to specify the same value for all spatial dimensions,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,output_padding,"An integer or tuple/list of 3 integers, specifying the amount of padding along the depth, height, and width. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to `None` (default), the output shape is inferred.",The amount of output PARAM along a given dimension must be lower than the stride along that same dimension,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,output_padding,"An integer or tuple/list of 3 integers, specifying the amount of padding along the depth, height, and width. Can be a single integer to specify the same value for all spatial dimensions. The amount of output padding along a given dimension must be lower than the stride along that same dimension. If set to `None` (default), the output shape is inferred.",If set to QSTR BSTR the output shape is inferred,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,output_padding,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.image.sample_distorted_bounding_box,image_size,"A `Tensor`. Must be one of the following types: `uint8`, `int8`,`int16`, `int32`, `int64`. 1-D, containing `[height, width, channels]`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,"[0,inf)",
tf.image.sample_distorted_bounding_box,image_size,"A `Tensor`. Must be one of the following types: `uint8`, `int8`,`int16`, `int32`, `int64`. 1-D, containing `[height, width, channels]`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,"[0,inf)",
tf.image.sample_distorted_bounding_box,image_size,"A `Tensor`. Must be one of the following types: `uint8`, `int8`,`int16`, `int32`, `int64`. 1-D, containing `[height, width, channels]`.",CONSTANT_NUM D containing BSTR,D_TYPE,D_STRUCTURE,,,,"[0,inf)",
tf.keras.backend.ctc_label_dense_to_sparse,label_lengths,length of the labels.,length of the PARAM,D_TYPE,,,,,"[0,inf)",
tf.io.decode_csv,records,A `Tensor` of type `string`. Each string is a record/row in the csv and all records should have the same format.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.io.decode_csv,records,A `Tensor` of type `string`. Each string is a record/row in the csv and all records should have the same format.,Each D_TYPE is a record row in the csv and all records should have the same format,D_TYPE,D_STRUCTURE,,,,,
tf.nn.fractional_max_pool,pooling_ratio,"An int or list of `ints` that has length `1`, `2` or `4`. Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",An D_TYPE or D_STRUCTURE of D_TYPE that has length CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.fractional_max_pool,pooling_ratio,"An int or list of `ints` that has length `1`, `2` or `4`. Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",Pooling ratio for each dimension of PARAM currently only supports row and col dimension and should be REXPR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.fractional_max_pool,pooling_ratio,"An int or list of `ints` that has length `1`, `2` or `4`. Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",For example a valid pooling ratio looks like BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.fractional_max_pool,pooling_ratio,"An int or list of `ints` that has length `1`, `2` or `4`. Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",The first and last elements must be CONSTANT_FLOAT because we don t allow pooling on batch and channels dimensions,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.fractional_max_pool,pooling_ratio,"An int or list of `ints` that has length `1`, `2` or `4`. Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",CONSTANT_FLOAT and CONSTANT_FLOAT are pooling ratio on height and width dimensions respectively,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.estimator.export.build_parsing_serving_input_receiver_fn,default_batch_size,the number of query examples expected per batch. Leave unset for variable batch size (recommended).,the number of query examples expected per batch,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.estimator.export.build_parsing_serving_input_receiver_fn,default_batch_size,the number of query examples expected per batch. Leave unset for variable batch size (recommended).,Leave unset for variable batch size BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.estimator.export.build_parsing_serving_input_receiver_fn,default_batch_size,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.random.stateless_truncated_normal,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.random.stateless_truncated_normal,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv1d_transpose,dilations,"An int or list of `ints` that has length `1` or `3` which defaults to 1. The dilation factor for each dimension of input. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. Dilations in the batch and depth dimensions must be 1.",An D_TYPE or D_STRUCTURE of D_TYPE that has length CONSTANT_NUM which defaults to CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.conv1d_transpose,dilations,"An int or list of `ints` that has length `1` or `3` which defaults to 1. The dilation factor for each dimension of input. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. Dilations in the batch and depth dimensions must be 1.",The dilation factor for each dimension of PARAM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.conv1d_transpose,dilations,"An int or list of `ints` that has length `1` or `3` which defaults to 1. The dilation factor for each dimension of input. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. Dilations in the batch and depth dimensions must be 1.",If set to k REXPR there will be k CONSTANT_NUM skipped cells between each filter element on that dimension,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.conv1d_transpose,dilations,"An int or list of `ints` that has length `1` or `3` which defaults to 1. The dilation factor for each dimension of input. If set to k > 1, there will be k-1 skipped cells between each filter element on that dimension. Dilations in the batch and depth dimensions must be 1.",Dilations in the batch and depth dimensions must be CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.conv1d_transpose,dilations,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.sparse.reduce_max,output_is_sparse,"If true, returns a `SparseTensor` instead of a dense`Tensor` (the default).",If CONSTANT_BOOL returns a D_STRUCTURE instead of a denseD_STRUCTURE BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.reduce_max,output_is_sparse,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv1d_transpose,padding,"A string, either `'VALID'` or `'SAME'`. The padding algorithm. See the ""returns"" section of `tf.nn.convolution` for details.",A D_TYPE either QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.conv1d_transpose,padding,"A string, either `'VALID'` or `'SAME'`. The padding algorithm. See the ""returns"" section of `tf.nn.convolution` for details.",The padding algorithm,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.conv1d_transpose,padding,"A string, either `'VALID'` or `'SAME'`. The padding algorithm. See the ""returns"" section of `tf.nn.convolution` for details.",See the QSTR section of tf nn convolution for details,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.conv1d_transpose,padding,DF: SAME,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.summary.image,max_outputs,"Optional `int` or rank-0 integer `Tensor`. At most this many images will be emitted at each step. When more than`max_outputs` many images are provided, the first `max_outputs` many images will be used and the rest silently discarded.",Optional D_TYPE or rank CONSTANT_NUM D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.summary.image,max_outputs,"Optional `int` or rank-0 integer `Tensor`. At most this many images will be emitted at each step. When more than`max_outputs` many images are provided, the first `max_outputs` many images will be used and the rest silently discarded.",At most this many images will be emitted at each PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.summary.image,max_outputs,"Optional `int` or rank-0 integer `Tensor`. At most this many images will be emitted at each step. When more than`max_outputs` many images are provided, the first `max_outputs` many images will be used and the rest silently discarded.",When more than QSTR many images are provided the first QSTR many images will be used and the rest silently discarded,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.summary.image,max_outputs,DF: 3,DEFAULT CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.math.logical_xor,y,A `Tensor` of type bool.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.keras.backend.sparse_categorical_crossentropy,from_logits,"Boolean, whether `output` is the result of a softmax, or is a tensor of logits.",D_TYPE whether PARAM is the result of a softmax or is a D_STRUCTURE of logits,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.sparse_categorical_crossentropy,from_logits,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.check_numerics,tensor,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.debugging.check_numerics,tensor,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.feature_column.numeric_column,dtype,"defines the type of values. Default value is `tf.float32`. Must be a non-quantized, real integer or floating point type.",defines the type of values,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.numeric_column,dtype,"defines the type of values. Default value is `tf.float32`. Must be a non-quantized, real integer or floating point type.",Default value is D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.numeric_column,dtype,"defines the type of values. Default value is `tf.float32`. Must be a non-quantized, real integer or floating point type.",Must be a non quantized real D_TYPE point type,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.numeric_column,dtype,DF: tf.dtypes.float32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.math.bincount,arr,An int32 tensor of non-negative values.,An D_TYPE D_STRUCTURE of non negative values,D_TYPE,D_STRUCTURE,,,,"[0,inf)",
tf.bitcast,input,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `int64`, `int32`, `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `complex64`, `complex128`, `qint8`, `quint8`, `qint16`, `quint16`, `qint32`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.bitcast,input,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `int64`, `int32`, `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `complex64`, `complex128`, `qint8`, `quint8`, `qint16`, `quint16`, `qint32`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.nn.avg_pool3d,data_format,A string. 'NDHWC' and 'NCDHW' are supported.,A D_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.avg_pool3d,data_format,A string. 'NDHWC' and 'NCDHW' are supported.,QSTR are supported,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.avg_pool3d,data_format,DF: NDHWC,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.l2_normalize,axis,axis along which to perform normalization.,axis along which to perform normalization,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.l2_normalize,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.segment_min,segment_ids,"A `Tensor`. Must be one of the following types: `int32`, `int64`. A 1-D tensor whose size is equal to the size of `data`'s first dimension.  Values should be sorted and can be repeated.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.segment_min,segment_ids,"A `Tensor`. Must be one of the following types: `int32`, `int64`. A 1-D tensor whose size is equal to the size of `data`'s first dimension.  Values should be sorted and can be repeated.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.segment_min,segment_ids,"A `Tensor`. Must be one of the following types: `int32`, `int64`. A 1-D tensor whose size is equal to the size of `data`'s first dimension.  Values should be sorted and can be repeated.",A CONSTANT_NUM D D_STRUCTURE whose size is equal to the size of PARAMs first dimension,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.segment_min,segment_ids,"A `Tensor`. Must be one of the following types: `int32`, `int64`. A 1-D tensor whose size is equal to the size of `data`'s first dimension.  Values should be sorted and can be repeated.",Values should be sorted and can be repeated,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.data.experimental.make_batched_features_dataset,parser_num_threads,Number of threads to use for parsing `Example` tensors into a dictionary of `Feature` tensors. Defaults to `2`.,Number of threads to use for parsing QSTR D_STRUCTURE into a D_STRUCTURE of QSTR D_STRUCTURE,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.data.experimental.make_batched_features_dataset,parser_num_threads,Number of threads to use for parsing `Example` tensors into a dictionary of `Feature` tensors. Defaults to `2`.,Defaults to CONSTANT_NUM,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.data.experimental.make_batched_features_dataset,parser_num_threads,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.math.scalar_mul,x,A `Tensor` or `IndexedSlices` to be scaled.,A D_STRUCTURE or QSTR to be scaled,,D_STRUCTURE,,,,,
tf.graph_util.import_graph_def,graph_def,A `GraphDef` proto containing operations to be imported into the default graph.,A QSTR proto containing operations to be imported into the default graph,,,,,,,
tf.strings.unicode_decode,input,An `N` dimensional potentially ragged `string` tensor with shape`[D1...DN]`.  `N` must be statically known.,An QSTR dimensional potentially ragged D_TYPE D_STRUCTURE with shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.strings.unicode_decode,input,An `N` dimensional potentially ragged `string` tensor with shape`[D1...DN]`.  `N` must be statically known.,QSTR must be statically known,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.math.unsorted_segment_sqrt_n,segment_ids,An integer tensor whose shape is a prefix of `data.shape`.,An D_TYPE D_STRUCTURE whose shape is a prefix of PARAM shape,D_TYPE,D_STRUCTURE,,,,,
tf.keras.backend.constant,dtype,The type of the elements of the resulting tensor.,The type of the elements of the resulting D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.constant,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.experimental.stop_if_no_increase_hook,eval_dir,"If set, directory containing summary files with eval metrics. By default, `estimator.eval_dir()` will be used.",If set directory containing summary files with eval metrics,,,,,,,
tf.estimator.experimental.stop_if_no_increase_hook,eval_dir,"If set, directory containing summary files with eval metrics. By default, `estimator.eval_dir()` will be used.",By default PARAM eval_dir will be used,,,,,,,
tf.estimator.experimental.stop_if_no_increase_hook,eval_dir,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.depthwise_conv2d,depthwise_kernel,convolution kernel for the depthwise convolution.,convolution kernel for the depthwise convolution,,,,,,,
tf.keras.layers.PReLU,shared_axes,"The axes along which to share learnable parameters for the activation function. For example, if the incoming feature maps are from a 2D convolution with output shape `(batch, height, width, channels)`, and you wish to share parameters across space so that each filter only has one set of parameters, set `shared_axes=[1, 2]`.",The axes along which to share learnable parameters for the activation function,D_TYPE,,,BSTR,CONSTANT_VAL,,
tf.keras.layers.PReLU,shared_axes,"The axes along which to share learnable parameters for the activation function. For example, if the incoming feature maps are from a 2D convolution with output shape `(batch, height, width, channels)`, and you wish to share parameters across space so that each filter only has one set of parameters, set `shared_axes=[1, 2]`.",For example if the incoming feature maps are from a CONSTANT_NUM D convolution with output shape BSTR and you wish to share parameters across space so that each filter only has one set of parameters set shared_axes BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,
tf.keras.layers.PReLU,shared_axes,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,
tf.random.stateless_truncated_normal,stddev,"A 0-D Tensor or Python value of type `dtype`. The standard deviation of the normal distribution, before truncation.",A CONSTANT_NUM D D_STRUCTURE or Python value of type PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.random.stateless_truncated_normal,stddev,"A 0-D Tensor or Python value of type `dtype`. The standard deviation of the normal distribution, before truncation.",The standard deviation of the normal distribution before truncation,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.random.stateless_truncated_normal,stddev,DF: 1.0,DEFAULT CONSTANT_FLOAT,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, depth, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, depth, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",A D_TYPE one of QSTR BSTR or QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.Conv3DTranspose,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, depth, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, depth, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",The ordering of the dimensions in the inputs QSTR corresponds to inputs with shape BSTR while QSTR corresponds to inputs with shape BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.Conv3DTranspose,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, depth, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, depth, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",It defaults to the QSTR value found in your Keras config file at keras keras json,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.Conv3DTranspose,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, depth, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, depth, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",If you never set it then it will be QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.Conv3DTranspose,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.backend.local_conv2d,output_shape,"a tuple with (output_row, output_col).",a D_STRUCTURE with BSTR,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.nn.fractional_avg_pool,pooling_ratio,"A list of `floats` that has length >= 4.  Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",A D_STRUCTURE of D_TYPE that has length REXPR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,pooling_ratio,"A list of `floats` that has length >= 4.  Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",Pooling ratio for each dimension of PARAM currently only supports row and col dimension and should be REXPR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,pooling_ratio,"A list of `floats` that has length >= 4.  Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",For example a valid pooling ratio looks like BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,pooling_ratio,"A list of `floats` that has length >= 4.  Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",The first and last elements must be CONSTANT_FLOAT because we don t allow pooling on batch and channels dimensions,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,pooling_ratio,"A list of `floats` that has length >= 4.  Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be >= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling ratio on height and width dimensions respectively.",CONSTANT_FLOAT and CONSTANT_FLOAT are pooling ratio on height and width dimensions respectively,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.max_pool_with_argmax,include_batch_in_index,An optional `boolean`. Defaults to `False`. Whether to include batch dimension in flattened index of `argmax`.,An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.max_pool_with_argmax,include_batch_in_index,An optional `boolean`. Defaults to `False`. Whether to include batch dimension in flattened index of `argmax`.,Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.max_pool_with_argmax,include_batch_in_index,An optional `boolean`. Defaults to `False`. Whether to include batch dimension in flattened index of `argmax`.,Whether to include batch dimension in flattened index of QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.max_pool_with_argmax,include_batch_in_index,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.softmax_cross_entropy_with_logits,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.softmax_cross_entropy_with_logits,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.random.learned_unigram_candidate_sampler,range_max,An `int`. The number of possible classes.,An D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.random.learned_unigram_candidate_sampler,range_max,An `int`. The number of possible classes.,The number of possible classes,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.image.rgb_to_grayscale,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.image.rgb_to_grayscale,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.ifft,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.ifft,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.regressor_parse_example_spec,label_key,A string identifying the label. It means tf.Example stores labels with this key.,A D_TYPE identifying the label,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.regressor_parse_example_spec,label_key,A string identifying the label. It means tf.Example stores labels with this key.,It means tf Example stores labels with this key,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv3d_transpose,name,Optional name for the returned tensor.,Optional name for the returned D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv3d_transpose,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.audio.encode_wav,sample_rate,A `Tensor` of type `int32`. Scalar containing the sample frequency.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.audio.encode_wav,sample_rate,A `Tensor` of type `int32`. Scalar containing the sample frequency.,Scalar containing the sample frequency,D_TYPE,D_STRUCTURE,,,,,
tf.vectorized_map,fn,"The callable to be performed. It accepts one argument, which will have the same (possibly nested) structure as `elems`, and returns a possibly nested structure of Tensors and Operations, which may be different than the structure of `elems`.",The callable to be performed,,,,,,,
tf.vectorized_map,fn,"The callable to be performed. It accepts one argument, which will have the same (possibly nested) structure as `elems`, and returns a possibly nested structure of Tensors and Operations, which may be different than the structure of `elems`.",It accepts one argument which will have the same BSTR structure as PARAM and returns a possibly nested structure of D_STRUCTURE and Operations which may be different than the structure of PARAM,,,,,,,
tf.nn.conv1d_transpose,input,"A 3-D `Tensor` of type `float` and shape`[batch, in_width, in_channels]` for `NWC` data format or`[batch, in_channels, in_width]` for `NCW` data format.",A CONSTANT_NUM D D_STRUCTURE of type D_TYPE and shape BSTR for QSTR data format or BSTR for QSTR data format,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.config.set_soft_device_placement,enabled,Whether to enable soft placement.,Whether to enable soft placement,D_TYPE,,,,,,
tf.math.less_equal,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.less_equal,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.dilation2d,strides,"A list of `ints` that has length `>= 4`. The stride of the sliding window for each dimension of the input tensor. Must be: `[1, stride_height, stride_width, 1]`.",A D_STRUCTURE of D_TYPE that has length REXPR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.dilation2d,strides,"A list of `ints` that has length `>= 4`. The stride of the sliding window for each dimension of the input tensor. Must be: `[1, stride_height, stride_width, 1]`.",The stride of the sliding window for each dimension of the PARAM D_STRUCTURE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.nn.dilation2d,strides,"A list of `ints` that has length `>= 4`. The stride of the sliding window for each dimension of the input tensor. Must be: `[1, stride_height, stride_width, 1]`.",Must be BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.image.rgb_to_grayscale,images,The RGB tensor to convert. Last dimension must have size 3 and should contain RGB values.,The RGB D_STRUCTURE to convert,D_TYPE,D_STRUCTURE,,,,,
tf.image.rgb_to_grayscale,images,The RGB tensor to convert. Last dimension must have size 3 and should contain RGB values.,Last dimension must have size CONSTANT_NUM and should contain RGB values,D_TYPE,D_STRUCTURE,,,,,
tf.image.grayscale_to_rgb,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.image.grayscale_to_rgb,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.quantize_and_dequantize,input_max,"If range_given=True, the maximum input value that needs to be represented in the quantized representation. If axis is specified, this should be a vector of maximum values for each slice along axis.",If PARAM CONSTANT_BOOL the maximum PARAM value that needs to be represented in the quantized representation,,,D_STRUCTURE,,,,
tf.quantization.quantize_and_dequantize,input_max,"If range_given=True, the maximum input value that needs to be represented in the quantized representation. If axis is specified, this should be a vector of maximum values for each slice along axis.",If PARAM is specified this should be a vector of maximum values for each slice along PARAM,,,D_STRUCTURE,,,,
tf.feature_column.embedding_column,dimension,"An integer specifying dimension of the embedding, must be > 0.",An D_TYPE specifying dimension of the embedding must be REXPR,D_TYPE,,,,CONSTANT_VAL,"(0,inf)",
tf.keras.layers.SimpleRNNCell,bias_regularizer,Regularizer function applied to the bias vector. Default:`None`.,Regularizer function applied to the bias vector,,,,,,,
tf.keras.layers.SimpleRNNCell,bias_regularizer,Regularizer function applied to the bias vector. Default:`None`.,Default QSTR,,,,,,,
tf.keras.layers.SimpleRNNCell,bias_regularizer,DF: None,DEFAULT None,,,,,,,
tf.norm,name,The name of the op.,The name of the op,D_TYPE,,,,CONSTANT_VAL,,
tf.norm,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.datasets.reuters.load_data,oov_char,words that were cut out because of the `num_words`or `skip_top` limit will be replaced with this character.,words that were cut out because of the PARAMor PARAM limit will be replaced with this character,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.datasets.reuters.load_data,oov_char,DF: 2,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.zeros_like,input,A `Tensor`.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.debugging.assert_non_negative,x,Numeric `Tensor`.,D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.keras.layers.LSTMCell,bias_initializer,Initializer for the bias vector. Default: `zeros`.,Initializer for the bias vector,D_TYPE,,,,,,
tf.keras.layers.LSTMCell,bias_initializer,Initializer for the bias vector. Default: `zeros`.,Default QSTR,D_TYPE,,,,,,
tf.keras.layers.LSTMCell,bias_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.io.gfile.copy,dst,"string, name of the file to which to copy to",D_TYPE name of the file to which to copy to,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_equal,name,"A name for this operation (optional).  Defaults to ""assert_equal"".",A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_equal,name,"A name for this operation (optional).  Defaults to ""assert_equal"".",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_equal,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.strided_slice,new_axis_mask,An `int32` mask.,An D_TYPE mask,D_TYPE,,,,CONSTANT_VAL,,
tf.strided_slice,new_axis_mask,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.zeros,shape,"Tuple or list of integers, shape of returned Keras variable",D_STRUCTURE of D_TYPE shape of returned Keras variable,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.io.encode_jpeg,format,"An optional `string` from: `"""", ""grayscale"", ""rgb""`. Defaults to `""""`. Per pixel image format.",An optional D_TYPE from QSTR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.io.encode_jpeg,format,"An optional `string` from: `"""", ""grayscale"", ""rgb""`. Defaults to `""""`. Per pixel image format.",Defaults to,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.io.encode_jpeg,format,"An optional `string` from: `"""", ""grayscale"", ""rgb""`. Defaults to `""""`. Per pixel image format.",Per pixel PARAM format,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.io.encode_jpeg,format,DF: ,,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.print_tensor,x,Tensor to print.,D_STRUCTURE to print,,D_STRUCTURE,,,,,
tf.keras.backend.categorical_crossentropy,axis,"Int specifying the channels axis. `axis=-1` corresponds to data format `channels_last', and`axis=1`corresponds to data format`channels_first`.",D_TYPE specifying the channels axis,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.categorical_crossentropy,axis,"Int specifying the channels axis. `axis=-1` corresponds to data format `channels_last', and`axis=1`corresponds to data format`channels_first`.",QSTR channels_last and QSTR channels_first,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.categorical_crossentropy,axis,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.expand_dims,input,A `Tensor`.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.linalg.lu_reconstruct,perm,"`p` as returned by `tf.linag.lu`, i.e., if `matmul(P, matmul(L, U)) = X` then `perm = argmax(P)`.",QSTR as returned by tf linag lu i e if matmul BSTR X QSTR perm argmax BSTR,,,,,,,
tf.nest.map_structure,**kwargs,"Valid keyword args are: `check_types`: If set to `True` (default) the types of iterables within the structures have to be same (e.g.`map_structure(func, [1], (1,))` raises a `TypeError`exception). To allow this set this argument to `False`. Note that namedtuples with identical name and fields are always considered to have the same shallow structure.`expand_composites`: If set to `True`, then composite tensors such as `tf.SparseTensor` and `tf.RaggedTensor` are expanded into their component tensors.  If `False` (the default), then composite tensors are not expanded. ",Valid keyword args are QSTR If set to CONSTANT_BOOL BSTR the types of iterables within the structures have to be same e g map_structure PARAM BSTR BSTR raises a QSTR exception,D_TYPE,,,,CONSTANT_VAL,,
tf.nest.map_structure,**kwargs,"Valid keyword args are: `check_types`: If set to `True` (default) the types of iterables within the structures have to be same (e.g.`map_structure(func, [1], (1,))` raises a `TypeError`exception). To allow this set this argument to `False`. Note that namedtuples with identical name and fields are always considered to have the same shallow structure.`expand_composites`: If set to `True`, then composite tensors such as `tf.SparseTensor` and `tf.RaggedTensor` are expanded into their component tensors.  If `False` (the default), then composite tensors are not expanded. ",To allow this set this argument to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nest.map_structure,**kwargs,"Valid keyword args are: `check_types`: If set to `True` (default) the types of iterables within the structures have to be same (e.g.`map_structure(func, [1], (1,))` raises a `TypeError`exception). To allow this set this argument to `False`. Note that namedtuples with identical name and fields are always considered to have the same shallow structure.`expand_composites`: If set to `True`, then composite tensors such as `tf.SparseTensor` and `tf.RaggedTensor` are expanded into their component tensors.  If `False` (the default), then composite tensors are not expanded. ",Note that namedtuples with identical name and fields are always considered to have the same shallow structure QSTR If set to CONSTANT_BOOL then composite D_STRUCTURE such as D_STRUCTURE and tf RaggedTensor are expanded into their component D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.nest.map_structure,**kwargs,"Valid keyword args are: `check_types`: If set to `True` (default) the types of iterables within the structures have to be same (e.g.`map_structure(func, [1], (1,))` raises a `TypeError`exception). To allow this set this argument to `False`. Note that namedtuples with identical name and fields are always considered to have the same shallow structure.`expand_composites`: If set to `True`, then composite tensors such as `tf.SparseTensor` and `tf.RaggedTensor` are expanded into their component tensors.  If `False` (the default), then composite tensors are not expanded. ",If CONSTANT_BOOL BSTR then composite D_STRUCTURE are not expanded,D_TYPE,,,,CONSTANT_VAL,,
tf.math.unsorted_segment_mean,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.unsorted_segment_mean,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.ragged.range,deltas,Vector or scalar `Tensor`.  Specifies the increment for each range. Defaults to `1`.,Vector or scalar D_STRUCTURE,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.ragged.range,deltas,Vector or scalar `Tensor`.  Specifies the increment for each range. Defaults to `1`.,Specifies the increment for each range,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.ragged.range,deltas,Vector or scalar `Tensor`.  Specifies the increment for each range. Defaults to `1`.,Defaults to CONSTANT_NUM,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.ragged.range,deltas,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.math.acosh,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `complex64`, `complex128`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.acosh,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `complex64`, `complex128`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.image.rgb_to_hsv,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. RGB data to convert. Last dimension must be size 3.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.rgb_to_hsv,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. RGB data to convert. Last dimension must be size 3.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.rgb_to_hsv,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. RGB data to convert. Last dimension must be size 3.",CONSTANT_NUM D or higher rank,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.rgb_to_hsv,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. RGB data to convert. Last dimension must be size 3.",RGB data to convert,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.image.rgb_to_hsv,images,"A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`. 1-D or higher rank. RGB data to convert. Last dimension must be size 3.",Last dimension must be size CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.linalg.matrix_rank,validate_args,"When `True`, additional assertions might be embedded in the graph. Default value: `False` (i.e., no graph assertions are added).",When CONSTANT_BOOL additional assertions might be embedded in the graph,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.matrix_rank,validate_args,"When `True`, additional assertions might be embedded in the graph. Default value: `False` (i.e., no graph assertions are added).",Default value CONSTANT_BOOL BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.matrix_rank,validate_args,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.foldl,elems,tensor,ONE_WORD D_STRUCTURE,,,,,,,
tf.keras.layers.SeparableConv1D,pointwise_regularizer,Optional regularizer for the pointwise convolution kernel.,Optional regularizer for the pointwise convolution kernel,,,,,,,
tf.keras.layers.SeparableConv1D,pointwise_regularizer,DF: None,DEFAULT None,,,,,,,
tf.feature_column.numeric_column,default_value,"A single value compatible with `dtype` or an iterable of values compatible with `dtype` which the column takes on during`tf.Example` parsing if data is missing. A default value of `None` will cause `tf.io.parse_example` to fail if an example does not contain this column. If a single value is provided, the same value will be applied as the default value for every item. If an iterable of values is provided, the shape of the `default_value` should be equal to the given `shape`.",A single value compatible with PARAM or an D_STRUCTURE of values compatible with PARAM which the column takes on during tf Example parsing if data is missing,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.feature_column.numeric_column,default_value,"A single value compatible with `dtype` or an iterable of values compatible with `dtype` which the column takes on during`tf.Example` parsing if data is missing. A default value of `None` will cause `tf.io.parse_example` to fail if an example does not contain this column. If a single value is provided, the same value will be applied as the default value for every item. If an iterable of values is provided, the shape of the `default_value` should be equal to the given `shape`.",A default value of QSTR will cause tf io parse_example to fail if an example does not contain this column,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.feature_column.numeric_column,default_value,"A single value compatible with `dtype` or an iterable of values compatible with `dtype` which the column takes on during`tf.Example` parsing if data is missing. A default value of `None` will cause `tf.io.parse_example` to fail if an example does not contain this column. If a single value is provided, the same value will be applied as the default value for every item. If an iterable of values is provided, the shape of the `default_value` should be equal to the given `shape`.",If a single value is provided the same value will be applied as the default value for every item,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.feature_column.numeric_column,default_value,"A single value compatible with `dtype` or an iterable of values compatible with `dtype` which the column takes on during`tf.Example` parsing if data is missing. A default value of `None` will cause `tf.io.parse_example` to fail if an example does not contain this column. If a single value is provided, the same value will be applied as the default value for every item. If an iterable of values is provided, the shape of the `default_value` should be equal to the given `shape`.",If an D_STRUCTURE of values is provided the PARAM of the QSTR should be equal to the given PARAM,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.feature_column.numeric_column,default_value,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.average,inputs,A list of input tensors (at least 2).,A D_STRUCTURE of input D_STRUCTURE BSTR,,,D_STRUCTURE,,,,
tf.get_static_value,partial,"If True, the returned numpy array is allowed to have partially evaluated values. Values that can't be evaluated will be None.",If CONSTANT_BOOL the returned numpy D_STRUCTURE is allowed to have partially evaluated values,D_TYPE,,,,CONSTANT_VAL,,
tf.get_static_value,partial,"If True, the returned numpy array is allowed to have partially evaluated values. Values that can't be evaluated will be None.",Values that can t be evaluated will be None,D_TYPE,,,,CONSTANT_VAL,,
tf.get_static_value,partial,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_scalar,message,A string to prefix to the default message.,A D_TYPE to prefix to the default message,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_scalar,message,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_shapes,message,A string to prefix to the default message.,A D_TYPE to prefix to the default message,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_shapes,message,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.argmin,output_type,"An optional `tf.DType` from: `tf.int32, tf.int64`. Defaults to`tf.int64`.",An optional D_TYPE from D_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.math.argmin,output_type,"An optional `tf.DType` from: `tf.int32, tf.int64`. Defaults to`tf.int64`.",Defaults toD_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.math.argmin,output_type,DF: tf.dtypes.int64,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.eye,name,"A name for this `Op`.  Defaults to ""eye"".",A name for this QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.eye,name,"A name for this `Op`.  Defaults to ""eye"".",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.eye,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.linspace,stop,A `Tensor`. Must have the same type as `start`. 0-D tensor. Last entry in the range.,A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.linspace,stop,A `Tensor`. Must have the same type as `start`. 0-D tensor. Last entry in the range.,Must have the same type as PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.linspace,stop,A `Tensor`. Must have the same type as `start`. 0-D tensor. Last entry in the range.,CONSTANT_NUM D D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.linspace,stop,A `Tensor`. Must have the same type as `start`. 0-D tensor. Last entry in the range.,Last entry in the range,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.clip_by_value,clip_value_max,"A 0-D (scalar) `Tensor`, or a `Tensor` with the same shape as `t`. The maximum value to clip by.",A CONSTANT_NUM D BSTR D_STRUCTURE with the same shape as QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,
tf.clip_by_value,clip_value_max,"A 0-D (scalar) `Tensor`, or a `Tensor` with the same shape as `t`. The maximum value to clip by.",The maximum value to clip by,D_TYPE,,,BSTR,CONSTANT_VAL,,
tf.math.equal,x,A `tf.Tensor` or `tf.SparseTensor` or `tf.IndexedSlices`.,A D_STRUCTURE or tf IndexedSlices,,D_STRUCTURE,,,,,
tf.image.ssim_multiscale,k1,Default value 0.01,Default value CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.image.ssim_multiscale,k1,DF: 0.01,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.image.random_brightness,max_delta,"float, must be non-negative.",D_TYPE must be non negative,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.dot,normalize,"Whether to L2-normalize samples along the dot product axis before taking the dot product. If set to True, then the output of the dot product is the cosine proximity between the two samples.",Whether to L2 normalize samples along the dot product axis before taking the dot product,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.dot,normalize,"Whether to L2-normalize samples along the dot product axis before taking the dot product. If set to True, then the output of the dot product is the cosine proximity between the two samples.",If set to CONSTANT_BOOL then the output of the dot product is the cosine proximity between the two samples,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.dot,normalize,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.activations.softmax,x,Input tensor.,Input D_STRUCTURE,,D_STRUCTURE,,,,,
tf.strings.unicode_encode,errors,Specifies the response when an invalid codepoint is encountered (optional). One of:     * `'replace'`: Replace invalid codepoint with the       `replacement_char`. (default)     * `'ignore'`: Skip invalid codepoints.     * `'strict'`: Raise an exception for any invalid codepoint.,Specifies the response when an invalid codepoint is encountered BSTR,D_TYPE,,,,,,
tf.strings.unicode_encode,errors,Specifies the response when an invalid codepoint is encountered (optional). One of:     * `'replace'`: Replace invalid codepoint with the       `replacement_char`. (default)     * `'ignore'`: Skip invalid codepoints.     * `'strict'`: Raise an exception for any invalid codepoint.,One of QSTR Replace invalid codepoint with the PARAM,D_TYPE,,,,,,
tf.strings.unicode_encode,errors,Specifies the response when an invalid codepoint is encountered (optional). One of:     * `'replace'`: Replace invalid codepoint with the       `replacement_char`. (default)     * `'ignore'`: Skip invalid codepoints.     * `'strict'`: Raise an exception for any invalid codepoint.,BSTR QSTR Skip invalid codepoints,D_TYPE,,,,,,
tf.strings.unicode_encode,errors,Specifies the response when an invalid codepoint is encountered (optional). One of:     * `'replace'`: Replace invalid codepoint with the       `replacement_char`. (default)     * `'ignore'`: Skip invalid codepoints.     * `'strict'`: Raise an exception for any invalid codepoint.,QSTR Raise an exception for any invalid codepoint,D_TYPE,,,,,,
tf.strings.unicode_encode,errors,DF: replace,DEFAULT DF_STR,D_TYPE,,,,,,
tf.signal.inverse_stft,frame_step,An integer scalar `Tensor`. The number of samples to step.,An D_TYPE scalar D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.signal.inverse_stft,frame_step,An integer scalar `Tensor`. The number of samples to step.,The number of samples to step,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.config.experimental_connect_to_host,job_name,The job name under which the new server will be accessible.,The job name under which the new server will be accessible,D_TYPE,,,,CONSTANT_VAL,,
tf.config.experimental_connect_to_host,job_name,DF: worker,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,
tf.random.uniform,dtype,"The type of the output: `float16`, `float32`, `float64`, `int32`, or `int64`.",The type of the output D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.random.uniform,dtype,DF: tf.dtypes.float32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cumulative_logsumexp,reverse,"If `True`, performs the cumulative log-sum-exp in the reverse direction.",If CONSTANT_BOOL performs the cumulative log sum exp in the reverse direction,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cumulative_logsumexp,reverse,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.random_zoom,row_axis,Index of axis for rows in the input tensor.,Index of axis for rows in the input D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.random_zoom,row_axis,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.math.accumulate_n,inputs,"A list of `Tensor` objects, each with same shape and type.",A D_STRUCTURE of D_STRUCTURE objects each with same PARAM and type,,,D_STRUCTURE,,,,
tf.keras.layers.SeparableConv2D,bias_regularizer,Regularizer function applied to the bias vector.,Regularizer function applied to the bias vector,,,,,,,
tf.keras.layers.SeparableConv2D,bias_regularizer,DF: None,DEFAULT None,,,,,,,
tf.nn.separable_conv2d,input,4-D `Tensor` with shape according to `data_format`.,CONSTANT_NUM D D_STRUCTURE with shape according to PARAM,,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.unsorted_segment_sum,data,"A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.unsorted_segment_sum,data,"A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.math.squared_difference,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.squared_difference,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.squared_difference,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.squared_difference,x,"A `Tensor`. Must be one of the following types: `bfloat16`, `half`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.image.ssim_multiscale,k2,"Default value 0.03 (SSIM is less sensitivity to K2 for lower values, so it would be better if we taken the values in range of 0< K2 <0.4).",Default value CONSTANT_FLOAT SSIM is less sensitivity to K2 for lower values so it would be better if we taken the values in range of CONSTANT_NUM REXPR REXPR,D_TYPE,,,,CONSTANT_VAL,,
tf.image.ssim_multiscale,k2,DF: 0.03,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.slice,start,1-D. tensor represents the start of the slice.,CONSTANT_NUM D D_STRUCTURE represents the start of the slice,,,,,CONSTANT_VAL,,
tf.keras.Input,dtype,"The data type expected by the input, as a string (`float32`, `float64`, `int32`...)",The data type expected by the input as a D_TYPE BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.Input,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.cond,name,Optional name prefix for the returned tensors.,Optional name prefix for the returned D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.cond,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.invert_permutation,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.invert_permutation,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.random_binomial,seed,"Integer, random seed.",D_TYPE random seed,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.random_binomial,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.serialize_tensor,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.io.serialize_tensor,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.sparse_dense_matmul,adjoint_b,"Use the adjoint of B in the matrix multiply.  If B is complex, this is transpose(conj(B)).  Otherwise it's transpose(B).",Use the adjoint of B in the matrix multiply,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.sparse_dense_matmul,adjoint_b,"Use the adjoint of B in the matrix multiply.  If B is complex, this is transpose(conj(B)).  Otherwise it's transpose(B).",If B is D_TYPE this is transpose BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.sparse_dense_matmul,adjoint_b,"Use the adjoint of B in the matrix multiply.  If B is complex, this is transpose(conj(B)).  Otherwise it's transpose(B).",Otherwise it transpose BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.sparse_dense_matmul,adjoint_b,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_png,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_png,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv3d_transpose,data_format,A string. 'NDHWC' and 'NCDHW' are supported.,A D_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.conv3d_transpose,data_format,A string. 'NDHWC' and 'NCDHW' are supported.,QSTR are supported,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.conv3d_transpose,data_format,DF: NDHWC,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.squeeze,x,A tensor or variable.,A D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.debugging.assert_integer,name,"A name for this operation (optional). Defaults to ""assert_integer"".",A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_integer,name,"A name for this operation (optional). Defaults to ""assert_integer"".",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_integer,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.audio.decode_wav,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.audio.decode_wav,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.regularizers.l1,l,Float; L1 regularization factor.,D_TYPE L1 regularization factor,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.regularizers.l1,l,DF: 0.01,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.experimental.stop_if_no_decrease_hook,metric_name,"`str`, metric to track. ""loss"", ""accuracy"", etc.",D_TYPE metric to track,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.experimental.stop_if_no_decrease_hook,metric_name,"`str`, metric to track. ""loss"", ""accuracy"", etc.",QSTR etc,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.Input,ragged,"A boolean specifying whether the placeholder to be created is ragged. Only one of 'ragged' and 'sparse' can be True. In this case, values of 'None' in the 'shape' argument represent ragged dimensions. For more information about RaggedTensors, seehttps://www.tensorflow.org/guide/ragged_tensors",A D_TYPE specifying whether the placeholder to be created is ragged,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.Input,ragged,"A boolean specifying whether the placeholder to be created is ragged. Only one of 'ragged' and 'sparse' can be True. In this case, values of 'None' in the 'shape' argument represent ragged dimensions. For more information about RaggedTensors, seehttps://www.tensorflow.org/guide/ragged_tensors",Only one of QSTR and PARAM can be CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.Input,ragged,"A boolean specifying whether the placeholder to be created is ragged. Only one of 'ragged' and 'sparse' can be True. In this case, values of 'None' in the 'shape' argument represent ragged dimensions. For more information about RaggedTensors, seehttps://www.tensorflow.org/guide/ragged_tensors",In this case values of QSTR in the PARAM argument represent ragged dimensions,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.Input,ragged,"A boolean specifying whether the placeholder to be created is ragged. Only one of 'ragged' and 'sparse' can be True. In this case, values of 'None' in the 'shape' argument represent ragged dimensions. For more information about RaggedTensors, seehttps://www.tensorflow.org/guide/ragged_tensors",For more information about RaggedTensors seehttps www tensorflow org guide ragged_tensors,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.Input,ragged,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.layers.Bidirectional,merge_mode,"Mode by which outputs of the forward and backward RNNs will be combined. One of {'sum', 'mul', 'concat', 'ave', None}. If None, the outputs will not be combined, they will be returned as a list.",Mode by which outputs of the forward and backward RNNs will be combined,D_TYPE,,,,,,
tf.keras.layers.Bidirectional,merge_mode,"Mode by which outputs of the forward and backward RNNs will be combined. One of {'sum', 'mul', 'concat', 'ave', None}. If None, the outputs will not be combined, they will be returned as a list.",One of QSTR None,D_TYPE,,,,,,
tf.keras.layers.Bidirectional,merge_mode,"Mode by which outputs of the forward and backward RNNs will be combined. One of {'sum', 'mul', 'concat', 'ave', None}. If None, the outputs will not be combined, they will be returned as a list.",If None the outputs will not be combined they will be returned as a D_STRUCTURE,D_TYPE,,,,,,
tf.keras.layers.Bidirectional,merge_mode,DF: concat,DEFAULT DF_STR,D_TYPE,,,,,,
tf.image.resize_with_pad,method,Method to use for resizing image. See `image.resize()`,Method to use for resizing PARAM,,,,,,,
tf.image.resize_with_pad,method,Method to use for resizing image. See `image.resize()`,See PARAM resize,,,,,,,
tf.image.resize_with_pad,method,DF: ResizeMethod.BILINEAR,ResizeMethod BILINEAR,,,,,,,
tf.math.in_top_k,predictions,A `Tensor` of type `float32`. A `batch_size` x `classes` tensor.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.math.in_top_k,predictions,A `Tensor` of type `float32`. A `batch_size` x `classes` tensor.,A QSTR x QSTR D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.strings.format,template,A string template to format tensor values into.,A D_TYPE template to format D_STRUCTURE values into,D_TYPE,,,,CONSTANT_VAL,,
tf.image.random_contrast,lower,float.  Lower bound for the random contrast factor.,ONE_WORD D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.image.random_contrast,lower,float.  Lower bound for the random contrast factor.,Lower bound for the random contrast factor,D_TYPE,,,,CONSTANT_VAL,,
tf.truncatemod,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.truncatemod,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LayerNormalization,gamma_initializer,Initializer for the gamma weight.,Initializer for the gamma weight,D_TYPE,,,,,,
tf.keras.layers.LayerNormalization,gamma_initializer,DF: ones,DEFAULT DF_STR,D_TYPE,,,,,,
tf.sparse.eye,dtype,The type of element in the resulting `Tensor`.,The type of element in the resulting D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.eye,dtype,DF: tf.dtypes.float32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.pool2d,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.summary.audio,max_outputs,"Optional `int` or rank-0 integer `Tensor`. At most this many audio clips will be emitted at each step. When more than`max_outputs` many clips are provided, the first `max_outputs`many clips will be used and the rest silently discarded.",Optional D_TYPE or rank CONSTANT_NUM D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.summary.audio,max_outputs,"Optional `int` or rank-0 integer `Tensor`. At most this many audio clips will be emitted at each step. When more than`max_outputs` many clips are provided, the first `max_outputs`many clips will be used and the rest silently discarded.",At most this many audio clips will be emitted at each PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.summary.audio,max_outputs,"Optional `int` or rank-0 integer `Tensor`. At most this many audio clips will be emitted at each step. When more than`max_outputs` many clips are provided, the first `max_outputs`many clips will be used and the rest silently discarded.",When more than QSTR many clips are provided the first QSTR many clips will be used and the rest silently discarded,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.summary.audio,max_outputs,DF: 3,DEFAULT CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.pad,constant_values,"In ""CONSTANT"" mode, the scalar pad value to use. Must be same type as `tensor`.",In QSTR PARAM the scalar pad value to use,D_TYPE,,,,CONSTANT_VAL,,
tf.pad,constant_values,"In ""CONSTANT"" mode, the scalar pad value to use. Must be same type as `tensor`.",Must be same type as D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.pad,constant_values,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.UpSampling3D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`while `channels_first` corresponds to inputs with shape`(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",A D_TYPE one of QSTR BSTR or QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling3D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`while `channels_first` corresponds to inputs with shape`(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",The ordering of the dimensions in the inputs QSTR corresponds to inputs with shape BSTRwhile QSTR corresponds to inputs with shape BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling3D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`while `channels_first` corresponds to inputs with shape`(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",It defaults to the QSTR value found in your Keras config file at keras keras json,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling3D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`while `channels_first` corresponds to inputs with shape`(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",If you never set it then it will be QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling3D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.transpose,perm,A permutation of the dimensions of `a`.,A permutation of the dimensions of QSTR,,,,,,,
tf.transpose,perm,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.GRUCell,bias_constraint,Constraint function applied to the bias vector. Default:`None`.,Constraint function applied to the bias vector,,,,,,,
tf.keras.layers.GRUCell,bias_constraint,Constraint function applied to the bias vector. Default:`None`.,Default QSTR,,,,,,,
tf.keras.layers.GRUCell,bias_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.Conv3D,activation,"Activation function to use. If you don't specify anything, no activation is applied (ie. ""linear"" activation: `a(x) = x`).",Activation function to use,,,,,,,
tf.keras.layers.Conv3D,activation,"Activation function to use. If you don't specify anything, no activation is applied (ie. ""linear"" activation: `a(x) = x`).",If you don t specify anything no activation is applied ie,,,,,,,
tf.keras.layers.Conv3D,activation,"Activation function to use. If you don't specify anything, no activation is applied (ie. ""linear"" activation: `a(x) = x`).",QSTR activation a BSTR x,,,,,,,
tf.keras.layers.Conv3D,activation,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.Layer,trainable,"Boolean, whether the layer's variables should be trainable.",D_TYPE whether the layer variables should be trainable,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Layer,trainable,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.erosion2d,dilations,"A list of `ints` that has length `>= 4`. 1-D of length 4. The input stride for atrous morphological dilation. Must be: `[1, rate_height, rate_width, 1]`.",A D_STRUCTURE of D_TYPE that has length REXPR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.erosion2d,dilations,"A list of `ints` that has length `>= 4`. 1-D of length 4. The input stride for atrous morphological dilation. Must be: `[1, rate_height, rate_width, 1]`.",CONSTANT_NUM D of length CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.erosion2d,dilations,"A list of `ints` that has length `>= 4`. 1-D of length 4. The input stride for atrous morphological dilation. Must be: `[1, rate_height, rate_width, 1]`.",The input stride for atrous morphological dilation,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.erosion2d,dilations,"A list of `ints` that has length `>= 4`. 1-D of length 4. The input stride for atrous morphological dilation. Must be: `[1, rate_height, rate_width, 1]`.",Must be BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.gather,batch_dims,An `integer`.  The number of batch dimensions.  Must be less than `rank(indices)`.,An D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.gather,batch_dims,An `integer`.  The number of batch dimensions.  Must be less than `rank(indices)`.,The number of batch dimensions,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.gather,batch_dims,An `integer`.  The number of batch dimensions.  Must be less than `rank(indices)`.,Must be less than rank BSTR,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.gather,batch_dims,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.in_train_phase,x,What to return in train phase (tensor or callable that returns a tensor).,What to return in train phase BSTR,,,,,,,
tf.data.experimental.make_batched_features_dataset,shuffle_seed,Randomization seed to use for shuffling.,Randomization seed to use for shuffling,,,,,,,
tf.data.experimental.make_batched_features_dataset,shuffle_seed,DF: None,DEFAULT None,,,,,,,
tf.math.unsorted_segment_prod,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.unsorted_segment_prod,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.l2_normalize,x,A `Tensor`.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.image.combined_non_max_suppression,iou_threshold,A float representing the threshold for deciding whether boxes overlap too much with respect to IOU.,A D_TYPE representing the threshold for deciding whether PARAM overlap too much with respect to IOU,D_TYPE,,,,CONSTANT_VAL,,
tf.image.combined_non_max_suppression,iou_threshold,DF: 0.5,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.AveragePooling1D,pool_size,"Integer, size of the average pooling windows.",D_TYPE size of the average pooling windows,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.AveragePooling1D,pool_size,DF: 2,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.print,output_stream,"The output stream, logging level, or file to print to. Defaults to sys.stderr, but sys.stdout, tf.compat.v1.logging.info, tf.compat.v1.logging.warning, tf.compat.v1.logging.error, absl.logging.info, absl.logging.warning and absl.loogging,error are also supported. To print to a file, pass a string started with ""file://"" followed by the file path, e.g., ""file:///tmp/foo.out"".",The output stream logging level or file to print to,,,,,,,
tf.print,output_stream,"The output stream, logging level, or file to print to. Defaults to sys.stderr, but sys.stdout, tf.compat.v1.logging.info, tf.compat.v1.logging.warning, tf.compat.v1.logging.error, absl.logging.info, absl.logging.warning and absl.loogging,error are also supported. To print to a file, pass a string started with ""file://"" followed by the file path, e.g., ""file:///tmp/foo.out"".",Defaults to sys stderr but sys stdout tf compat v1 logging info tf compat v1 logging warning tf compat v1 logging error absl logging info absl logging warning and absl loogging error are also supported,,,,,,,
tf.print,output_stream,"The output stream, logging level, or file to print to. Defaults to sys.stderr, but sys.stdout, tf.compat.v1.logging.info, tf.compat.v1.logging.warning, tf.compat.v1.logging.error, absl.logging.info, absl.logging.warning and absl.loogging,error are also supported. To print to a file, pass a string started with ""file://"" followed by the file path, e.g., ""file:///tmp/foo.out"".",To print to a file pass a D_TYPE started with file followed by the file path e g file tmp foo out,,,,,,,
tf.print,output_stream,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.spatial_3d_padding,padding,"Tuple of 3 tuples, padding pattern.",D_STRUCTURE of CONSTANT_NUM tuples padding pattern,,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.backend.spatial_3d_padding,padding,"DF: ((1, 1), (1, 1), (1, 1))",DEFAULT BSTR,,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.argsort,values,1-D or higher numeric `Tensor`.,CONSTANT_NUM D or higher D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.nn.conv2d_transpose,name,Optional name for the returned tensor.,Optional name for the returned D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv2d_transpose,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,num_classes,An `int`. The number of possible classes.,An D_TYPE,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.nn.sampled_softmax_loss,num_classes,An `int`. The number of possible classes.,The number of possible classes,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.preprocessing.image.random_shift,wrg,"Width shift range, as a float fraction of the width.",Width shift range as a D_TYPE fraction of the width,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.utils.model_to_dot,rankdir,"`rankdir` argument passed to PyDot, a string specifying the format of the plot: 'TB' creates a vertical plot; 'LR' creates a horizontal plot.",QSTR argument passed to PyDot a D_TYPE specifying the format of the plot QSTR creates a vertical plot QSTR creates a horizontal plot,D_TYPE,,,,,,
tf.keras.utils.model_to_dot,rankdir,DF: TB,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.layers.LayerNormalization,center,"If True, add offset of `beta` to normalized tensor. If False, `beta` is ignored.",If CONSTANT_BOOL add offset of QSTR to normalized D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LayerNormalization,center,"If True, add offset of `beta` to normalized tensor. If False, `beta` is ignored.",If CONSTANT_BOOL QSTR is ignored,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LayerNormalization,center,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.ctc_batch_cost,y_pred,"tensor `(samples, time_steps, num_categories)`containing the prediction, or output of the softmax.",D_STRUCTURE BSTRcontaining the prediction or output of the softmax,,D_STRUCTURE,,,,,
tf.gather,indices,"The index `Tensor`.  Must be one of the following types: `int32`,`int64`. Must be in range `[0, params.shape[axis])`.",The index D_STRUCTURE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.gather,indices,"The index `Tensor`.  Must be one of the following types: `int32`,`int64`. Must be in range `[0, params.shape[axis])`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.gather,indices,"The index `Tensor`.  Must be one of the following types: `int32`,`int64`. Must be in range `[0, params.shape[axis])`.",Must be in range CONSTANT_NUM PARAM shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.while_loop,back_prop,Whether backprop is enabled for this while loop.,Whether backprop is enabled for this while loop,D_TYPE,,,,CONSTANT_VAL,,
tf.while_loop,back_prop,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.add_metrics,metric_fn,"A function which should obey the following signature: Args: can only have following four arguments in any order:predictions: Predictions `Tensor` or dict of `Tensor` created by given`estimator`.features: Input `dict` of `Tensor` objects created by `input_fn` which is given to `estimator.evaluate` as an argument.labels:  Labels `Tensor` or dict of `Tensor` created by `input_fn`which is given to `estimator.evaluate` as an argument.config: config attribute of the `estimator`.Returns: Dict of metric results keyed by name. Final metrics are a union of this and `estimator's` existing metrics. If there is a name conflict between this and `estimator`s existing metrics, this will override the existing one. The values of the dict are the results of calling a metric function, namely a `(metric_tensor, update_op)` tuple. ",A function which should obey the following signature Args can only have following four arguments in any order predictions Predictions D_STRUCTURE of D_STRUCTURE created by given PARAM features Input D_STRUCTURE of D_STRUCTURE objects created by QSTR which is given to PARAM evaluate as an argument labels Labels D_STRUCTURE of D_STRUCTURE created by QSTR which is given to PARAM evaluate as an argument config config attribute of the PARAM Returns D_STRUCTURE of metric results keyed by name,,,,,,,
tf.estimator.add_metrics,metric_fn,"A function which should obey the following signature: Args: can only have following four arguments in any order:predictions: Predictions `Tensor` or dict of `Tensor` created by given`estimator`.features: Input `dict` of `Tensor` objects created by `input_fn` which is given to `estimator.evaluate` as an argument.labels:  Labels `Tensor` or dict of `Tensor` created by `input_fn`which is given to `estimator.evaluate` as an argument.config: config attribute of the `estimator`.Returns: Dict of metric results keyed by name. Final metrics are a union of this and `estimator's` existing metrics. If there is a name conflict between this and `estimator`s existing metrics, this will override the existing one. The values of the dict are the results of calling a metric function, namely a `(metric_tensor, update_op)` tuple. ",Final metrics are a union of this and PARAMs existing metrics,,,,,,,
tf.estimator.add_metrics,metric_fn,"A function which should obey the following signature: Args: can only have following four arguments in any order:predictions: Predictions `Tensor` or dict of `Tensor` created by given`estimator`.features: Input `dict` of `Tensor` objects created by `input_fn` which is given to `estimator.evaluate` as an argument.labels:  Labels `Tensor` or dict of `Tensor` created by `input_fn`which is given to `estimator.evaluate` as an argument.config: config attribute of the `estimator`.Returns: Dict of metric results keyed by name. Final metrics are a union of this and `estimator's` existing metrics. If there is a name conflict between this and `estimator`s existing metrics, this will override the existing one. The values of the dict are the results of calling a metric function, namely a `(metric_tensor, update_op)` tuple. ",If there is a name conflict between this and PARAMs existing metrics this will override the existing one,,,,,,,
tf.estimator.add_metrics,metric_fn,"A function which should obey the following signature: Args: can only have following four arguments in any order:predictions: Predictions `Tensor` or dict of `Tensor` created by given`estimator`.features: Input `dict` of `Tensor` objects created by `input_fn` which is given to `estimator.evaluate` as an argument.labels:  Labels `Tensor` or dict of `Tensor` created by `input_fn`which is given to `estimator.evaluate` as an argument.config: config attribute of the `estimator`.Returns: Dict of metric results keyed by name. Final metrics are a union of this and `estimator's` existing metrics. If there is a name conflict between this and `estimator`s existing metrics, this will override the existing one. The values of the dict are the results of calling a metric function, namely a `(metric_tensor, update_op)` tuple. ",The values of the D_STRUCTURE are the results of calling a metric function namely a BSTR D_STRUCTURE,,,,,,,
tf.random.all_candidate_sampler,seed,An `int`. An operation-specific seed. Default is 0.,An D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.random.all_candidate_sampler,seed,An `int`. An operation-specific seed. Default is 0.,An operation specific seed,D_TYPE,,,,CONSTANT_VAL,,
tf.random.all_candidate_sampler,seed,An `int`. An operation-specific seed. Default is 0.,Default is CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.random.all_candidate_sampler,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.compute_average_loss,per_example_loss,Per-example loss.,Per example loss,,,,,,,
tf.nn.dilation2d,data_format,"A `string`, only `""NHWC""` is currently supported.",A D_TYPE only QSTR is currently supported,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.math.cumprod,reverse,A `bool` (default: False).,A D_TYPE default CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.cumprod,reverse,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.tanh,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.tanh,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.weighted_moments,axes,1-d tensor of int32 values; these are the axes along which to compute mean and variance.,CONSTANT_NUM d D_STRUCTURE of D_TYPE values these are the axes along which to compute mean and variance,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.unstack,value,A rank `R > 0` `Tensor` to be unstacked.,A rank R REXPR D_STRUCTURE to be unstacked,,,,,CONSTANT_VAL,,
tf.random.fixed_unigram_candidate_sampler,num_shards,A sampler can be used to sample from a subset of the original range in order to speed up the whole computation through parallelism. This parameter (together with `shard`) indicates the number of partitions that are being used in the overall computation.,A sampler can be used to sample from a subset of the original range in order to speed up the whole computation through parallelism,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.random.fixed_unigram_candidate_sampler,num_shards,A sampler can be used to sample from a subset of the original range in order to speed up the whole computation through parallelism. This parameter (together with `shard`) indicates the number of partitions that are being used in the overall computation.,This parameter BSTR indicates the number of partitions that are being used in the overall computation,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.random.fixed_unigram_candidate_sampler,num_shards,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.broadcast_to,shape,"A `Tensor`. Must be one of the following types: `int32`, `int64`. An 1-D `int` Tensor. The shape of the desired output.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.broadcast_to,shape,"A `Tensor`. Must be one of the following types: `int32`, `int64`. An 1-D `int` Tensor. The shape of the desired output.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.broadcast_to,shape,"A `Tensor`. Must be one of the following types: `int32`, `int64`. An 1-D `int` Tensor. The shape of the desired output.",An CONSTANT_NUM D D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.broadcast_to,shape,"A `Tensor`. Must be one of the following types: `int32`, `int64`. An 1-D `int` Tensor. The shape of the desired output.",The shape of the desired output,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.square,x,Tensor or variable.,D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.histogram_fixed_width_bins,dtype,dtype for returned histogram.,dtype for returned histogram,D_TYPE,,,,CONSTANT_VAL,,
tf.histogram_fixed_width_bins,dtype,DF: tf.dtypes.int32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.placeholder,ndim,"Number of axes of the tensor. At least one of {`shape`, `ndim`} must be specified. If both are specified, `shape` is used.",Number of axes of the D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.placeholder,ndim,"Number of axes of the tensor. At least one of {`shape`, `ndim`} must be specified. If both are specified, `shape` is used.",At least one of PARAM QSTR must be specified,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.placeholder,ndim,"Number of axes of the tensor. At least one of {`shape`, `ndim`} must be specified. If both are specified, `shape` is used.",If both are specified PARAM is used,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.placeholder,ndim,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_batched_features_dataset,reader,A function or class that can be called with a `filenames` tensor and (optional) `reader_args` and returns a `Dataset` of `Example` tensors. Defaults to `tf.data.TFRecordDataset`.,A function or class that can be called with a QSTR D_STRUCTURE and BSTR PARAM and returns a QSTR of QSTR D_STRUCTURE,,,,,,,
tf.data.experimental.make_batched_features_dataset,reader,A function or class that can be called with a `filenames` tensor and (optional) `reader_args` and returns a `Dataset` of `Example` tensors. Defaults to `tf.data.TFRecordDataset`.,Defaults to tf data TFRecordDataset,,,,,,,
tf.data.experimental.make_batched_features_dataset,reader,DF: None,DEFAULT None,,,,,,,
tf.config.experimental_connect_to_cluster,cluster_spec_or_resolver,A `ClusterSpec` or `ClusterResolver` describing the cluster.,A QSTR describing the cluster,,,,,,,
tf.image.rgb_to_hsv,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.image.rgb_to_hsv,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.weighted_categorical_column,weight_feature_key,String key for weight values.,D_TYPE key for weight values,D_TYPE,,,,CONSTANT_VAL,,
tf.image.draw_bounding_boxes,colors,A `Tensor` of type `float32`. 2-D. A list of RGBA colors to cycle through for the boxes.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,D_STRUCTURE,,,,
tf.image.draw_bounding_boxes,colors,A `Tensor` of type `float32`. 2-D. A list of RGBA colors to cycle through for the boxes.,CONSTANT_NUM D A D_STRUCTURE of RGBA colors to cycle through for the PARAM,D_TYPE,D_STRUCTURE,D_STRUCTURE,,,,
tf.debugging.enable_check_numerics,path_length_limit,Limit to the file path included in the printed stack trace. Applicable only to ops in `tf.function`s (graphs).,Limit to the file path included in the printed stack trace,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.enable_check_numerics,path_length_limit,Limit to the file path included in the printed stack trace. Applicable only to ops in `tf.function`s (graphs).,Applicable only to ops in tf function BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.enable_check_numerics,path_length_limit,DF: 50,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,padding,"one of `""valid""` or `""same""` (case-insensitive).",one of QSTR BSTR,D_TYPE,,,,,,QSTR
tf.keras.layers.Conv3DTranspose,padding,DF: valid,DEFAULT DF_STR,D_TYPE,,,,,,QSTR
tf.signal.fftshift,axes,"`int` or shape `tuple`, optional Axes over which to shift.  Default is None, which shifts all axes.",D_TYPE or shape D_STRUCTURE optional Axes over which to shift,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.signal.fftshift,axes,"`int` or shape `tuple`, optional Axes over which to shift.  Default is None, which shifts all axes.",Default is None which shifts all axes,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.signal.fftshift,axes,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.LSTM,kernel_initializer,"Initializer for the `kernel` weights matrix, used for the linear transformation of the inputs. Default: `glorot_uniform`.",Initializer for the QSTR weights matrix used for the linear transformation of the inputs,D_TYPE,,,,,,
tf.keras.layers.LSTM,kernel_initializer,"Initializer for the `kernel` weights matrix, used for the linear transformation of the inputs. Default: `glorot_uniform`.",Default QSTR,D_TYPE,,,,,,
tf.keras.layers.LSTM,kernel_initializer,DF: glorot_uniform,DEFAULT DF_STR,D_TYPE,,,,,,
tf.ones,name,Optional string. A name for the operation.,Optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.ones,name,Optional string. A name for the operation.,A name for the operation,D_TYPE,,,,CONSTANT_VAL,,
tf.ones,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.gfile.walk,topdown,"bool, Traverse pre order if True, post order if False.",D_TYPE Traverse pre order if CONSTANT_BOOL post order if CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.io.gfile.walk,topdown,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.slice,begin,An `int32` or `int64` `Tensor`.,An D_TYPE D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.nn.atrous_conv2d,filters,"A 4-D `Tensor` with the same type as `value` and shape`[filter_height, filter_width, in_channels, out_channels]`. `filters`'`in_channels` dimension must match that of `value`. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height `filter_height + (filter_height - 1) * (rate - 1)` and effective width `filter_width + (filter_width - 1) * (rate - 1)`, produced by inserting `rate - 1` zeros along consecutive elements across the`filters`' spatial dimensions.",A CONSTANT_NUM D D_STRUCTURE with the same type as PARAM and shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.atrous_conv2d,filters,"A 4-D `Tensor` with the same type as `value` and shape`[filter_height, filter_width, in_channels, out_channels]`. `filters`'`in_channels` dimension must match that of `value`. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height `filter_height + (filter_height - 1) * (rate - 1)` and effective width `filter_width + (filter_width - 1) * (rate - 1)`, produced by inserting `rate - 1` zeros along consecutive elements across the`filters`' spatial dimensions.",QSTR in_channels dimension must match that of PARAM,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.atrous_conv2d,filters,"A 4-D `Tensor` with the same type as `value` and shape`[filter_height, filter_width, in_channels, out_channels]`. `filters`'`in_channels` dimension must match that of `value`. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height `filter_height + (filter_height - 1) * (rate - 1)` and effective width `filter_width + (filter_width - 1) * (rate - 1)`, produced by inserting `rate - 1` zeros along consecutive elements across the`filters`' spatial dimensions.",Atrous convolution is equivalent to standard convolution with upsampled filters with effective height QSTR filter_width BSTR produced by inserting PARAM CONSTANT_NUM zeros along consecutive elements across the QSTR spatial dimensions,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.debugging.assert_none_equal,name,"A name for this operation (optional).  Defaults to ""assert_none_equal"".",A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_none_equal,name,"A name for this operation (optional).  Defaults to ""assert_none_equal"".",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_none_equal,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.cumprod,x,A tensor or variable.,A D_STRUCTURE or variable,,D_STRUCTURE,,,,,
tf.signal.dct,norm,The normalization to apply. `None` for no normalization or `'ortho'`for orthonormal normalization.,The normalization to apply,,,,,,,
tf.signal.dct,norm,The normalization to apply. `None` for no normalization or `'ortho'`for orthonormal normalization.,QSTR for no normalization or QSTR for orthonormal normalization,,,,,,,
tf.signal.dct,norm,DF: None,DEFAULT None,,,,,,,
tf.extract_volume_patches,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.extract_volume_patches,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv_transpose,output_shape,A 1-D `Tensor` representing the output shape of the deconvolution op.,A CONSTANT_NUM D D_STRUCTURE representing the output shape of the deconvolution op,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.Dense,kernel_initializer,Initializer for the `kernel` weights matrix.,Initializer for the QSTR weights matrix,D_TYPE,,,,,,
tf.keras.layers.Dense,kernel_initializer,DF: glorot_uniform,DEFAULT DF_STR,D_TYPE,,,,,,
tf.math.nextafter,x2,A `Tensor`. Must have the same type as `x1`.,A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.nextafter,x2,A `Tensor`. Must have the same type as `x1`.,Must have the same type as PARAM,D_TYPE,D_STRUCTURE,,,,,
tf.nn.fractional_avg_pool,overlapping,"An optional `bool`.  Defaults to `False`.  When set to `True`, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:`index  0  1  2  3  4``value  20 5  16 3  7`If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.  The result would be [20, 16] for fractional avg pooling.",An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,overlapping,"An optional `bool`.  Defaults to `False`.  When set to `True`, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:`index  0  1  2  3  4``value  20 5  16 3  7`If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.  The result would be [20, 16] for fractional avg pooling.",Defaults to CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,overlapping,"An optional `bool`.  Defaults to `False`.  When set to `True`, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:`index  0  1  2  3  4``value  20 5  16 3  7`If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.  The result would be [20, 16] for fractional avg pooling.",When set to CONSTANT_BOOL it means when pooling the values at the boundary of adjacent pooling cells are used by both cells,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,overlapping,"An optional `bool`.  Defaults to `False`.  When set to `True`, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:`index  0  1  2  3  4``value  20 5  16 3  7`If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.  The result would be [20, 16] for fractional avg pooling.",For example index CONSTANT_NUM CONSTANT_NUM CONSTANT_NUM CONSTANT_NUM CONSTANT_NUM PARAM CONSTANT_NUM0 CONSTANT_NUM CONSTANT_NUM6 CONSTANT_NUM CONSTANT_NUMIf the pooling D_STRUCTURE is BSTR then CONSTANT_NUM6 at index CONSTANT_NUM will be used twice,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,overlapping,"An optional `bool`.  Defaults to `False`.  When set to `True`, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:`index  0  1  2  3  4``value  20 5  16 3  7`If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.  The result would be [20, 16] for fractional avg pooling.",The result would be BSTR for fractional avg pooling,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.fractional_avg_pool,overlapping,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.ctc_beam_search_decoder,inputs,"3-D `float` `Tensor`, size `[max_time, batch_size, num_classes]`. The logits.",CONSTANT_NUM D D_TYPE D_STRUCTURE size BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.nn.ctc_beam_search_decoder,inputs,"3-D `float` `Tensor`, size `[max_time, batch_size, num_classes]`. The logits.",The logits,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.sparse.reduce_sum,keepdims,"If true, retain reduced dimensions with length 1.",If CONSTANT_BOOL retain reduced dimensions with length CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.reduce_sum,keepdims,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.image.non_max_suppression_overlaps,scores,A 1-D float `Tensor` of shape `[num_boxes]` representing a single score corresponding to each box (each row of boxes).,A CONSTANT_NUM D D_TYPE D_STRUCTURE of shape BSTR representing a single score corresponding to each box BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.io.decode_proto,descriptor_source,"An optional `string`. Defaults to `""local://""`. Either the special value `local://` or a path to a file containing a serialized `FileDescriptorSet`.",An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_proto,descriptor_source,"An optional `string`. Defaults to `""local://""`. Either the special value `local://` or a path to a file containing a serialized `FileDescriptorSet`.",Defaults to local,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_proto,descriptor_source,"An optional `string`. Defaults to `""local://""`. Either the special value `local://` or a path to a file containing a serialized `FileDescriptorSet`.",Either the special value local QSTR FileDescriptorSet,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_proto,descriptor_source,DF: local://,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.cross_hashed,hash_key,"Integer hash_key that will be used by the `FingerprintCat64`function. If not given, will use a default key.",D_TYPE hash_key that will be used by the QSTR function,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.cross_hashed,hash_key,"Integer hash_key that will be used by the `FingerprintCat64`function. If not given, will use a default key.",If not given will use a default key,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.cross_hashed,hash_key,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.foldr,back_prop,(optional) True enables support for back propagation.,BSTR CONSTANT_BOOL enables support for back propagation,D_TYPE,,,,CONSTANT_VAL,,
tf.foldr,back_prop,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.histogram_fixed_width,value_range,"Shape [2] `Tensor` of same `dtype` as `values`. values <= value_range[0] will be mapped to hist[0], values >= value_range[1] will be mapped to hist[-1].",Shape BSTR D_STRUCTURE of same PARAM as PARAM,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.histogram_fixed_width,value_range,"Shape [2] `Tensor` of same `dtype` as `values`. values <= value_range[0] will be mapped to hist[0], values >= value_range[1] will be mapped to hist[-1].",PARAM REXPR BSTR will be mapped to hist BSTR PARAM REXPR BSTR will be mapped to hist BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.std,axis,"An integer, the axis to compute the standard deviation.",An D_TYPE the axis to compute the standard deviation,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.std,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,return_state,Boolean. Whether to return the last state in addition to the output. Default: `False`.,ONE_WORD D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,return_state,Boolean. Whether to return the last state in addition to the output. Default: `False`.,Whether to return the last state in addition to the output,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,return_state,Boolean. Whether to return the last state in addition to the output. Default: `False`.,Default CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,return_state,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRUCell,reset_after,"GRU convention (whether to apply reset gate after or before matrix multiplication). False = ""before"", True = ""after"" (default and CuDNN compatible).",GRU convention BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRUCell,reset_after,"GRU convention (whether to apply reset gate after or before matrix multiplication). False = ""before"", True = ""after"" (default and CuDNN compatible).",CONSTANT_BOOL QSTR CONSTANT_BOOL QSTR BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRUCell,reset_after,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ThresholdedReLU,theta,Float >= 0. Threshold location of activation.,D_TYPE REXPR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ThresholdedReLU,theta,Float >= 0. Threshold location of activation.,Threshold location of activation,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ThresholdedReLU,theta,DF: 1.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.categorical_column_with_vocabulary_list,vocabulary_list,An ordered iterable defining the vocabulary. Each feature is mapped to the index of its value (if present) in `vocabulary_list`. Must be castable to `dtype`.,An ordered D_STRUCTURE defining the vocabulary,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.feature_column.categorical_column_with_vocabulary_list,vocabulary_list,An ordered iterable defining the vocabulary. Each feature is mapped to the index of its value (if present) in `vocabulary_list`. Must be castable to `dtype`.,Each feature is mapped to the index of its value BSTR in QSTR,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.feature_column.categorical_column_with_vocabulary_list,vocabulary_list,An ordered iterable defining the vocabulary. Each feature is mapped to the index of its value (if present) in `vocabulary_list`. Must be castable to `dtype`.,Must be castable to PARAM,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.clip_by_norm,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.clip_by_norm,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.clip_by_value,clip_value_min,"A 0-D (scalar) `Tensor`, or a `Tensor` with the same shape as `t`. The minimum value to clip by.",A CONSTANT_NUM D BSTR D_STRUCTURE with the same shape as QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,
tf.clip_by_value,clip_value_min,"A 0-D (scalar) `Tensor`, or a `Tensor` with the same shape as `t`. The minimum value to clip by.",The minimum value to clip by,D_TYPE,,,BSTR,CONSTANT_VAL,,
tf.space_to_batch_nd,paddings,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 2-D with shape `[M, 2]`, all values must be >= 0.`paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension`i + 1`, which corresponds to spatial dimension `i`.  It is required that`block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.This operation is equivalent to the following steps: Zero-pad the start and end of dimensions `[1, ..., M]` of the input according to `paddings` to produce `padded` of shape `padded_shape`.Reshape `padded` to `reshaped_padded` of shape:[batch] + [padded_shape[1] / block_shape[0],  block_shape[0], ..., padded_shape[M] / block_shape[M-1], block_shape[M-1]] + remaining_shapePermute dimensions of `reshaped_padded` to produce`permuted_reshaped_padded` of shape:block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shapeReshape `permuted_reshaped_padded` to flatten `block_shape` into the batch dimension, producing an output tensor of shape:[batch * prod(block_shape)] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape Some examples:(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and   `paddings = [[0, 0], [0, 0]]`:",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.space_to_batch_nd,paddings,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 2-D with shape `[M, 2]`, all values must be >= 0.`paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension`i + 1`, which corresponds to spatial dimension `i`.  It is required that`block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.This operation is equivalent to the following steps: Zero-pad the start and end of dimensions `[1, ..., M]` of the input according to `paddings` to produce `padded` of shape `padded_shape`.Reshape `padded` to `reshaped_padded` of shape:[batch] + [padded_shape[1] / block_shape[0],  block_shape[0], ..., padded_shape[M] / block_shape[M-1], block_shape[M-1]] + remaining_shapePermute dimensions of `reshaped_padded` to produce`permuted_reshaped_padded` of shape:block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shapeReshape `permuted_reshaped_padded` to flatten `block_shape` into the batch dimension, producing an output tensor of shape:[batch * prod(block_shape)] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape Some examples:(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and   `paddings = [[0, 0], [0, 0]]`:",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.space_to_batch_nd,paddings,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 2-D with shape `[M, 2]`, all values must be >= 0.`paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension`i + 1`, which corresponds to spatial dimension `i`.  It is required that`block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.This operation is equivalent to the following steps: Zero-pad the start and end of dimensions `[1, ..., M]` of the input according to `paddings` to produce `padded` of shape `padded_shape`.Reshape `padded` to `reshaped_padded` of shape:[batch] + [padded_shape[1] / block_shape[0],  block_shape[0], ..., padded_shape[M] / block_shape[M-1], block_shape[M-1]] + remaining_shapePermute dimensions of `reshaped_padded` to produce`permuted_reshaped_padded` of shape:block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shapeReshape `permuted_reshaped_padded` to flatten `block_shape` into the batch dimension, producing an output tensor of shape:[batch * prod(block_shape)] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape Some examples:(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and   `paddings = [[0, 0], [0, 0]]`:",CONSTANT_NUM D with shape BSTR all values must be REXPRpaddings BSTR BSTR specifies the padding for PARAM dimension i CONSTANT_NUM which corresponds to spatial dimension QSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.space_to_batch_nd,paddings,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 2-D with shape `[M, 2]`, all values must be >= 0.`paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension`i + 1`, which corresponds to spatial dimension `i`.  It is required that`block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.This operation is equivalent to the following steps: Zero-pad the start and end of dimensions `[1, ..., M]` of the input according to `paddings` to produce `padded` of shape `padded_shape`.Reshape `padded` to `reshaped_padded` of shape:[batch] + [padded_shape[1] / block_shape[0],  block_shape[0], ..., padded_shape[M] / block_shape[M-1], block_shape[M-1]] + remaining_shapePermute dimensions of `reshaped_padded` to produce`permuted_reshaped_padded` of shape:block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shapeReshape `permuted_reshaped_padded` to flatten `block_shape` into the batch dimension, producing an output tensor of shape:[batch * prod(block_shape)] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape Some examples:(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and   `paddings = [[0, 0], [0, 0]]`:",It is required that PARAM BSTR divides QSTR This operation is equivalent to the following steps Zero pad the start and end of dimensions BSTR of the PARAM according to QSTR to produce QSTR of shape QSTR Reshape QSTR to QSTR of shape BSTR padded_shape BSTR PARAM BSTR PARAM BSTR padded_shape BSTR PARAM BSTR PARAM BSTR remaining_shapePermute dimensions of QSTR to produce QSTR of shape PARAM BSTR padded_shape BSTR PARAM BSTR padded_shape BSTR PARAM BSTR remaining_shapeReshape QSTR to flatten PARAM into the batch dimension producing an output D_STRUCTURE of shape BSTR padded_shape BSTR PARAM BSTR padded_shape BSTR PARAM BSTR remaining_shape Some examples BSTR For the following PARAM of shape BSTR PARAM BSTR and paddings BSTR BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.one_hot,indices,"nD integer tensor of shape`(batch_size, dim1, dim2, ... dim(n-1))`",nD D_TYPE D_STRUCTURE of shape BSTR,D_TYPE,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.ragged.stack_dynamic_partitions,data,A `Tensor` or `RaggedTensor` containing the values to stack.,A D_STRUCTURE or QSTR containing the values to stack,,D_STRUCTURE,,,,,
tf.keras.layers.BatchNormalization,center,"If True, add offset of `beta` to normalized tensor. If False, `beta` is ignored.",If CONSTANT_BOOL add offset of QSTR to normalized D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.BatchNormalization,center,"If True, add offset of `beta` to normalized tensor. If False, `beta` is ignored.",If CONSTANT_BOOL QSTR is ignored,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.BatchNormalization,center,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.depthwise_conv2d,name,A name for this operation (optional).,A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.depthwise_conv2d,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.Input,**kwargs,deprecated arguments support. Supports `batch_shape` and`batch_input_shape`.,deprecated arguments support,,,,,,,
tf.keras.Input,**kwargs,deprecated arguments support. Supports `batch_shape` and`batch_input_shape`.,Supports QSTR,,,,,,,
tf.feature_column.numeric_column,key,"A unique string identifying the input feature. It is used as the column name and the dictionary key for feature parsing configs, feature`Tensor` objects, and feature columns.",A unique D_TYPE identifying the input feature,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.numeric_column,key,"A unique string identifying the input feature. It is used as the column name and the dictionary key for feature parsing configs, feature`Tensor` objects, and feature columns.",It is used as the column name and the D_STRUCTURE key for feature parsing configs featureD_STRUCTURE objects and feature columns,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.UpSampling2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",A D_TYPE one of QSTR BSTR or QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",The ordering of the dimensions in the inputs QSTR corresponds to inputs with shape BSTR while QSTR corresponds to inputs with shape BSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",It defaults to the QSTR value found in your Keras config file at keras keras json,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling2D,data_format,"A string, one of `channels_last` (default) or `channels_first`. The ordering of the dimensions in the inputs.`channels_last` corresponds to inputs with shape`(batch, height, width, channels)` while `channels_first`corresponds to inputs with shape`(batch, channels, height, width)`. It defaults to the `image_data_format` value found in your Keras config file at `~/.keras/keras.json`. If you never set it, then it will be ""channels_last"".",If you never set it then it will be QSTR,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling2D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.tensor_scatter_nd_add,tensor,A `Tensor`. Tensor to copy/update.,A D_STRUCTURE,,D_STRUCTURE,,,,,
tf.tensor_scatter_nd_add,tensor,A `Tensor`. Tensor to copy/update.,D_STRUCTURE to copy update,,D_STRUCTURE,,,,,
tf.math.cumulative_logsumexp,x,"A `Tensor`. Must be one of the following types: `float16`, `float32`,`float64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.math.cumulative_logsumexp,x,"A `Tensor`. Must be one of the following types: `float16`, `float32`,`float64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.fingerprint,method,A `Tensor` of type `tf.string`. Fingerprint method used by this op. Currently available method is `farmhash64`.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.fingerprint,method,A `Tensor` of type `tf.string`. Fingerprint method used by this op. Currently available method is `farmhash64`.,Fingerprint method used by this op,D_TYPE,D_STRUCTURE,,,,,
tf.fingerprint,method,A `Tensor` of type `tf.string`. Fingerprint method used by this op. Currently available method is `farmhash64`.,Currently available method is QSTR,D_TYPE,D_STRUCTURE,,,,,
tf.fingerprint,method,DF: farmhash64,DEFAULT DF_STR,D_TYPE,D_STRUCTURE,,,,,
tf.xla.experimental.jit_scope,separate_compiled_gradients,"If true put each gradient subgraph into a separate compilation scope. This gives fine-grained control over which portions of the graph will be compiled as a single unit. Compiling gradients separately may yield better performance for some graphs. The scope is named based on the scope of the forward computation as well as the name of the gradients. As a result, the gradients will be compiled in a scope that is separate from both the forward computation, and from other gradients.",If CONSTANT_BOOL put each gradient subgraph into a separate compilation scope,D_TYPE,,,,CONSTANT_VAL,,
tf.xla.experimental.jit_scope,separate_compiled_gradients,"If true put each gradient subgraph into a separate compilation scope. This gives fine-grained control over which portions of the graph will be compiled as a single unit. Compiling gradients separately may yield better performance for some graphs. The scope is named based on the scope of the forward computation as well as the name of the gradients. As a result, the gradients will be compiled in a scope that is separate from both the forward computation, and from other gradients.",This gives fine grained control over which portions of the graph will be compiled as a single unit,D_TYPE,,,,CONSTANT_VAL,,
tf.xla.experimental.jit_scope,separate_compiled_gradients,"If true put each gradient subgraph into a separate compilation scope. This gives fine-grained control over which portions of the graph will be compiled as a single unit. Compiling gradients separately may yield better performance for some graphs. The scope is named based on the scope of the forward computation as well as the name of the gradients. As a result, the gradients will be compiled in a scope that is separate from both the forward computation, and from other gradients.",Compiling gradients separately may yield better performance for some graphs,D_TYPE,,,,CONSTANT_VAL,,
tf.xla.experimental.jit_scope,separate_compiled_gradients,"If true put each gradient subgraph into a separate compilation scope. This gives fine-grained control over which portions of the graph will be compiled as a single unit. Compiling gradients separately may yield better performance for some graphs. The scope is named based on the scope of the forward computation as well as the name of the gradients. As a result, the gradients will be compiled in a scope that is separate from both the forward computation, and from other gradients.",The scope is named based on the scope of the forward computation as well as the name of the gradients,D_TYPE,,,,CONSTANT_VAL,,
tf.xla.experimental.jit_scope,separate_compiled_gradients,"If true put each gradient subgraph into a separate compilation scope. This gives fine-grained control over which portions of the graph will be compiled as a single unit. Compiling gradients separately may yield better performance for some graphs. The scope is named based on the scope of the forward computation as well as the name of the gradients. As a result, the gradients will be compiled in a scope that is separate from both the forward computation, and from other gradients.",As a result the gradients will be compiled in a scope that is separate from both the forward computation and from other gradients,D_TYPE,,,,CONSTANT_VAL,,
tf.xla.experimental.jit_scope,separate_compiled_gradients,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.image.sample_distorted_bounding_box,seed,"An optional `int`. Defaults to `0`. If `seed` is set to non-zero, the random number generator is seeded by the given `seed`.  Otherwise, it is seeded by a random seed.",An optional D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.image.sample_distorted_bounding_box,seed,"An optional `int`. Defaults to `0`. If `seed` is set to non-zero, the random number generator is seeded by the given `seed`.  Otherwise, it is seeded by a random seed.",Defaults to CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.image.sample_distorted_bounding_box,seed,"An optional `int`. Defaults to `0`. If `seed` is set to non-zero, the random number generator is seeded by the given `seed`.  Otherwise, it is seeded by a random seed.",If QSTR is set to non zero the random number generator is seeded by the given QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.image.sample_distorted_bounding_box,seed,"An optional `int`. Defaults to `0`. If `seed` is set to non-zero, the random number generator is seeded by the given `seed`.  Otherwise, it is seeded by a random seed.",Otherwise it is seeded by a random seed,D_TYPE,,,,CONSTANT_VAL,,
tf.image.sample_distorted_bounding_box,seed,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.nest.assert_same_structure,nest2,an arbitrarily nested structure.,an arbitrarily nested structure,,,,,,,
tf.strings.ngrams,separator,"The separator string used between ngram elements. Must be a string constant, not a Tensor.",The separator D_TYPE used between ngram elements,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.ngrams,separator,"The separator string used between ngram elements. Must be a string constant, not a Tensor.",Must be a D_TYPE constant not a D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.ngrams,separator,DF:  , ,D_TYPE,,,,CONSTANT_VAL,,
tf.bitwise.bitwise_xor,x,"A `Tensor`. Must be one of the following types: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`.",A D_STRUCTURE,D_TYPE,D_STRUCTURE,,,,,
tf.bitwise.bitwise_xor,x,"A `Tensor`. Must be one of the following types: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`.",Must be one of the following types D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.linalg.diag,k,"Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main diagonal, and negative value means subdiagonals. `k` can be a single integer (for a single diagonal) or a pair of integers specifying the low and high ends of a matrix band. `k[0]` must not be larger than `k[1]`.",PARAM offset BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.diag,k,"Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main diagonal, and negative value means subdiagonals. `k` can be a single integer (for a single diagonal) or a pair of integers specifying the low and high ends of a matrix band. `k[0]` must not be larger than `k[1]`.",Positive value means superdiagonal CONSTANT_NUM refers to the main PARAM and negative value means subdiagonals,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.diag,k,"Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main diagonal, and negative value means subdiagonals. `k` can be a single integer (for a single diagonal) or a pair of integers specifying the low and high ends of a matrix band. `k[0]` must not be larger than `k[1]`.",QSTR can be a single D_TYPE BSTR or a pair of D_TYPE specifying the low and high ends of a matrix band,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.diag,k,"Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main diagonal, and negative value means subdiagonals. `k` can be a single integer (for a single diagonal) or a pair of integers specifying the low and high ends of a matrix band. `k[0]` must not be larger than `k[1]`.",QSTR k BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.diag,k,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.image.crop_and_resize,boxes,"A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.",A CONSTANT_NUM D D_STRUCTURE of shape BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.image.crop_and_resize,boxes,"A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.",The QSTR th row of the D_STRUCTURE specifies the coordinates of a box in the box_ind BSTR PARAM and is specified in normalized coordinates BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.image.crop_and_resize,boxes,"A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.",A normalized coordinate value of QSTR is mapped to the PARAM coordinate at y BSTR so as the BSTR interval of normalized PARAM height is mapped to BSTR in PARAM height coordinates,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.image.crop_and_resize,boxes,"A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.",We do allow QSTR QSTR in which case the sampled crop is an up down flipped version of the original PARAM,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.image.crop_and_resize,boxes,"A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.",The width dimension is treated similarly,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.image.crop_and_resize,boxes,"A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.",Normalized coordinates outside the BSTR range are allowed in which case we use PARAM to extrapolate the input PARAM values,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.config.experimental.set_synchronous_execution,enable,Whether operations should be dispatched synchronously. Valid values: None: sets the system default.True: executes each operation synchronously.False: executes each operation asynchronously. ,Whether operations should be dispatched synchronously,D_TYPE,,,,,,
tf.config.experimental.set_synchronous_execution,enable,Whether operations should be dispatched synchronously. Valid values: None: sets the system default.True: executes each operation synchronously.False: executes each operation asynchronously. ,Valid values None sets the system default CONSTANT_BOOL executes each operation synchronously CONSTANT_BOOL executes each operation asynchronously,D_TYPE,,,,,,
tf.keras.layers.GRU,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,D_TYPE between CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,Fraction of the PARAM to drop for the linear transformation of the inputs,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,dropout,Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.,Default CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.GRU,dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Dense,use_bias,"Boolean, whether the layer uses a bias vector.",D_TYPE whether the layer uses a bias vector,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Dense,use_bias,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_non_negative,name,"A name for this operation (optional).  Defaults to ""assert_non_negative"".",A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_non_negative,name,"A name for this operation (optional).  Defaults to ""assert_non_negative"".",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_non_negative,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.in_top_k,k,"An `int`, number of top elements to consider.",An D_TYPE number of top elements to consider,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.DenseFeatures,feature_columns,"An iterable containing the FeatureColumns to use as inputs to your model. All items should be instances of classes derived from `DenseColumn` such as `numeric_column`, `embedding_column`,`bucketized_column`, `indicator_column`. If you have categorical features, you can wrap them with an `embedding_column` or`indicator_column`.",An D_STRUCTURE containing the FeatureColumns to use as inputs to your model,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.layers.DenseFeatures,feature_columns,"An iterable containing the FeatureColumns to use as inputs to your model. All items should be instances of classes derived from `DenseColumn` such as `numeric_column`, `embedding_column`,`bucketized_column`, `indicator_column`. If you have categorical features, you can wrap them with an `embedding_column` or`indicator_column`.",All items should be instances of classes derived from QSTR such as QSTR,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.layers.DenseFeatures,feature_columns,"An iterable containing the FeatureColumns to use as inputs to your model. All items should be instances of classes derived from `DenseColumn` such as `numeric_column`, `embedding_column`,`bucketized_column`, `indicator_column`. If you have categorical features, you can wrap them with an `embedding_column` or`indicator_column`.",If you have categorical features you can wrap them with an QSTR,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.layers.Attention,use_scale,"If `True`, will create a scalar variable to scale the attention scores.",If CONSTANT_BOOL will create a scalar variable to scale the attention scores,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Attention,use_scale,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,compression_type,"(Optional.) A `tf.string` scalar evaluating to one of`""""` (no compression), `""ZLIB""`, or `""GZIP""`. Defaults to no compression.",ONE_WORD BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,compression_type,"(Optional.) A `tf.string` scalar evaluating to one of`""""` (no compression), `""ZLIB""`, or `""GZIP""`. Defaults to no compression.",A D_TYPE scalar evaluating to one of BSTR QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,compression_type,"(Optional.) A `tf.string` scalar evaluating to one of`""""` (no compression), `""ZLIB""`, or `""GZIP""`. Defaults to no compression.",Defaults to no compression,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,compression_type,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.unique_with_counts,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.unique_with_counts,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_greater_equal,name,"A name for this operation (optional).  Defaults to ""assert_greater_equal"".",A name for this operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_greater_equal,name,"A name for this operation (optional).  Defaults to ""assert_greater_equal"".",Defaults to QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_greater_equal,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv1d_transpose,data_format,A string. `'NWC'` and `'NCW'` are supported.,A D_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.conv1d_transpose,data_format,A string. `'NWC'` and `'NCW'` are supported.,QSTR are supported,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.conv1d_transpose,data_format,DF: NWC,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.ragged.constant,row_splits_dtype,data type for the constructed `RaggedTensor`'s row_splits. One of `tf.int32` or `tf.int64`.,data type for the constructed QSTR row_splits,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.ragged.constant,row_splits_dtype,data type for the constructed `RaggedTensor`'s row_splits. One of `tf.int32` or `tf.int64`.,One of D_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.ragged.constant,row_splits_dtype,DF: tf.dtypes.int64,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.ragged.stack,values,"A list of `tf.Tensor` or `tf.RaggedTensor`.  May not be empty. All`values` must have the same rank and the same dtype; but unlike`tf.stack`, they can have arbitrary dimension sizes.",A D_STRUCTURE of D_STRUCTURE or tf RaggedTensor,,,D_STRUCTURE,,,,
tf.ragged.stack,values,"A list of `tf.Tensor` or `tf.RaggedTensor`.  May not be empty. All`values` must have the same rank and the same dtype; but unlike`tf.stack`, they can have arbitrary dimension sizes.",May not be empty,,,D_STRUCTURE,,,,
tf.ragged.stack,values,"A list of `tf.Tensor` or `tf.RaggedTensor`.  May not be empty. All`values` must have the same rank and the same dtype; but unlike`tf.stack`, they can have arbitrary dimension sizes.",All QSTR must have the same rank and the same dtype but unlike tf stack they can have arbitrary dimension sizes,,,D_STRUCTURE,,,,
tf.random.categorical,logits,"2-D Tensor with shape `[batch_size, num_classes]`.  Each slice`[i, :]` represents the unnormalized log-probabilities for all classes.",CONSTANT_NUM D D_STRUCTURE with shape BSTR,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.random.categorical,logits,"2-D Tensor with shape `[batch_size, num_classes]`.  Each slice`[i, :]` represents the unnormalized log-probabilities for all classes.",Each slice i represents the unnormalized log probabilities for all classes,,D_STRUCTURE,,BSTR,CONSTANT_VAL,,
tf.debugging.Assert,data,The tensors to print out when condition is false.,The D_STRUCTURE to print out when PARAM is CONSTANT_BOOL,,D_STRUCTURE,,,,,
tf.nn.RNNCellDropoutWrapper,dtype,"(optional) The `dtype` of the input, state, and output tensors. Required and used <strong>iff</strong> `variational_recurrent = True`.",BSTR The QSTR of the input state and output D_STRUCTURE,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.RNNCellDropoutWrapper,dtype,"(optional) The `dtype` of the input, state, and output tensors. Required and used <strong>iff</strong> `variational_recurrent = True`.",Required and used REXPR REXPR strong REXPR CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.RNNCellDropoutWrapper,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.experimental.terminate_keras_multiprocessing_pools,use_sigkill,Boolean of whether or not to perform a cleanup pass using SIGKILL.,D_TYPE of whether or not to perform a cleanup pass using SIGKILL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.experimental.terminate_keras_multiprocessing_pools,use_sigkill,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.DepthwiseConv2D,depthwise_initializer,Initializer for the depthwise kernel matrix.,Initializer for the depthwise kernel matrix,D_TYPE,,,,,,
tf.keras.layers.DepthwiseConv2D,depthwise_initializer,DF: glorot_uniform,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.layers.UpSampling2D,size,"Int, or tuple of 2 integers. The upsampling factors for rows and columns.",D_TYPE or D_STRUCTURE of CONSTANT_NUM D_TYPE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.UpSampling2D,size,"Int, or tuple of 2 integers. The upsampling factors for rows and columns.",The upsampling factors for rows and columns,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.UpSampling2D,size,"DF: (2, 2)",DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.LocallyConnected1D,implementation,"implementation mode, either `1`, `2`, or `3`.`1` loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.`2` stores layer weights in a dense but sparsely-populated 2D matrix and implements the forward pass as a single matrix-multiply. It uses a lot of RAM but performs few (large) ops.`3` stores layer weights in a sparse tensor and implements the forward pass as a single sparse matrix-multiply.How to choose:`1`: large, dense models,`2`: small models,`3`: large, sparse models,where ""large"" stands for large input/output activations (i.e. many `filters`, `input_filters`, large `input_size`,`output_size`), and ""sparse"" stands for few connections between inputs and outputs, i.e. small ratio`filters * input_filters * kernel_size / (input_size * strides)`, where inputs to and outputs of the layer are assumed to have shapes`(input_size, input_filters)`, `(output_size, filters)`respectively.It is recommended to benchmark each in the setting of interest to pick the most efficient one (in terms of speed and memory usage). Correct choice of implementation can lead to dramatic speed improvements (e.g. 50X), potentially at the expense of RAM.Also, only `padding=""valid""` is supported by `implementation=1`.",implementation mode either CONSTANT_NUM CONSTANT_NUM loops over input spatial locations to perform the forward pass,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,implementation,"implementation mode, either `1`, `2`, or `3`.`1` loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.`2` stores layer weights in a dense but sparsely-populated 2D matrix and implements the forward pass as a single matrix-multiply. It uses a lot of RAM but performs few (large) ops.`3` stores layer weights in a sparse tensor and implements the forward pass as a single sparse matrix-multiply.How to choose:`1`: large, dense models,`2`: small models,`3`: large, sparse models,where ""large"" stands for large input/output activations (i.e. many `filters`, `input_filters`, large `input_size`,`output_size`), and ""sparse"" stands for few connections between inputs and outputs, i.e. small ratio`filters * input_filters * kernel_size / (input_size * strides)`, where inputs to and outputs of the layer are assumed to have shapes`(input_size, input_filters)`, `(output_size, filters)`respectively.It is recommended to benchmark each in the setting of interest to pick the most efficient one (in terms of speed and memory usage). Correct choice of implementation can lead to dramatic speed improvements (e.g. 50X), potentially at the expense of RAM.Also, only `padding=""valid""` is supported by `implementation=1`.",It is memory efficient but performs a lot of BSTR ops CONSTANT_NUM stores layer weights in a dense but sparsely populated CONSTANT_NUM D matrix and implements the forward pass as a single matrix multiply,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,implementation,"implementation mode, either `1`, `2`, or `3`.`1` loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.`2` stores layer weights in a dense but sparsely-populated 2D matrix and implements the forward pass as a single matrix-multiply. It uses a lot of RAM but performs few (large) ops.`3` stores layer weights in a sparse tensor and implements the forward pass as a single sparse matrix-multiply.How to choose:`1`: large, dense models,`2`: small models,`3`: large, sparse models,where ""large"" stands for large input/output activations (i.e. many `filters`, `input_filters`, large `input_size`,`output_size`), and ""sparse"" stands for few connections between inputs and outputs, i.e. small ratio`filters * input_filters * kernel_size / (input_size * strides)`, where inputs to and outputs of the layer are assumed to have shapes`(input_size, input_filters)`, `(output_size, filters)`respectively.It is recommended to benchmark each in the setting of interest to pick the most efficient one (in terms of speed and memory usage). Correct choice of implementation can lead to dramatic speed improvements (e.g. 50X), potentially at the expense of RAM.Also, only `padding=""valid""` is supported by `implementation=1`.",It uses a lot of RAM but performs few BSTR ops CONSTANT_NUM stores layer weights in a sparse D_STRUCTURE and implements the forward pass as a single sparse matrix multiply How to choose CONSTANT_NUM large dense models CONSTANT_NUM small models CONSTANT_NUM large sparse models where QSTR stands for large input output activations i e,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,implementation,"implementation mode, either `1`, `2`, or `3`.`1` loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.`2` stores layer weights in a dense but sparsely-populated 2D matrix and implements the forward pass as a single matrix-multiply. It uses a lot of RAM but performs few (large) ops.`3` stores layer weights in a sparse tensor and implements the forward pass as a single sparse matrix-multiply.How to choose:`1`: large, dense models,`2`: small models,`3`: large, sparse models,where ""large"" stands for large input/output activations (i.e. many `filters`, `input_filters`, large `input_size`,`output_size`), and ""sparse"" stands for few connections between inputs and outputs, i.e. small ratio`filters * input_filters * kernel_size / (input_size * strides)`, where inputs to and outputs of the layer are assumed to have shapes`(input_size, input_filters)`, `(output_size, filters)`respectively.It is recommended to benchmark each in the setting of interest to pick the most efficient one (in terms of speed and memory usage). Correct choice of implementation can lead to dramatic speed improvements (e.g. 50X), potentially at the expense of RAM.Also, only `padding=""valid""` is supported by `implementation=1`.",many PARAM QSTR large QSTR and QSTR stands for few connections between inputs and outputs i e,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,implementation,"implementation mode, either `1`, `2`, or `3`.`1` loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.`2` stores layer weights in a dense but sparsely-populated 2D matrix and implements the forward pass as a single matrix-multiply. It uses a lot of RAM but performs few (large) ops.`3` stores layer weights in a sparse tensor and implements the forward pass as a single sparse matrix-multiply.How to choose:`1`: large, dense models,`2`: small models,`3`: large, sparse models,where ""large"" stands for large input/output activations (i.e. many `filters`, `input_filters`, large `input_size`,`output_size`), and ""sparse"" stands for few connections between inputs and outputs, i.e. small ratio`filters * input_filters * kernel_size / (input_size * strides)`, where inputs to and outputs of the layer are assumed to have shapes`(input_size, input_filters)`, `(output_size, filters)`respectively.It is recommended to benchmark each in the setting of interest to pick the most efficient one (in terms of speed and memory usage). Correct choice of implementation can lead to dramatic speed improvements (e.g. 50X), potentially at the expense of RAM.Also, only `padding=""valid""` is supported by `implementation=1`.",small ratio PARAM input_filters PARAM BSTR where inputs to and outputs of the layer are assumed to have shapes BSTR BSTRrespectively It is recommended to benchmark each in the setting of interest to pick the most efficient one BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,implementation,"implementation mode, either `1`, `2`, or `3`.`1` loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.`2` stores layer weights in a dense but sparsely-populated 2D matrix and implements the forward pass as a single matrix-multiply. It uses a lot of RAM but performs few (large) ops.`3` stores layer weights in a sparse tensor and implements the forward pass as a single sparse matrix-multiply.How to choose:`1`: large, dense models,`2`: small models,`3`: large, sparse models,where ""large"" stands for large input/output activations (i.e. many `filters`, `input_filters`, large `input_size`,`output_size`), and ""sparse"" stands for few connections between inputs and outputs, i.e. small ratio`filters * input_filters * kernel_size / (input_size * strides)`, where inputs to and outputs of the layer are assumed to have shapes`(input_size, input_filters)`, `(output_size, filters)`respectively.It is recommended to benchmark each in the setting of interest to pick the most efficient one (in terms of speed and memory usage). Correct choice of implementation can lead to dramatic speed improvements (e.g. 50X), potentially at the expense of RAM.Also, only `padding=""valid""` is supported by `implementation=1`.",Correct choice of implementation can lead to dramatic speed improvements e g,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,implementation,"implementation mode, either `1`, `2`, or `3`.`1` loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.`2` stores layer weights in a dense but sparsely-populated 2D matrix and implements the forward pass as a single matrix-multiply. It uses a lot of RAM but performs few (large) ops.`3` stores layer weights in a sparse tensor and implements the forward pass as a single sparse matrix-multiply.How to choose:`1`: large, dense models,`2`: small models,`3`: large, sparse models,where ""large"" stands for large input/output activations (i.e. many `filters`, `input_filters`, large `input_size`,`output_size`), and ""sparse"" stands for few connections between inputs and outputs, i.e. small ratio`filters * input_filters * kernel_size / (input_size * strides)`, where inputs to and outputs of the layer are assumed to have shapes`(input_size, input_filters)`, `(output_size, filters)`respectively.It is recommended to benchmark each in the setting of interest to pick the most efficient one (in terms of speed and memory usage). Correct choice of implementation can lead to dramatic speed improvements (e.g. 50X), potentially at the expense of RAM.Also, only `padding=""valid""` is supported by `implementation=1`.",50X potentially at the expense of RAM Also only PARAM QSTR is supported by implementation CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected1D,implementation,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.crossed_column,hash_key,Specify the hash_key that will be used by the `FingerprintCat64`function to combine the crosses fingerprints on SparseCrossOp (optional).,Specify the hash_key that will be used by the QSTR function to combine the crosses fingerprints on SparseCrossOp BSTR,,,,,,,
tf.feature_column.crossed_column,hash_key,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.Conv2DTranspose,padding,"one of `""valid""` or `""same""` (case-insensitive).",one of QSTR BSTR,D_TYPE,,,,,,QSTR
tf.keras.layers.Conv2DTranspose,padding,DF: valid,DEFAULT DF_STR,D_TYPE,,,,,,QSTR
tf.keras.backend.pool2d,pool_size,tuple of 2 integers.,D_STRUCTURE of CONSTANT_NUM D_TYPE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.math.segment_prod,name,A name for the operation (optional).,A name for the operation BSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.math.segment_prod,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,weights,"A `Tensor` of shape `[num_classes, dim]`, or a list of `Tensor`objects whose concatenation along dimension 0 has shape [num_classes, dim].  The (possibly-sharded) class embeddings.",A D_STRUCTURE of shape BSTR or a D_STRUCTURE of D_STRUCTUREobjects whose concatenation along dimension CONSTANT_NUM has shape BSTR,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.nn.sampled_softmax_loss,weights,"A `Tensor` of shape `[num_classes, dim]`, or a list of `Tensor`objects whose concatenation along dimension 0 has shape [num_classes, dim].  The (possibly-sharded) class embeddings.",The BSTR class embeddings,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.strings.format,inputs,"A list of `Tensor` objects, or a single Tensor. The list of tensors to format into the template string. If a solitary tensor is passed in, the input tensor will automatically be wrapped as a list.",A D_STRUCTURE of D_STRUCTURE objects or a single D_STRUCTURE,,D_STRUCTURE,D_STRUCTURE,,,,
tf.strings.format,inputs,"A list of `Tensor` objects, or a single Tensor. The list of tensors to format into the template string. If a solitary tensor is passed in, the input tensor will automatically be wrapped as a list.",The D_STRUCTURE of D_STRUCTURE to format into the PARAM D_TYPE,,D_STRUCTURE,D_STRUCTURE,,,,
tf.strings.format,inputs,"A list of `Tensor` objects, or a single Tensor. The list of tensors to format into the template string. If a solitary tensor is passed in, the input tensor will automatically be wrapped as a list.",If a solitary D_STRUCTURE is passed in the input D_STRUCTURE will automatically be wrapped as a D_STRUCTURE,,D_STRUCTURE,D_STRUCTURE,,,,
tf.keras.layers.LayerNormalization,scale,"If True, multiply by `gamma`. If False, `gamma` is not used. When the next layer is linear (also e.g. `nn.relu`), this can be disabled since the scaling will be done by the next layer.",If CONSTANT_BOOL multiply by QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LayerNormalization,scale,"If True, multiply by `gamma`. If False, `gamma` is not used. When the next layer is linear (also e.g. `nn.relu`), this can be disabled since the scaling will be done by the next layer.",If CONSTANT_BOOL QSTR is not used,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LayerNormalization,scale,"If True, multiply by `gamma`. If False, `gamma` is not used. When the next layer is linear (also e.g. `nn.relu`), this can be disabled since the scaling will be done by the next layer.",When the next layer is linear also e g,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LayerNormalization,scale,"If True, multiply by `gamma`. If False, `gamma` is not used. When the next layer is linear (also e.g. `nn.relu`), this can be disabled since the scaling will be done by the next layer.",nn relu this can be disabled since the scaling will be done by the next layer,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LayerNormalization,scale,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.count_nonzero,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input), rank(input))`.",The dimensions to reduce,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input,ndim:&input)",
tf.math.count_nonzero,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input), rank(input))`.",If QSTR BSTR reduces all dimensions,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input,ndim:&input)",
tf.math.count_nonzero,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input), rank(input))`.",Must be in the range BSTR,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input,ndim:&input)",
tf.math.count_nonzero,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input,ndim:&input)",
tf.xla.experimental.jit_scope,compile_ops,"Whether to enable or disable compilation in the scope. Either a Python bool, or a callable that accepts the parameter`node_def` and returns a python bool.",Whether to enable or disable compilation in the scope,D_TYPE,,,,CONSTANT_VAL,,
tf.xla.experimental.jit_scope,compile_ops,"Whether to enable or disable compilation in the scope. Either a Python bool, or a callable that accepts the parameter`node_def` and returns a python bool.",Either a Python D_TYPE or a callable that accepts the parameter QSTR and returns a python D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.xla.experimental.jit_scope,compile_ops,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.sequence.pad_sequences,maxlen,"Int, maximum length of all sequences.",D_TYPE maximum length of all PARAM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.sequence.pad_sequences,maxlen,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.truediv,x,`Tensor` numerator of numeric type.,D_STRUCTURE numerator of D_TYPE type,D_TYPE,D_STRUCTURE,,,,,
tf.nn.conv1d,filters,A 3D `Tensor`.  Must have the same type as `input`.,A CONSTANT_NUM D D_STRUCTURE,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.nn.conv1d,filters,A 3D `Tensor`.  Must have the same type as `input`.,Must have the same type as PARAM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.tensordot,a,`Tensor` of type `float32` or `float64`.,D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.strings.unicode_script,input,A `Tensor` of type `int32`. A Tensor of int32 Unicode code points.,A D_STRUCTURE of type D_TYPE,D_TYPE,D_STRUCTURE,,,,,
tf.strings.unicode_script,input,A `Tensor` of type `int32`. A Tensor of int32 Unicode code points.,A D_STRUCTURE of D_TYPE Unicode code points,D_TYPE,D_STRUCTURE,,,,,
tf.keras.layers.ZeroPadding2D,padding,"Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints. If int: the same symmetric padding is applied to height and width.If tuple of 2 ints: interpreted as two different symmetric padding values for height and width:`(symmetric_height_pad, symmetric_width_pad)`.If tuple of 2 tuples of 2 ints: interpreted as`((top_pad, bottom_pad), (left_pad, right_pad))` ",D_TYPE or D_STRUCTURE of CONSTANT_NUM D_TYPE or D_STRUCTURE of CONSTANT_NUM tuples of CONSTANT_NUM D_TYPE,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.ZeroPadding2D,padding,"Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints. If int: the same symmetric padding is applied to height and width.If tuple of 2 ints: interpreted as two different symmetric padding values for height and width:`(symmetric_height_pad, symmetric_width_pad)`.If tuple of 2 tuples of 2 ints: interpreted as`((top_pad, bottom_pad), (left_pad, right_pad))` ",If D_TYPE the same symmetric padding is applied to height and width If D_STRUCTURE of CONSTANT_NUM D_TYPE interpreted as two different symmetric padding values for height and width BSTR If D_STRUCTURE of CONSTANT_NUM tuples of CONSTANT_NUM D_TYPE interpreted as BSTR,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.layers.ZeroPadding2D,padding,"DF: (1, 1)",DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.math.reduce_euclidean_norm,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input_tensor), rank(input_tensor))`.",The dimensions to reduce,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.math.reduce_euclidean_norm,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input_tensor), rank(input_tensor))`.",If QSTR BSTR reduces all dimensions,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.math.reduce_euclidean_norm,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input_tensor), rank(input_tensor))`.",Must be in the range BSTR,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.math.reduce_euclidean_norm,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.math.reduce_sum,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input_tensor), rank(input_tensor))`.",The dimensions to reduce,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.math.reduce_sum,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input_tensor), rank(input_tensor))`.",If QSTR BSTR reduces all dimensions,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.math.reduce_sum,axis,"The dimensions to reduce. If `None` (the default), reduces all dimensions. Must be in the range `[-rank(input_tensor), rank(input_tensor))`.",Must be in the range BSTR,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.math.reduce_sum,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.linalg.svd,full_matrices,"If true, compute full-sized `u` and `v`. If false (the default), compute only the leading `P` singular vectors. Ignored if `compute_uv` is `False`.",If CONSTANT_BOOL compute full sized QSTR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.svd,full_matrices,"If true, compute full-sized `u` and `v`. If false (the default), compute only the leading `P` singular vectors. Ignored if `compute_uv` is `False`.",If CONSTANT_BOOL BSTR compute only the leading QSTR singular vectors,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.svd,full_matrices,"If true, compute full-sized `u` and `v`. If false (the default), compute only the leading `P` singular vectors. Ignored if `compute_uv` is `False`.",Ignored if PARAM is CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.svd,full_matrices,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.datasets.reuters.load_data,**kwargs,Used for backwards compatibility.,Used for backwards compatibility,,,,,,,
tf.keras.layers.GRUCell,recurrent_activation,"Activation function to use for the recurrent step. Default: sigmoid (`sigmoid`). If you pass `None`, no activation is applied (ie. ""linear"" activation: `a(x) = x`).",PARAM function to use for the recurrent step,,,,,,,
tf.keras.layers.GRUCell,recurrent_activation,"Activation function to use for the recurrent step. Default: sigmoid (`sigmoid`). If you pass `None`, no activation is applied (ie. ""linear"" activation: `a(x) = x`).",Default sigmoid QSTR,,,,,,,
tf.keras.layers.GRUCell,recurrent_activation,"Activation function to use for the recurrent step. Default: sigmoid (`sigmoid`). If you pass `None`, no activation is applied (ie. ""linear"" activation: `a(x) = x`).",If you pass QSTR no PARAM is applied ie,,,,,,,
tf.keras.layers.GRUCell,recurrent_activation,"Activation function to use for the recurrent step. Default: sigmoid (`sigmoid`). If you pass `None`, no activation is applied (ie. ""linear"" activation: `a(x) = x`).",QSTR PARAM a BSTR x,,,,,,,
tf.keras.layers.GRUCell,recurrent_activation,DF: sigmoid,DEFAULT DF_STR,,,,,,,
tf.keras.estimator.model_to_estimator,custom_objects,DF: None,DEFAULT None,,,D_STRUCTURE,,,,
tf.math.not_equal,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.experimental.preprocessing.Normalization,reset_state,DF: None,DEFAULT None,D_TYPE,,,,,,
tf.data.experimental.make_batched_features_dataset,sloppy_ordering,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_batched_features_dataset,shuffle,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.eye,num_columns,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.SimpleRNNCell,recurrent_dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.load_img,interpolation,DF: nearest,DEFAULT DF_STR,,,,,,,
tf.nn.conv2d_transpose,padding,DF: SAME,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.image.draw_bounding_boxes,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_greater,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.dense_to_ragged_batch,row_splits_dtype,DF: tf.dtypes.int64,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.io.parse_sequence_example,context_features,DF: None,DEFAULT None,,,D_STRUCTURE,,,,
tf.keras.layers.LocallyConnected1D,bias_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.any,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LSTMCell,activation,DF: tanh,DEFAULT DF_STR,,,,,,,
tf.math.reduce_logsumexp,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.hamming_window,dtype,DF: tf.dtypes.float32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.RNN,go_backwards,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.image.hsv_to_rgb,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Dense,bias_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.models.save_model,signatures,DF: None,DEFAULT None,,,,,,,
tf.keras.utils.register_keras_serializable,package,DF: Custom,DEFAULT DF_STR,D_TYPE,,,,,,
tf.quantization.fake_quant_with_min_max_args_gradient,max,DF: 6,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNN,recurrent_dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.max_pool_with_argmax,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SeparableConv2D,depth_multiplier,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.strings.split,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.check_numerics,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.sequence_categorical_column_with_identity,default_value,DF: None,DEFAULT None,,,,,,"[0,&num_buckets)",
tf.keras.preprocessing.image.random_shift,fill_mode,DF: nearest,DEFAULT DF_STR,D_TYPE,,,,,,QSTR
tf.io.parse_sequence_example,sequence_features,DF: None,DEFAULT None,,,D_STRUCTURE,,,,
tf.math.cumprod,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Cropping3D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.LocallyConnected2D,kernel_initializer,DF: glorot_uniform,DEFAULT DF_STR,D_TYPE,,,,,,
tf.data.experimental.rejection_resample,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.relu,max_value,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.batch_normalization,epsilon,DF: 0.001,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.regularizers.l1_l2,l2,DF: 0.01,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.atrous_conv2d_transpose,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.data.experimental.make_csv_dataset,prefetch_buffer_size,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.strings.unicode_transcode,replacement_char,DF: 65533,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.gradients,unconnected_gradients,DF: tf.UnconnectedGradients.NONE,tf UnconnectedGradients NONE,,,,,,,
tf.no_op,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.add_n,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.top_k,sorted,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.random_binomial,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.norm,ord,DF: euclidean,DEFAULT DF_STR,D_TYPE,,,,,,QSTR
tf.keras.preprocessing.image.img_to_array,dtype,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.set_diag,name,DF: set_diag,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.normalize,axis,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.sparse.segment_mean,num_segments,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.linalg.matrix_transpose,name,DF: matrix_transpose,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,
tf.gather_nd,batch_dims,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,"[0,inf)",
tf.keras.backend.random_uniform,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.random_shear,channel_axis,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.reduce_all,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.categorical_column_with_vocabulary_list,num_oov_buckets,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.io.decode_image,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.dynamic_partition,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.avg_pool3d,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.models.save_model,include_optimizer,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.RNNCellDropoutWrapper,seed,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.compat.as_text,encoding,DF: utf-8,utf CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.trace_export,profiler_outdir,DF: None,DEFAULT None,,,,,,,
tf.keras.datasets.imdb.load_data,oov_char,DF: 2,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.random.normal,mean,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.summary.scalar,description,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv2d_transpose,data_format,DF: NHWC,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.layers.experimental.preprocessing.TextVectorization,pad_to_max_tokens,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.BatchNormalization,gamma_constraint,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.SeparableConv1D,use_bias,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.any,keepdims,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.count_nonzero,keepdims,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.strings.unicode_transcode,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNNCell,activation,DF: tanh,DEFAULT DF_STR,,,,,,,
tf.signal.inverse_stft,window_fn,DF: tf.signal.hann_window,tf signal hann_window,,,,,,,
tf.io.deserialize_many_sparse,rank,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.expand_dims,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Concatenate,axis,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.avg_pool2d,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.BatchNormalization,trainable,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.experimental.preprocessing.TextVectorization,split,DF: SPLIT_ON_WHITESPACE,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.layers.ConvLSTM2D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.UpSampling2D,interpolation,DF: nearest,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.avg_pool,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.embedding_column,combiner,DF: mean,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.linalg.tridiagonal_solve,partial_pivoting,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LayerNormalization,beta_constraint,DF: None,DEFAULT None,,,,,,,
tf.math.accumulate_n,shape,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.ConvLSTM2D,return_sequences,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.l2_normalize,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.random_shear,cval,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.lu_reconstruct,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.segment_min,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ConvLSTM2D,bias_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.linalg.tensor_diag,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.strided_slice,end_mask,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.in_test_phase,training,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected2D,implementation,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv1D,activity_regularizer,DF: None,DEFAULT None,,,,,,,
tf.sets.difference,aminusb,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.foldl,parallel_iterations,DF: 10,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.GRU,go_backwards,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.io.gfile.rename,overwrite,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.autograph.to_graph,recursive,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.confusion_matrix,weights,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,BSTR,,,
tf.debugging.assert_shapes,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.cholesky,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.feature_column.embedding_column,tensor_name_in_ckpt,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.estimator.experimental.stop_if_lower_hook,run_every_secs,DF: 60,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.summary.create_file_writer,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_image,channels,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.SimpleRNN,dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.image.combined_non_max_suppression,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.local_conv1d,data_format,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.GRUCell,recurrent_dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.shape_n,out_type,DF: tf.dtypes.int32,D_TYPE D_TYPE,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.variable,dtype,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,,,
tf.data.experimental.make_csv_dataset,column_defaults,DF: None,DEFAULT None,,,D_STRUCTURE,,,,
tf.histogram_fixed_width_bins,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reciprocal,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNNCell,dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.graph_util.import_graph_def,producer_op_list,DF: None,DEFAULT None,,,D_STRUCTURE,,CONSTANT_VAL,,
tf.keras.backend.relu,threshold,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.batch_normalization,axis,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.experimental.SequenceFeatures,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.encode_proto,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.AveragePooling2D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.SeparableConv1D,trainable,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.parse_single_sequence_example,example_name,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.keras.layers.Conv1D,kernel_regularizer,DF: None,DEFAULT None,,,,,,,
tf.strings.ngrams,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.temporal_padding,padding,"DF: (1, 1)",DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.zeros,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.safe_embedding_lookup_sparse,max_norm,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.SeparableConv1D,padding,DF: valid,DEFAULT DF_STR,D_TYPE,,,,,,QSTR
tf.keras.layers.Conv3D,kernel_regularizer,DF: None,DEFAULT None,,,,,,,
tf.keras.backend.prod,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.decode_jpeg,try_recover_truncated,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.quantization.quantize_and_dequantize,range_given,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.PReLU,alpha_initializer,DF: zeros,DEFAULT DF_STR,,,,,,,
tf.feature_column.numeric_column,normalizer_fn,DF: None,DEFAULT None,,,,,,,
tf.linalg.solve,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Cropping2D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.GRUCell,kernel_constraint,DF: None,DEFAULT None,,,,,,,
tf.scatter_nd,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.cond,false_fn,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.SeparableConv1D,activation,DF: None,DEFAULT None,,,,,,,
tf.nest.assert_same_structure,check_types,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.nn.embedding_lookup_sparse,max_norm,DF: None,DEFAULT None,,,,,,,
tf.strings.as_string,width,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,"[0,inf)",
tf.math.is_non_decreasing,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.ConvLSTM2D,kernel_initializer,DF: glorot_uniform,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.estimator.model_to_estimator,checkpoint_format,DF: checkpoint,DEFAULT DF_STR,D_TYPE,,,,,,
tf.keras.layers.LSTM,recurrent_dropout,DF: 0.0,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.Input,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.apply_channel_shift,channel_axis,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.pinv,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.depthwise_conv2d_backprop_filter,data_format,DF: NHWC,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.estimator.regressor_parse_example_spec,label_dimension,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.utils.plot_model,show_layer_names,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.experimental.enable_dump_debug_info,op_regex,DF: None,DEFAULT None,,,,,,,
tf.image.random_crop,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.matmul,adjoint_b,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.io.parse_single_example,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,kernel_regularizer,DF: None,DEFAULT None,,,,,,,
tf.nn.safe_embedding_lookup_sparse,combiner,DF: mean,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.nn.normalize_moments,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.Assert,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.debugging.assert_shapes,data,DF: None,DEFAULT None,,D_STRUCTURE,,,,,
tf.linalg.lu_matrix_inverse,validate_args,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.math.reduce_mean,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.io.decode_jpeg,fancy_upscaling,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.backend.conv1d,strides,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.linalg.logm,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.signal.frame,axis,DF: -1,DEFAULT CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.math.zero_fraction,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.space_to_batch,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.LocallyConnected2D,activation,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.BatchNormalization,beta_regularizer,DF: None,DEFAULT None,,,,,,,
tf.nn.max_pool1d,data_format,DF: NWC,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.backend.pool2d,padding,DF: valid,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.keras.datasets.reuters.load_data,skip_top,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv3D,data_format,DF: None,DEFAULT None,D_TYPE,,,BSTR,CONSTANT_VAL,,QSTR
tf.keras.layers.experimental.preprocessing.TextVectorization,ngrams,DF: None,DEFAULT None,D_TYPE,,D_STRUCTURE,,CONSTANT_VAL,,
tf.nn.avg_pool2d,data_format,DF: NHWC,DEFAULT DF_STR,D_TYPE,,,,CONSTANT_VAL,,QSTR
tf.math.sqrt,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.io.read_file,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.linspace,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.cross,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.utils.get_file,cache_dir,DF: None,DEFAULT None,,,,,,,
tf.keras.layers.Conv2D,dilation_rate,"DF: (1, 1)",DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,1]",
tf.math.sigmoid,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.sparse.slice,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv3D,strides,"DF: (1, 1, 1)",DEFAULT CONSTANT_NUM,D_TYPE,,D_STRUCTURE,BSTR,CONSTANT_VAL,"[0,inf)",
tf.keras.layers.ConvLSTM2D,stateful,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.nn.conv2d_transpose,dilations,DF: None,DEFAULT None,D_TYPE,D_STRUCTURE,D_STRUCTURE,BSTR,CONSTANT_VAL,,
tf.keras.preprocessing.text.text_to_word_sequence,lower,DF: True,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.experimental.terminate_keras_multiprocessing_pools,grace_period,DF: 0.1,DEFAULT CONSTANT_FLOAT,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.SimpleRNN,bias_initializer,DF: zeros,DEFAULT DF_STR,D_TYPE,,,,,,
tf.random.stateless_uniform,minval,DF: 0,DEFAULT CONSTANT_NUM,D_TYPE,D_STRUCTURE,,,CONSTANT_VAL,,
tf.strings.format,summarize,DF: 3,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.deserialize,custom_objects,DF: None,DEFAULT None,,,D_STRUCTURE,,,,
tf.math.reduce_logsumexp,axis,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,"[-ndim:&input_tensor,ndim:&input_tensor)",
tf.keras.layers.SimpleRNNCell,kernel_constraint,DF: None,DEFAULT None,,,,,,,
tf.shape,name,DF: None,DEFAULT None,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.layers.Conv3DTranspose,kernel_constraint,DF: None,DEFAULT None,,,,,,,
tf.linalg.matvec,a_is_sparse,DF: False,DEFAULT CONSTANT_BOOL,D_TYPE,,,,CONSTANT_VAL,,
tf.keras.preprocessing.image.random_rotation,interpolation_order,DF: 1,DEFAULT CONSTANT_NUM,D_TYPE,,,,CONSTANT_VAL,,
