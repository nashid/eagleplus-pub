API,Arg,default,doc_dtype,enum_constr,descp
mxnet.ndarray.dot,forward_stype,_Null,"[""{None, 'csr', 'default', 'row_sparse'}"", 'optional', ""default='None'""]","['None', 'csr', 'default', 'row_sparse']","The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type."
mxnet.ndarray.op.ctc_loss,blank_label,_Null,"[""{'first', 'last'}"", 'optional', ""default='first'""]","['first', 'last']","Set the label that is reserved for blank label.If ""first"", 0-th label is reserved, and label values for tokens in the vocabulary are between `1` and `alphabet_size-1`, and the padding mask is `-1`. If ""last"", last label value `alphabet_size-1` is reserved for blank label instead, and label values for tokens in the vocabulary are between `0` and `alphabet_size-2`, and the padding mask is `0`."
mxnet.ndarray.random_uniform,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.contrib.quantized_conv,cudnn_tune,_Null,"[""{None, 'fastest', 'limited_workspace', 'off'}"", 'optional', ""default='None'""]","['None', 'fastest', 'limited_workspace', 'off']",Whether to pick convolution algo by running performance test.
mxnet.ndarray.contrib.quantized_conv,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'None']","Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
mxnet.ndarray.contrib.dequantize,out_type,_Null,"[""{'float32'}"", 'optional', ""default='float32'""]",['float32'],Output data type.
mxnet.ndarray.op.l2normalization,mode,_Null,"[""{'channel', 'instance', 'spatial'}"", 'optional', ""default='instance'""]","['channel', 'instance', 'spatial']",Specify the dimension along which to compute L2 norm.
mxnet.ndarray.op.sequencereverse,axis,_Null,"['int', 'optional', ""default='0'""]",['0'],The sequence axis. Only 0 is currently supported.
mxnet.ndarray.contrib.box_non_maximum_suppression,in_format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The input box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.ndarray.contrib.box_non_maximum_suppression,out_format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The output box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.ndarray.random_exponential,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.random_gamma,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.op.sequencemask,axis,_Null,"['int', 'optional', ""default='0'""]","['0', '1']",The sequence axis. Only values of 0 and 1 are currently supported.
mxnet.image.resize_short,interp,2,"['int', 'optional', 'default=2']","['0', '1', '10', '2', '3', '4', '9']","Interpolation method used for resizing the image. Possible values: 0: Nearest Neighbors Interpolation. 1: Bilinear interpolation. 2: Bicubic interpolation over 4x4 pixel neighborhood. 3: Area-based (resampling using pixel area relation). It may be a preferred method for image decimation, as it gives moire-free results. But when the image is zoomed, it is similar to the Nearest Neighbors method. (used by default). 4: Lanczos interpolation over 8x8 pixel neighborhood. 9: Cubic for enlarge, area for shrink, bilinear for others 10: Random select from interpolation method metioned above. Note: When shrinking an image, it will generally look best with AREA-based interpolation, whereas, when enlarging an image, it will generally look best with Bicubic (slow) or Bilinear (faster but still looks OK). More details can be found in the documentation of OpenCV, please refer to http://docs.opencv.org/master/da/d54/group__imgproc__transform.html."
mxnet.ndarray.op.sample_normal,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.sample_poisson,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.contrib.quantize_v2,out_type,_Null,"[""{'auto', 'int8', 'uint8'}"", 'optional', ""default='int8'""]","['auto', 'int8', 'uint8']",Output data type. auto can be specified to automatically determine output type according to min_calib_range.
mxnet.contrib.ndarray.ctc_loss,blank_label,_Null,"[""{'first', 'last'}"", 'optional', ""default='first'""]","['first', 'last']","Set the label that is reserved for blank label.If ""first"", 0-th label is reserved, and label values for tokens in the vocabulary are between `1` and `alphabet_size-1`, and the padding mask is `-1`. If ""last"", last label value `alphabet_size-1` is reserved for blank label instead, and label values for tokens in the vocabulary are between `0` and `alphabet_size-2`, and the padding mask is `0`."
mxnet.ndarray.gridgenerator,transform_type,_Null,"[""{'affine', 'warp'}"", 'required']","['affine', 'warp']","The type of transformation. For affine, input data should be an affine matrix of size (batch, 6). For warp, input data should be an optical flow of size (batch, 2, h, w)."
mxnet.contrib.ndarray.requantize,out_type,_Null,"[""{'auto', 'int8', 'uint8'}"", 'optional', ""default='int8'""]","['auto', 'int8', 'uint8']",Output data type. auto can be specified to automatically determine output type according to min_calib_range.
mxnet.kvstore.create,name,local,"[""{'local', 'device', 'nccl', 'dist_sync', 'dist_device_sync', 'dist_async'}""]","['device', 'dist_async', 'dist_device_sync', 'dist_sync', 'local', 'nccl']",The type of KVStore.
mxnet.ndarray.sequencelast,axis,_Null,"['int', 'optional', ""default='0'""]","['0', '1']",The sequence axis. Only values of 0 and 1 are currently supported.
mxnet.contrib.ndarray.box_decode,format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='center'""]","['center', 'corner']","The box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.ndarray.sample_exponential,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.op.ctcloss,blank_label,_Null,"[""{'first', 'last'}"", 'optional', ""default='first'""]","['first', 'last']","Set the label that is reserved for blank label.If ""first"", 0-th label is reserved, and label values for tokens in the vocabulary are between `1` and `alphabet_size-1`, and the padding mask is `-1`. If ""last"", last label value `alphabet_size-1` is reserved for blank label instead, and label values for tokens in the vocabulary are between `0` and `alphabet_size-2`, and the padding mask is `0`."
mxnet.io.libsvmiter,ctx,None,"[""{'cpu', 'gpu'}"", 'optional', ""default='gpu'""]","['cpu', 'gpu']",Context data loader optimized for.
mxnet.io.libsvmiter,dtype,None,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type. `None` means no change.
mxnet.io.imagedetrecorditer,crop_emit_mode,None,"[""{'center', 'overlap'}"", 'optional', ""default='center'""]","['center', 'overlap']",Augmentation Param: Emition mode for invalid ground-truths after crop. center: emit if centroid of object is out of crop region; overlap: emit if overlap is less than emit_overlap_thresh.
mxnet.io.imagedetrecorditer,ctx,None,"[""{'cpu', 'gpu'}"", 'optional', ""default='gpu'""]","['cpu', 'gpu']",Context data loader optimized for.
mxnet.io.imagedetrecorditer,dtype,None,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type. `None` means no change.
mxnet.io.imagedetrecorditer,inter_method,None,"['int', 'optional', ""default='1'""]","['0', '1', '10', '2', '3', '4', '9']",Augmentation Param: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.
mxnet.io.imagedetrecorditer,resize_mode,None,"[""{'fit', 'force', 'shrink'}"", 'optional', ""default='force'""]","['fit', 'force', 'shrink']","Augmentation Param: How image data fit in data_shape. force: force reshape to data_shape regardless of aspect ratio; shrink: ensure each side fit in data_shape, preserve aspect ratio; fit: fit image to data_shape, preserve ratio, will upscale if applicable."
mxnet.ndarray.contrib.box_decode,format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='center'""]","['center', 'corner']","The box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.ndarray.op.pick,mode,_Null,"[""{'clip', 'wrap'}"", 'optional', ""default='clip'""]","['clip', 'wrap']","Specify how out-of-bound indices behave. Default is ""clip"". ""clip"" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  ""wrap"" means to wrap around."
mxnet.ndarray.convolution,cudnn_tune,_Null,"[""{None, 'fastest', 'limited_workspace', 'off'}"", 'optional', ""default='None'""]","['None', 'fastest', 'limited_workspace', 'off']",Whether to pick convolution algo by running performance test.
mxnet.ndarray.convolution,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'None']","Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
mxnet.ndarray.op.cast,dtype,_Null,"[""{'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'required']","['bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type.
mxnet.ndarray.op.sample_gamma,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.random_negative_binomial,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.softmax2,dtype,_Null,"[""{None, 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).
mxnet.ndarray.contrib.requantize,out_type,_Null,"[""{'auto', 'int8', 'uint8'}"", 'optional', ""default='int8'""]","['auto', 'int8', 'uint8']",Output data type. auto can be specified to automatically determine output type according to min_calib_range.
mxnet.ndarray.op.choose_element_0index,mode,_Null,"[""{'clip', 'wrap'}"", 'optional', ""default='clip'""]","['clip', 'wrap']","Specify how out-of-bound indices behave. Default is ""clip"". ""clip"" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  ""wrap"" means to wrap around."
mxnet.contrib.ndarray.quantized_conv,cudnn_tune,_Null,"[""{None, 'fastest', 'limited_workspace', 'off'}"", 'optional', ""default='None'""]","['None', 'fastest', 'limited_workspace', 'off']",Whether to pick convolution algo by running performance test.
mxnet.contrib.ndarray.quantized_conv,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'None']","Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
mxnet.contrib.ndarray.dequantize,out_type,_Null,"[""{'float32'}"", 'optional', ""default='float32'""]",['float32'],Output data type.
mxnet.ndarray.sparse.cast_storage,stype,_Null,"[""{'csr', 'default', 'row_sparse'}"", 'required']","['csr', 'default', 'row_sparse']",Output storage type.
mxnet.ndarray.random_normal,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.random.normal,dtype,_Null,"[""{'float16', 'float32', 'float64'}"", 'optional']","['float16', 'float32', 'float64']",Data type of output samples. Default is 'float32'
mxnet.ndarray.cast,dtype,_Null,"[""{'bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'required']","['bool', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type.
mxnet.ndarray.op.embedding,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Data type of weight.
mxnet.ndarray.pick,mode,_Null,"[""{'clip', 'wrap'}"", 'optional', ""default='clip'""]","['clip', 'wrap']","Specify how out-of-bound indices behave. Default is ""clip"". ""clip"" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  ""wrap"" means to wrap around."
mxnet.ndarray.op.dot,forward_stype,_Null,"[""{None, 'csr', 'default', 'row_sparse'}"", 'optional', ""default='None'""]","['None', 'csr', 'default', 'row_sparse']","The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type."
mxnet.ndarray.random.randn,dtype,None,"[""{'float16', 'float32', 'float64'}""]","['float16', 'float32', 'float64']",Data type of output samples. Default is 'float32'
mxnet.contrib.ndarray.box_iou,format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.ndarray.one_hot,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",DType of the output
mxnet.ndarray.contrib.box_iou,format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.ndarray.argsort,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'uint8']","DType of the output indices. It is only valid when ret_typ is ""indices"" or ""both"". An error will be raised if the selected data type cannot precisely represent the indices."
mxnet.image.createaugmenter,inter_method,2,"['int', 'default=2(Area-based)']","['0', '1', '10', '2', '3', '4', '9']","Interpolation method for all resizing operations Possible values: 0: Nearest Neighbors Interpolation. 1: Bilinear interpolation. 2: Bicubic interpolation over 4x4 pixel neighborhood. 3: Area-based (resampling using pixel area relation). It may be a preferred method for image decimation, as it gives moire-free results. But when the image is zoomed, it is similar to the Nearest Neighbors method. (used by default). 4: Lanczos interpolation over 8x8 pixel neighborhood. 9: Cubic for enlarge, area for shrink, bilinear for others 10: Random select from interpolation method metioned above. Note: When shrinking an image, it will generally look best with AREA-based interpolation, whereas, when enlarging an image, it will generally look best with Bicubic (slow) or Bilinear (faster but still looks OK). "
mxnet.contrib.ndarray.quantized_act,act_type,_Null,"[""{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}"", 'required']","['relu', 'sigmoid', 'softrelu', 'softsign', 'tanh']",Activation function to be applied.
mxnet.contrib.quantization.quantize_model,calib_mode,entropy,['str'],"['entropy', 'naive', 'none']","If calib_mode='none', no calibration will be used and the thresholds for requantization after the corresponding layers will be calculated at runtime by calling min and max operators. The quantized models generated in this mode are normally 10-20% slower than those with calibrations during inference. If calib_mode='naive', the min and max values of the layer outputs from a calibration dataset will be directly taken as the thresholds for quantization. If calib_mode='entropy' (default mode), the thresholds for quantization will be derived such that the KL divergence between the distributions of FP32 layer outputs and quantized layer outputs is minimized based upon the calibration dataset."
mxnet.contrib.quantization.quantize_model,quantized_dtype,int8,['str'],"['auto', 'int8', 'uint8']","The quantized destination type for input data. Currently support 'int8', 'uint8' and 'auto'. 'auto' means automatically select output type according to calibration result. Default value is 'int8'."
mxnet.ndarray.sample_gamma,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.image.imread,flag,None,"['{0, 1}', 'default 1']","['0', '1']",1 for three channel color output. 0 for grayscale output.
mxnet.ndarray.softmin,dtype,_Null,"[""{None, 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).
mxnet.ndarray.op.sample_poisson,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.sample_generalized_negative_binomial,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.pad,mode,_Null,"[""{'constant', 'edge', 'reflect'}"", 'required']","['constant', 'edge', 'reflect']","Padding type to use. ""constant"" pads with constant_value ""edge"" pads using the edge values of the input array ""reflect"" pads by reflecting values with respect to the edges."
mxnet.ndarray.op.spatialtransformer,sampler_type,_Null,"[""{'bilinear'}"", 'required']",['bilinear'],sampling type
mxnet.ndarray.op.spatialtransformer,transform_type,_Null,"[""{'affine'}"", 'required']",['affine'],transformation type
mxnet.ndarray.choose_element_0index,mode,_Null,"[""{'clip', 'wrap'}"", 'optional', ""default='clip'""]","['clip', 'wrap']","Specify how out-of-bound indices behave. Default is ""clip"". ""clip"" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  ""wrap"" means to wrap around."
mxnet.contrib.quantization.quantize_net,calib_mode,none,['str'],"['entropy', 'naive', 'none']","If calib_mode='none', no calibration will be used and the thresholds for requantization after the corresponding layers will be calculated at runtime by calling min and max operators. The quantized models generated in this mode are normally 10-20% slower than those with calibrations during inference. If calib_mode='naive', the min and max values of the layer outputs from a calibration dataset will be directly taken as the thresholds for quantization. If calib_mode='entropy' (default mode), the thresholds for quantization will be derived such that the KL divergence between the distributions of FP32 layer outputs and quantized layer outputs is minimized based upon the calibration dataset."
mxnet.contrib.quantization.quantize_net,quantized_dtype,auto,['str'],"['auto', 'int8', 'uint8']","The quantized destination type for input data. Currently support 'int8' , 'uint8' and 'auto'. 'auto' means automatically select output type according to calibration result. Default value is 'int8'."
mxnet.ndarray.contrib.deformableconvolution,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'None']","Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
mxnet.ndarray.deconvolution,cudnn_tune,_Null,"[""{None, 'fastest', 'limited_workspace', 'off'}"", 'optional', ""default='None'""]","['None', 'fastest', 'limited_workspace', 'off']",Whether to pick convolution algorithm by running performance test.
mxnet.ndarray.deconvolution,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'None']","Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
mxnet.io.mnistiter,ctx,None,"[""{'cpu', 'gpu'}"", 'optional', ""default='gpu'""]","['cpu', 'gpu']",Context data loader optimized for.
mxnet.io.mnistiter,dtype,None,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type. `None` means no change.
mxnet.ndarray.random_generalized_negative_binomial,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.op.random_uniform,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.contrib.bilinearresize2d,mode,_Null,"[""{'like', 'odd_scale', 'size', 'to_even_down', 'to_even_up', 'to_odd_down', 'to_odd_up'}"", 'optional', ""default='size'""]","['like', 'odd_scale', 'simple', 'size', 'to_even_down', 'to_even_up', 'to_odd_down', 'to_odd_up']","resizing mode. ""simple"" - output height equals parameter ""height"" if ""scale_height"" parameter is not defined or input height multiplied by ""scale_height"" otherwise. Same for width;""odd_scale"" - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale > 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale < 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);""like"" - resize first input to the height and width of second input; ""to_even_down"" - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);""to_even_up"" - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);""to_odd_down"" - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);""to_odd_up"" - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);"
mxnet.ndarray.op.dropout,mode,_Null,"[""{'always', 'training'}"", 'optional', ""default='training'""]","['always', 'training']",Whether to only turn on dropout during training or to also turn on for inference.
mxnet.ndarray.op.random_negative_binomial,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.sparse.embedding,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Data type of weight.
mxnet.ndarray.sequencemask,axis,_Null,"['int', 'optional', ""default='0'""]","['0', '1']",The sequence axis. Only values of 0 and 1 are currently supported.
mxnet.ndarray.op.sample_multinomial,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'uint8'}"", 'optional', ""default='int32'""]","['float16', 'float32', 'float64', 'int32', 'uint8']",DType of the output in case this can't be inferred.
mxnet.ndarray.op.random_gamma,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.topk,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'uint8']","DType of the output indices when ret_typ is ""indices"" or ""both"". An error will be raised if the selected data type cannot precisely represent the indices."
mxnet.ndarray.topk,ret_typ,_Null,"[""{'both', 'indices', 'mask', 'value'}"", 'optional', ""default='indices'""]","['both', 'indices', 'mask', 'value']","The return type. ""value"" means to return the top k values, ""indices"" means to return the indices of the top k values, ""mask"" means to return a mask array containing 0 and 1. 1 means the top k values. ""both"" means to return a list of both values and indices of top k elements."
mxnet.ndarray.random.negative_binomial,dtype,_Null,"[""{'float16', 'float32', 'float64'}"", 'optional']","['float16', 'float32', 'float64']",Data type of output samples. Default is 'float32'
mxnet.ndarray.op.log_softmax,dtype,_Null,"[""{None, 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).
mxnet.ndarray.contrib.sparseembedding,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Data type of weight.
mxnet.ndarray.contrib.ctc_loss,blank_label,_Null,"[""{'first', 'last'}"", 'optional', ""default='first'""]","['first', 'last']","Set the label that is reserved for blank label.If ""first"", 0-th label is reserved, and label values for tokens in the vocabulary are between `1` and `alphabet_size-1`, and the padding mask is `-1`. If ""last"", last label value `alphabet_size-1` is reserved for blank label instead, and label values for tokens in the vocabulary are between `0` and `alphabet_size-2`, and the padding mask is `0`."
mxnet.ndarray.random.randint,dtype,_Null,"[""{'int32', 'int64'}"", 'optional']","['int32', 'int64']",Data type of output samples. Default is 'int32'
mxnet.contrib.quantization.calib_graph,quantized_dtype,int8,['str'],"['auto', 'int8', 'uint8']","The quantized destination type for input data. Currently support 'int8' , 'uint8' and 'auto'. 'auto' means automatically select output type according to calibration result. Default value is 'int8'."
mxnet.ndarray.op.sequencelast,axis,_Null,"['int', 'optional', ""default='0'""]","['0', '1']",The sequence axis. Only values of 0 and 1 are currently supported.
mxnet.ndarray.op.amp_cast,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'required']","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type.
mxnet.contrib.ndarray.box_non_maximum_suppression,in_format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The input box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.contrib.ndarray.box_non_maximum_suppression,out_format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The output box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.ndarray.embedding,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Data type of weight.
mxnet.ndarray.contrib.quantized_act,act_type,_Null,"[""{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}"", 'required']","['relu', 'sigmoid', 'softrelu', 'softsign', 'tanh']",Activation function to be applied.
mxnet.ndarray.op.makeloss,normalization,_Null,"[""{'batch', 'null', 'valid'}"", 'optional', ""default='null'""]","['batch', 'null', 'valid']","If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements."
mxnet.ndarray.pooling,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC', 'None']","Set layout for input and output. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
mxnet.ndarray.pooling,pool_type,_Null,"[""{'avg', 'lp', 'max', 'sum'}"", 'optional', ""default='max'""]","['avg', 'lp', 'max', 'sum']",Pooling type to be applied.
mxnet.ndarray.pooling,pooling_convention,_Null,"[""{'full', 'same', 'valid'}"", 'optional', ""default='valid'""]","['full', 'same', 'valid']",Pooling convention to be applied.
mxnet.ndarray.random.poisson,dtype,_Null,"[""{'float16', 'float32', 'float64'}"", 'optional']","['float16', 'float32', 'float64']",Data type of output samples. Default is 'float32'
mxnet.contrib.ndarray.quantize_v2,out_type,_Null,"[""{'auto', 'int8', 'uint8'}"", 'optional', ""default='int8'""]","['auto', 'int8', 'uint8']",Output data type. auto can be specified to automatically determine output type according to min_calib_range.
mxnet.ndarray.op.pad,mode,_Null,"[""{'constant', 'edge', 'reflect'}"", 'required']","['constant', 'edge', 'reflect']","Padding type to use. ""constant"" pads with constant_value ""edge"" pads using the edge values of the input array ""reflect"" pads by reflecting values with respect to the edges."
mxnet.ndarray.op.topk,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'uint8']","DType of the output indices when ret_typ is ""indices"" or ""both"". An error will be raised if the selected data type cannot precisely represent the indices."
mxnet.ndarray.op.topk,ret_typ,_Null,"[""{'both', 'indices', 'mask', 'value'}"", 'optional', ""default='indices'""]","['both', 'indices', 'mask', 'value']","The return type. ""value"" means to return the top k values, ""indices"" means to return the indices of the top k values, ""mask"" means to return a mask array containing 0 and 1. 1 means the top k values. ""both"" means to return a list of both values and indices of top k elements."
mxnet.ndarray.softmaxoutput,normalization,_Null,"[""{'batch', 'null', 'valid'}"", 'optional', ""default='null'""]","['batch', 'null', 'valid']",Normalizes the gradient.
mxnet.ndarray.softmax,normalization,_Null,"[""{'batch', 'null', 'valid'}"", 'optional', ""default='null'""]","['batch', 'null', 'valid']",Normalizes the gradient.
mxnet.ndarray.op.random_randint,dtype,_Null,"[""{'None', 'int32', 'int64'}"", 'optional', ""default='None'""]","['None', 'int32', 'int64']",DType of the output in case this can't be inferred. Defaults to int32 if not defined (dtype=None).
mxnet.ndarray.op.random_normal,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.op.batch_dot,forward_stype,_Null,"[""{None, 'csr', 'default', 'row_sparse'}"", 'optional', ""default='None'""]","['None', 'csr', 'default', 'row_sparse']","The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type."
mxnet.ndarray.op.sample_uniform,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.rnn,mode,_Null,"[""{'gru', 'lstm', 'rnn_relu', 'rnn_tanh'}"", 'required']","['gru', 'lstm', 'rnn_relu', 'rnn_tanh']",the type of RNN to compute
mxnet.ndarray.contrib.quantize,out_type,_Null,"[""{'int8', 'uint8'}"", 'optional', ""default='uint8'""]","['int8', 'uint8']",Output data type.
mxnet.ndarray.log_softmax,dtype,_Null,"[""{None, 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).
mxnet.ndarray.spatialtransformer,sampler_type,_Null,"[""{'bilinear'}"", 'required']",['bilinear'],sampling type
mxnet.ndarray.spatialtransformer,transform_type,_Null,"[""{'affine'}"", 'required']",['affine'],transformation type
mxnet.image.createdetaugmenter,inter_method,2,"['int', 'default=2(Area-based)']","['0', '1', '10', '2', '3', '4', '9']","Interpolation method for all resizing operations Possible values: 0: Nearest Neighbors Interpolation. 1: Bilinear interpolation. 2: Area-based (resampling using pixel area relation). It may be a preferred method for image decimation, as it gives moire-free results. But when the image is zoomed, it is similar to the Nearest Neighbors method. (used by default). 3: Bicubic interpolation over 4x4 pixel neighborhood. 4: Lanczos interpolation over 8x8 pixel neighborhood. 9: Cubic for enlarge, area for shrink, bilinear for others 10: Random select from interpolation method metioned above. Note: When shrinking an image, it will generally look best with AREA-based interpolation, whereas, when enlarging an image, it will generally look best with Bicubic (slow) or Bilinear (faster but still looks OK). "
mxnet.contrib.ndarray.sparseembedding,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Data type of weight.
mxnet.ndarray.ctcloss,blank_label,_Null,"[""{'first', 'last'}"", 'optional', ""default='first'""]","['first', 'last']","Set the label that is reserved for blank label.If ""first"", 0-th label is reserved, and label values for tokens in the vocabulary are between `1` and `alphabet_size-1`, and the padding mask is `-1`. If ""last"", last label value `alphabet_size-1` is reserved for blank label instead, and label values for tokens in the vocabulary are between `0` and `alphabet_size-2`, and the padding mask is `0`."
mxnet.ndarray.upsampling,multi_input_mode,None,"[""{'concat', 'sum'}"", 'optional', ""default='concat'""]","['concat', 'sum']","How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling."
mxnet.ndarray.upsampling,sample_type,null,"[""{'bilinear', 'nearest'}"", 'required']","['bilinear', 'nearest']",upsampling method
mxnet.ndarray.take,mode,_Null,"[""{'clip', 'raise', 'wrap'}"", 'optional', ""default='clip'""]","['clip', 'raise', 'wrap']","Specify how out-of-bound indices bahave. Default is ""clip"". ""clip"" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. ""wrap"" means to wrap around. ""raise"" means to raise an error when index out of range."
mxnet.ndarray.op.norm,axis,_Null,"['Shape', 'None', 'optional', 'default=None']",['2'],"The axis or axes along which to perform the reduction.The default, axis=(), will compute over all elements into a scalar array with shape (1,). If axis is int, a reduction is performed on a particular axis. If axis is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed.   "
mxnet.ndarray.op.norm,ord,_Null,"['int', 'optional', ""default='2'""]","['1', '2']",Order of the norm. Currently ord=1 and ord=2 is supported.
mxnet.ndarray.op.norm,out_dtype,_Null,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8']",The data type of the output.
mxnet.ndarray.op.take,mode,_Null,"[""{'clip', 'raise', 'wrap'}"", 'optional', ""default='clip'""]","['clip', 'raise', 'wrap']","Specify how out-of-bound indices bahave. Default is ""clip"". ""clip"" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis. ""wrap"" means to wrap around. ""raise"" means to raise an error when index out of range."
mxnet.ndarray.norm,axis,_Null,"['Shape', 'None', 'optional', 'default=None']",['2'],"The axis or axes along which to perform the reduction.The default, axis=(), will compute over all elements into a scalar array with shape (1,). If axis is int, a reduction is performed on a particular axis. If axis is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed.   "
mxnet.ndarray.norm,ord,_Null,"['int', 'optional', ""default='2'""]","['1', '2']",Order of the norm. Currently ord=1 and ord=2 is supported.
mxnet.ndarray.norm,out_dtype,_Null,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8']",The data type of the output.
mxnet.ndarray.op.random_poisson,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.op.cast_storage,stype,_Null,"[""{'csr', 'default', 'row_sparse'}"", 'required']","['csr', 'default', 'row_sparse']",Output storage type.
mxnet.ndarray.op.activation,act_type,_Null,"[""{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}"", 'required']","['relu', 'sigmoid', 'softrelu', 'softsign', 'tanh']",Activation function to be applied.
mxnet.ndarray.ctc_loss,blank_label,_Null,"[""{'first', 'last'}"", 'optional', ""default='first'""]","['first', 'last']","Set the label that is reserved for blank label.If ""first"", 0-th label is reserved, and label values for tokens in the vocabulary are between `1` and `alphabet_size-1`, and the padding mask is `-1`. If ""last"", last label value `alphabet_size-1` is reserved for blank label instead, and label values for tokens in the vocabulary are between `0` and `alphabet_size-2`, and the padding mask is `0`."
mxnet.ndarray.op.sample_negative_binomial,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.sample_normal,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.sample_multinomial,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'uint8'}"", 'optional', ""default='int32'""]","['float16', 'float32', 'float64', 'int32', 'uint8']",DType of the output in case this can't be inferred.
mxnet.ndarray.op.random_generalized_negative_binomial,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.op.gridgenerator,transform_type,_Null,"[""{'affine', 'warp'}"", 'required']","['affine', 'warp']","The type of transformation. For affine, input data should be an affine matrix of size (batch, 6). For warp, input data should be an optical flow of size (batch, 2, h, w)."
mxnet.io.imagerecorditer,ctx,None,"[""{'cpu', 'gpu'}"", 'optional', ""default='gpu'""]","['cpu', 'gpu']",Context data loader optimized for.
mxnet.io.imagerecorditer,dtype,None,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type. `None` means no change.
mxnet.io.imagerecorditer,inter_method,None,"['int', 'optional', ""default='1'""]","['0', '1', '10', '2', '3', '4', '9']",The interpolation method: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.
mxnet.ndarray.op.softmax2,dtype,_Null,"[""{None, 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).
mxnet.ndarray.random.generalized_negative_binomial,dtype,_Null,"[""{'float16', 'float32', 'float64'}"", 'optional']","['float16', 'float32', 'float64']",Data type of output samples. Default is 'float32'
mxnet.contrib.ndarray.bilinearresize2d,mode,_Null,"[""{'like', 'odd_scale', 'size', 'to_even_down', 'to_even_up', 'to_odd_down', 'to_odd_up'}"", 'optional', ""default='size'""]","['like', 'odd_scale', 'simple', 'size', 'to_even_down', 'to_even_up', 'to_odd_down', 'to_odd_up']","resizing mode. ""simple"" - output height equals parameter ""height"" if ""scale_height"" parameter is not defined or input height multiplied by ""scale_height"" otherwise. Same for width;""odd_scale"" - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale > 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale < 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);""like"" - resize first input to the height and width of second input; ""to_even_down"" - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);""to_even_up"" - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);""to_odd_down"" - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);""to_odd_up"" - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);"
mxnet.ndarray.op.sample_generalized_negative_binomial,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.random.uniform,dtype,_Null,"[""{'float16', 'float32', 'float64'}"", 'optional']","['float16', 'float32', 'float64']",Data type of output samples. Default is 'float32'
mxnet.ndarray.op.leakyrelu,act_type,_Null,"[""{'elu', 'gelu', 'leaky', 'prelu', 'rrelu', 'selu'}"", 'optional', ""default='leaky'""]","['elu', 'gelu', 'leaky', 'prelu', 'rrelu', 'selu']",Activation function to be applied.
mxnet.ndarray.op.rnn,mode,_Null,"[""{'gru', 'lstm', 'rnn_relu', 'rnn_tanh'}"", 'required']","['gru', 'lstm', 'rnn_relu', 'rnn_tanh']",the type of RNN to compute
mxnet.ndarray.op.cumsum,dtype,_Null,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8']","Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used."
mxnet.ndarray.batch_dot,forward_stype,_Null,"[""{None, 'csr', 'default', 'row_sparse'}"", 'optional', ""default='None'""]","['None', 'csr', 'default', 'row_sparse']","The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type."
mxnet.ndarray.random_poisson,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.sequencereverse,axis,_Null,"['int', 'optional', ""default='0'""]",['0'],The sequence axis. Only 0 is currently supported.
mxnet.contrib.ndarray.deformableconvolution,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'None']","Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
mxnet.ndarray.l2normalization,mode,_Null,"[""{'channel', 'instance', 'spatial'}"", 'optional', ""default='instance'""]","['channel', 'instance', 'spatial']",Specify the dimension along which to compute L2 norm.
mxnet.ndarray.op.convolution,cudnn_tune,_Null,"[""{None, 'fastest', 'limited_workspace', 'off'}"", 'optional', ""default='None'""]","['None', 'fastest', 'limited_workspace', 'off']",Whether to pick convolution algo by running performance test.
mxnet.ndarray.op.convolution,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'None']","Set layout for input, output and weight. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
mxnet.ndarray.random.gamma,dtype,_Null,"[""{'float16', 'float32', 'float64'}"", 'optional']","['float16', 'float32', 'float64']",Data type of output samples. Default is 'float32'
mxnet.ndarray.sparse.dot,forward_stype,_Null,"[""{None, 'csr', 'default', 'row_sparse'}"", 'optional', ""default='None'""]","['None', 'csr', 'default', 'row_sparse']","The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type."
mxnet.ndarray.op.random_exponential,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.op.softmaxoutput,normalization,_Null,"[""{'batch', 'null', 'valid'}"", 'optional', ""default='null'""]","['batch', 'null', 'valid']",Normalizes the gradient.
mxnet.ndarray.contrib.box_nms,in_format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The input box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.ndarray.contrib.box_nms,out_format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The output box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.contrib.ndarray.box_nms,in_format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The input box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.contrib.ndarray.box_nms,out_format,_Null,"[""{'center', 'corner'}"", 'optional', ""default='corner'""]","['center', 'corner']","The output box encoding type. ""corner"" means boxes are encoded as [xmin, ymin, xmax, ymax], ""center"" means boxes are encodes as [x, y, width, height]."
mxnet.contrib.ndarray.quantized_pooling,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC', 'None']","Set layout for input and output. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
mxnet.contrib.ndarray.quantized_pooling,pool_type,_Null,"[""{'avg', 'lp', 'max', 'sum'}"", 'optional', ""default='max'""]","['avg', 'lp', 'max', 'sum']",Pooling type to be applied.
mxnet.contrib.ndarray.quantized_pooling,pooling_convention,_Null,"[""{'full', 'same', 'valid'}"", 'optional', ""default='valid'""]","['full', 'same', 'valid']",Pooling convention to be applied.
mxnet.ndarray.sample_uniform,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.op.softmax,normalization,_Null,"[""{'batch', 'null', 'valid'}"", 'optional', ""default='null'""]","['batch', 'null', 'valid']",Normalizes the gradient.
mxnet.ndarray.op.pooling,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC', 'None']","Set layout for input and output. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
mxnet.ndarray.op.pooling,pool_type,_Null,"[""{'avg', 'lp', 'max', 'sum'}"", 'optional', ""default='max'""]","['avg', 'lp', 'max', 'sum']",Pooling type to be applied.
mxnet.ndarray.op.pooling,pooling_convention,_Null,"[""{'full', 'same', 'valid'}"", 'optional', ""default='valid'""]","['full', 'same', 'valid']",Pooling convention to be applied.
mxnet.ndarray.op.softmaxactivation,mode,_Null,"[""{'channel', 'instance'}"", 'optional', ""default='instance'""]","['channel', 'instance']","Specifies how to compute the softmax. If set to `instance`, it computes softmax for each instance. If set to `channel`, It computes cross channel softmax for each position of each instance."
mxnet.ndarray.random_randint,dtype,_Null,"[""{'None', 'int32', 'int64'}"", 'optional', ""default='None'""]","['None', 'int32', 'int64']",DType of the output in case this can't be inferred. Defaults to int32 if not defined (dtype=None).
mxnet.image.imdecode,flag,None,"['int', 'optional', 'default=1']","['0', '1']",1 for three channel color output. 0 for grayscale output.
mxnet.image.imdecode,to_rgb,None,"['int', 'optional', 'default=1']","['0', '1']",1 for RGB formatted output (MXNet default). 0 for BGR formatted output (OpenCV default).
mxnet.ndarray.sample_negative_binomial,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.image.imresize,interp,None,"['int', 'optional', 'default=1']","['0', '1', '10', '2', '3', '4', '9']","Interpolation method (default=cv2.INTER_LINEAR). Possible values: 0: Nearest Neighbors Interpolation. 1: Bilinear interpolation. 2: Bicubic interpolation over 4x4 pixel neighborhood. 3: Area-based (resampling using pixel area relation). It may be a preferred method for image decimation, as it gives moire-free results. But when the image is zoomed, it is similar to the Nearest Neighbors method. (used by default). 4: Lanczos interpolation over 8x8 pixel neighborhood. 9: Cubic for enlarge, area for shrink, bilinear for others 10: Random select from interpolation method metioned above. Note: When shrinking an image, it will generally look best with AREA-based interpolation, whereas, when enlarging an image, it will generally look best with Bicubic (slow) or Bilinear (faster but still looks OK). More details can be found in the documentation of OpenCV, please refer to http://docs.opencv.org/master/da/d54/group__imgproc__transform.html."
mxnet.ndarray.softmaxactivation,mode,_Null,"[""{'channel', 'instance'}"", 'optional', ""default='instance'""]","['channel', 'instance']","Specifies how to compute the softmax. If set to `instance`, it computes softmax for each instance. If set to `channel`, It computes cross channel softmax for each position of each instance."
mxnet.ndarray.op.sample_exponential,dtype,_Null,"[""{'None', 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None).
mxnet.ndarray.random.exponential,dtype,_Null,"[""{'float16', 'float32', 'float64'}"", 'optional']","['float16', 'float32', 'float64']",Data type of output samples. Default is 'float32'
mxnet.ndarray.op.softmin,dtype,_Null,"[""{None, 'float16', 'float32', 'float64'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64']",DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None).
mxnet.ndarray.makeloss,normalization,_Null,"[""{'batch', 'null', 'valid'}"", 'optional', ""default='null'""]","['batch', 'null', 'valid']","If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements."
mxnet.ndarray.op.upsampling,multi_input_mode,None,"[""{'concat', 'sum'}"", 'optional', ""default='concat'""]","['concat', 'sum']","How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling."
mxnet.ndarray.op.upsampling,sample_type,null,"[""{'bilinear', 'nearest'}"", 'required']","['bilinear', 'nearest']",upsampling method
mxnet.ndarray.op.one_hot,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",DType of the output
mxnet.ndarray.op.argsort,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'uint8'}"", 'optional', ""default='float32'""]","['float16', 'float32', 'float64', 'int32', 'int64', 'uint8']","DType of the output indices. It is only valid when ret_typ is ""indices"" or ""both"". An error will be raised if the selected data type cannot precisely represent the indices."
mxnet.ndarray.amp_cast,dtype,_Null,"[""{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'required']","['float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type.
mxnet.ndarray.contrib.quantized_pooling,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC', 'None']","Set layout for input and output. Empty for default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
mxnet.ndarray.contrib.quantized_pooling,pool_type,_Null,"[""{'avg', 'lp', 'max', 'sum'}"", 'optional', ""default='max'""]","['avg', 'lp', 'max', 'sum']",Pooling type to be applied.
mxnet.ndarray.contrib.quantized_pooling,pooling_convention,_Null,"[""{'full', 'same', 'valid'}"", 'optional', ""default='valid'""]","['full', 'same', 'valid']",Pooling convention to be applied.
mxnet.contrib.ndarray.ctcloss,blank_label,_Null,"[""{'first', 'last'}"", 'optional', ""default='first'""]","['first', 'last']","Set the label that is reserved for blank label.If ""first"", 0-th label is reserved, and label values for tokens in the vocabulary are between `1` and `alphabet_size-1`, and the padding mask is `-1`. If ""last"", last label value `alphabet_size-1` is reserved for blank label instead, and label values for tokens in the vocabulary are between `0` and `alphabet_size-2`, and the padding mask is `0`."
mxnet.ndarray.contrib.ctcloss,blank_label,_Null,"[""{'first', 'last'}"", 'optional', ""default='first'""]","['first', 'last']","Set the label that is reserved for blank label.If ""first"", 0-th label is reserved, and label values for tokens in the vocabulary are between `1` and `alphabet_size-1`, and the padding mask is `-1`. If ""last"", last label value `alphabet_size-1` is reserved for blank label instead, and label values for tokens in the vocabulary are between `0` and `alphabet_size-2`, and the padding mask is `0`."
mxnet.contrib.ndarray.quantize,out_type,_Null,"[""{'int8', 'uint8'}"", 'optional', ""default='uint8'""]","['int8', 'uint8']",Output data type.
mxnet.ndarray.cast_storage,stype,_Null,"[""{'csr', 'default', 'row_sparse'}"", 'required']","['csr', 'default', 'row_sparse']",Output storage type.
mxnet.ndarray.dropout,mode,_Null,"[""{'always', 'training'}"", 'optional', ""default='training'""]","['always', 'training']",Whether to only turn on dropout during training or to also turn on for inference.
mxnet.io.csviter,ctx,None,"[""{'cpu', 'gpu'}"", 'optional', ""default='gpu'""]","['cpu', 'gpu']",Context data loader optimized for.
mxnet.io.csviter,dtype,None,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8']",Output data type. `None` means no change.
mxnet.ndarray.cumsum,dtype,_Null,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8']","Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used."
mxnet.ndarray.activation,act_type,_Null,"[""{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}"", 'required']","['relu', 'sigmoid', 'softrelu', 'softsign', 'tanh']",Activation function to be applied.
mxnet.ndarray.leakyrelu,act_type,_Null,"[""{'elu', 'gelu', 'leaky', 'prelu', 'rrelu', 'selu'}"", 'optional', ""default='leaky'""]","['elu', 'gelu', 'leaky', 'prelu', 'rrelu', 'selu']",Activation function to be applied.
mxnet.contrib.quantization.quantize_graph,calib_mode,entropy,['str'],"['entropy', 'naive', 'none']","If calib_mode='none', no calibration will be used and the thresholds for requantization after the corresponding layers will be calculated at runtime by calling min and max operators. The quantized models generated in this mode are normally 10-20% slower than those with calibrations during inference. If calib_mode='naive', the min and max values of the layer outputs from a calibration dataset will be directly taken as the thresholds for quantization. If calib_mode='entropy' (default mode), the thresholds for quantization will be derived such that the KL divergence between the distributions of FP32 layer outputs and quantized layer outputs is minimized based upon the calibration dataset."
mxnet.contrib.quantization.quantize_graph,quantized_dtype,int8,['str'],"['auto', 'int8', 'uint8']","The quantized destination type for input data. Currently support 'int8' , 'uint8' and 'auto'. 'auto' means automatically select output type according to calibration result. Default value is 'int8'."
mxnet.ndarray.sparse.norm,axis,_Null,"['Shape', 'None', 'optional', 'default=None']",['2'],"The axis or axes along which to perform the reduction.The default, axis=(), will compute over all elements into a scalar array with shape (1,). If axis is int, a reduction is performed on a particular axis. If axis is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed.   "
mxnet.ndarray.sparse.norm,ord,_Null,"['int', 'optional', ""default='2'""]","['1', '2']",Order of the norm. Currently ord=1 and ord=2 is supported.
mxnet.ndarray.sparse.norm,out_dtype,_Null,"[""{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'}"", 'optional', ""default='None'""]","['None', 'float16', 'float32', 'float64', 'int32', 'int64', 'int8']",The data type of the output.
mxnet.ndarray.op.deconvolution,cudnn_tune,_Null,"[""{None, 'fastest', 'limited_workspace', 'off'}"", 'optional', ""default='None'""]","['None', 'fastest', 'limited_workspace', 'off']",Whether to pick convolution algorithm by running performance test.
mxnet.ndarray.op.deconvolution,layout,_Null,"[""{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'}"", 'optional', ""default='None'""]","['NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'None']","Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
