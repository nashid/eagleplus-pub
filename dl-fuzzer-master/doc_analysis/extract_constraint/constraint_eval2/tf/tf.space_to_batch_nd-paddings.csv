descp1,descp2,default,attribute,constraint,in_doc,extracted
,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 2-D with shape `[M, 2]`, all values must be >= 0.`paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension`i + 1`, which corresponds to spatial dimension `i`.  It is required that`block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.This operation is equivalent to the following steps: Zero-pad the start and end of dimensions `[1, ..., M]` of the input according to `paddings` to produce `padded` of shape `padded_shape`.Reshape `padded` to `reshaped_padded` of shape:[batch] + [padded_shape[1] / block_shape[0],  block_shape[0], ..., padded_shape[M] / block_shape[M-1], block_shape[M-1]] + remaining_shapePermute dimensions of `reshaped_padded` to produce`permuted_reshaped_padded` of shape:block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shapeReshape `permuted_reshaped_padded` to flatten `block_shape` into the batch dimension, producing an output tensor of shape:[batch * prod(block_shape)] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape Some examples:(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and   `paddings = [[0, 0], [0, 0]]`:",,prim_dtype,"dtype(tf.int32, tf.int64)",,1
,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 2-D with shape `[M, 2]`, all values must be >= 0.`paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension`i + 1`, which corresponds to spatial dimension `i`.  It is required that`block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.This operation is equivalent to the following steps: Zero-pad the start and end of dimensions `[1, ..., M]` of the input according to `paddings` to produce `padded` of shape `padded_shape`.Reshape `padded` to `reshaped_padded` of shape:[batch] + [padded_shape[1] / block_shape[0],  block_shape[0], ..., padded_shape[M] / block_shape[M-1], block_shape[M-1]] + remaining_shapePermute dimensions of `reshaped_padded` to produce`permuted_reshaped_padded` of shape:block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shapeReshape `permuted_reshaped_padded` to flatten `block_shape` into the batch dimension, producing an output tensor of shape:[batch * prod(block_shape)] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape Some examples:(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and   `paddings = [[0, 0], [0, 0]]`:",,nonprim_dtype,tensor_t(tf.tensor),,1
,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 2-D with shape `[M, 2]`, all values must be >= 0.`paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension`i + 1`, which corresponds to spatial dimension `i`.  It is required that`block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.This operation is equivalent to the following steps: Zero-pad the start and end of dimensions `[1, ..., M]` of the input according to `paddings` to produce `padded` of shape `padded_shape`.Reshape `padded` to `reshaped_padded` of shape:[batch] + [padded_shape[1] / block_shape[0],  block_shape[0], ..., padded_shape[M] / block_shape[M-1], block_shape[M-1]] + remaining_shapePermute dimensions of `reshaped_padded` to produce`permuted_reshaped_padded` of shape:block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shapeReshape `permuted_reshaped_padded` to flatten `block_shape` into the batch dimension, producing an output tensor of shape:[batch * prod(block_shape)] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape Some examples:(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and   `paddings = [[0, 0], [0, 0]]`:",,shape,"shape([1,2,2,1], [batch*prod(&block_shape)], [batch], [m,2]), ndim(1, 2, 4)",,1
,"A `Tensor`. Must be one of the following types: `int32`, `int64`. 2-D with shape `[M, 2]`, all values must be >= 0.`paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension`i + 1`, which corresponds to spatial dimension `i`.  It is required that`block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.This operation is equivalent to the following steps: Zero-pad the start and end of dimensions `[1, ..., M]` of the input according to `paddings` to produce `padded` of shape `padded_shape`.Reshape `padded` to `reshaped_padded` of shape:[batch] + [padded_shape[1] / block_shape[0],  block_shape[0], ..., padded_shape[M] / block_shape[M-1], block_shape[M-1]] + remaining_shapePermute dimensions of `reshaped_padded` to produce`permuted_reshaped_padded` of shape:block_shape + [batch] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shapeReshape `permuted_reshaped_padded` to flatten `block_shape` into the batch dimension, producing an output tensor of shape:[batch * prod(block_shape)] + [padded_shape[1] / block_shape[0], ..., padded_shape[M] / block_shape[M-1]] + remaining_shape Some examples:(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and   `paddings = [[0, 0], [0, 0]]`:",,validvalue,"range([0,inf))",,1
